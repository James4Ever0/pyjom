#!/usr/bin/env -S node --no-warnings --loader ts-node/esm
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
/**
 *   Ducks - https://github.com/huan/ducks
 *
 *   @copyright 2020 Huan LI (李卓桓) <https://github.com/huan>
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 */
const tstest_1 = require("tstest");
const redux_1 = require("redux");
const redux_observable_1 = require("redux-observable");
// import createSagaMiddleware     from 'redux-saga'
const ducks_js_1 = require("./ducks.js");
const counterDuck = __importStar(require("../../examples/counter/mod.js"));
const dingdongDuck = __importStar(require("../../examples/ding-dong/mod.js"));
const pingpongDuck = __importStar(require("../../examples/ping-pong/mod.js"));
const switcherDuck = __importStar(require("../../examples/switcher/mod.js"));
(0, tstest_1.test)('construction()', async (t) => {
    t.throws(() => new ducks_js_1.Ducks({}), 'should not happy with empty duckery');
    t.doesNotThrow(() => new ducks_js_1.Ducks({
        counter: counterDuck,
        dong: dingdongDuck,
        pong: pingpongDuck,
    }), 'should be able to construct with ducks');
});
(0, tstest_1.test)('reducer()', async (t) => {
    const ducks = new ducks_js_1.Ducks({
        counter: counterDuck,
    });
    const initialState = {};
    const store = (0, redux_1.createStore)((state) => ({ ...state }), initialState, (0, redux_1.compose)(ducks.enhancer()));
    void store;
    // store.subscribe(() => console.info(store.getState()))
    const { counter } = ducks.ducksify();
    t.equal(counter.selectors.getCounter(), 0, 'should get counter 0 after initialization');
    counter.operations.tap();
    t.equal(counter.selectors.getCounter(), 1, 'should get counter 1 after tap');
});
(0, tstest_1.test)('constructor() with option.middleware', async (t) => {
    const epicMiddleware = (0, redux_observable_1.createEpicMiddleware)();
    /**
     * Huan(202109): https://github.com/huan/ducks/issues/4
     */
    // const sagaMiddleware = createSagaMiddleware()
    const ducks = new ducks_js_1.Ducks({
        dong: dingdongDuck,
        pong: pingpongDuck,
    });
    t.doesNotThrow(() => (0, redux_1.createStore)(state => state, (0, redux_1.compose)(ducks.enhancer(), (0, redux_1.applyMiddleware)(epicMiddleware))), 'should not throw when satisfied the middleware in Ducks constructor options');
});
/**
 * Huan(202109): disable saga
 *  See: https://github.com/huan/ducks/issues/4
 */
// test('Sagas middlewares', async t => {
//   const sagaMiddleware = createSagaMiddleware()
//   const ducks = new Ducks({
//     pong    : pingpongDuck,
//   })
//   const {
//     pong,
//   }         = ducks.ducksify()
//   const store = createStore(
//     state => state,
//     compose(
//       ducks.enhancer(),
//       applyMiddleware(
//         sagaMiddleware,
//       ),
//     ),
//   )
//   void store
//   t.equal(pong.selectors.getPong(), 0, 'should get pong 0 on initialization')
//   pong.operations.ping()
//   t.equal(pong.selectors.getPong(), 1, 'should get pong 1 after operations.ping()')
// })
(0, tstest_1.test)('Epics middlewares', async (t) => {
    const ducks = new ducks_js_1.Ducks({ dong: dingdongDuck });
    const dong = ducks.ducksify('dong');
    const epicMiddleware = (0, redux_observable_1.createEpicMiddleware)();
    /* const store = */ (0, redux_1.createStore)(state => state, (0, redux_1.compose)(ducks.enhancer(), (0, redux_1.applyMiddleware)(epicMiddleware)));
    t.equal(dong.selectors.getDong(), 0, 'should get dong 0 on initialization');
    dong.operations.ding();
    t.equal(dong.selectors.getDong(), 1, 'should get dong 1 after operations.ding()');
});
(0, tstest_1.test)('Ducks with other reducers work together', async (t) => {
    const ducks = new ducks_js_1.Ducks({
        counter: counterDuck,
    });
    const { counter } = ducks.ducksify();
    const store = (0, redux_1.createStore)((0, redux_1.combineReducers)({
        switch: switcherDuck.default,
    }), (0, redux_1.compose)(ducks.enhancer()));
    void store;
    // store.subscribe(() => console.info(store.getState()))
    t.equal(counter.selectors.getCounter(), 0, 'should get counter 0 on initialization');
    t.equal(store.getState().switch.status, false, 'should get false from switch status on initialization');
    counter.operations.tap();
    t.equal(counter.selectors.getCounter(), 1, 'should get counter 1 after tap');
    store.dispatch(switcherDuck.actions.toggle());
    t.equal(store.getState().switch.status, true, 'should get true from switch status after dispatch actions.toggle()');
});
(0, tstest_1.test)('configureStore() smoke testing', async (t) => {
    const ducks = new ducks_js_1.Ducks({
        counter: counterDuck,
    });
    const { counter } = ducks.ducksify();
    const store = ducks.configureStore();
    void store;
    // store.subscribe(() => console.info(store.getState()))
    t.equal(counter.selectors.getCounter(), 0, 'should get counter 0 on initialization');
    counter.operations.tap();
    t.equal(counter.selectors.getCounter(), 1, 'should get counter 1 after tap');
});
(0, tstest_1.test)('configureStore() called twice', async (t) => {
    const ducks = new ducks_js_1.Ducks({
        counter: counterDuck,
    });
    t.doesNotThrow(() => ducks.configureStore(), 'should not throw for the first time');
    t.throws(() => ducks.configureStore(), 'should throw for the second time');
});
(0, tstest_1.test)('ducksify(namespace & duck)', async (t) => {
    const ducks = new ducks_js_1.Ducks({
        counter: counterDuck,
        switcher: switcherDuck,
    });
    const { counter, switcher, } = ducks.ducksify();
    const counterByName = ducks.ducksify('counter');
    const switcherByName = ducks.ducksify('switcher');
    const counterByDuck = ducks.ducksify(counterDuck);
    const switcherByDuck = ducks.ducksify(switcherDuck);
    t.equal(counter, counterByName, 'counter should be same with by name');
    t.equal(counter, counterByDuck, 'counter should be same with by duck');
    t.equal(switcher, switcherByName, 'switcher should be same with by name');
    t.equal(switcher, switcherByDuck, 'switcher should be same with by duck');
});
//# sourceMappingURL=ducks.spec.js.map