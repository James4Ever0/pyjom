#!/usr/bin/env -S node --no-warnings --loader ts-node/esm
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tstest_1 = require("tstest");
const stream_1 = require("stream");
const file_box_1 = require("file-box");
const wechaty_grpc_1 = require("wechaty-grpc");
const file_box_chunk_js_1 = require("./file-box-chunk.js");
const chunk_pb_js_1 = require("./chunk-pb.js");
(0, tstest_1.test)('packFileBoxChunk()', async (t) => {
    const FILE_BOX_DATA = 'test';
    const FILE_BOX_NAME = 'test.dat';
    const fileBox = file_box_1.FileBox.fromBuffer(Buffer.from(FILE_BOX_DATA), FILE_BOX_NAME);
    const chunkStream = await (0, file_box_chunk_js_1.packFileBoxToChunk)(fileBox);
    const pbStream = await (0, chunk_pb_js_1.packFileBoxChunkToPb)(wechaty_grpc_1.puppet.MessageFileStreamResponse)(chunkStream);
    let name = '';
    let buffer = '';
    pbStream.on('data', (data) => {
        if (data.hasFileBoxChunk()) {
            const fileBoxChunk = data.getFileBoxChunk();
            if (fileBoxChunk.hasData()) {
                buffer += fileBoxChunk.getData();
            }
            else if (fileBoxChunk.hasName()) {
                name = fileBoxChunk.getName();
            }
        }
    });
    await new Promise(resolve => chunkStream.on('end', resolve));
    t.equal(name, FILE_BOX_NAME, 'should get file box name');
    t.equal(buffer, FILE_BOX_DATA, 'should get file box data');
});
(0, tstest_1.test)('unpackFileBoxChunkFromPb()', async (t) => {
    const FILE_BOX_DATA = 'test';
    const FILE_BOX_NAME = 'test.dat';
    const fileBox = file_box_1.FileBox.fromBuffer(Buffer.from(FILE_BOX_DATA), FILE_BOX_NAME);
    const chunkStream = await (0, file_box_chunk_js_1.packFileBoxToChunk)(fileBox);
    const request = new wechaty_grpc_1.puppet.MessageSendFileStreamRequest();
    const packedStream = new stream_1.PassThrough({ objectMode: true });
    chunkStream.on('data', (data) => {
        request.setFileBoxChunk(data);
        packedStream.write(request);
    }).on('end', () => {
        packedStream.end();
    });
    const outputChunkStream = (0, chunk_pb_js_1.unpackFileBoxChunkFromPb)(packedStream);
    const outputFileBox = await (0, file_box_chunk_js_1.unpackFileBoxFromChunk)(outputChunkStream);
    t.equal((await outputFileBox.toBuffer()).toString(), FILE_BOX_DATA, 'should get file box data');
});
(0, tstest_1.test)('packFileBoxChunk() <-> unpackFileBoxChunkFromPb()', async (t) => {
    const FILE_BOX_DATA = 'test';
    const FILE_BOX_NAME = 'test.dat';
    const fileBox = file_box_1.FileBox.fromBuffer(Buffer.from(FILE_BOX_DATA), FILE_BOX_NAME);
    const chunkStream = await (0, file_box_chunk_js_1.packFileBoxToChunk)(fileBox);
    const packedStream = (0, chunk_pb_js_1.packFileBoxChunkToPb)(wechaty_grpc_1.puppet.MessageFileStreamResponse)(chunkStream);
    const unpackedStream = (0, chunk_pb_js_1.unpackFileBoxChunkFromPb)(packedStream);
    const restoredBox = await (0, file_box_chunk_js_1.unpackFileBoxFromChunk)(unpackedStream);
    t.equal(fileBox.name, restoredBox.name, 'should be same name');
    const EXPECTED_BASE64 = await fileBox.toBase64();
    const actualBase64 = await restoredBox.toBase64();
    t.equal(EXPECTED_BASE64, actualBase64, 'should be same content');
});
(0, tstest_1.test)('packFileBoxChunk(): should not throw if no read on the stream', async (t) => {
    t.plan(1);
    const stream = await getTestChunkStream({});
    let outStream;
    try {
        outStream = (0, chunk_pb_js_1.packFileBoxChunkToPb)(wechaty_grpc_1.puppet.MessageFileStreamResponse)(stream);
    }
    catch (e) {
        t.ok(e.message);
        return;
    }
    outStream.on('error', _ => { });
    t.pass();
});
(0, tstest_1.test)('packFileBoxChunk(): should emit error in the output stream', async (t) => {
    const EXPECTED_MESSAGE = 'test emit error';
    const stream = await getTestChunkStream({ errorMessage: EXPECTED_MESSAGE });
    const outStream = (0, chunk_pb_js_1.packFileBoxChunkToPb)(wechaty_grpc_1.puppet.MessageFileStreamResponse)(stream);
    const error = await new Promise(resolve => outStream.on('error', resolve));
    // await new Promise(resolve => outStream.on('end', resolve))
    t.equal(error.message, EXPECTED_MESSAGE, 'should emit error message');
});
(0, tstest_1.test)('unpackFileBoxChunkFromPb(): should not throw if no read on the stream', async (t) => {
    t.plan(1);
    const stream = await getTestPackedStream({});
    let outStream;
    try {
        outStream = (0, chunk_pb_js_1.unpackFileBoxChunkFromPb)(stream);
        t.pass('should no rejection');
    }
    catch (e) {
        t.fail(e.message);
        return;
    }
    outStream.on('error', _ => { });
});
(0, tstest_1.test)('unpackFileBoxChunkFromPb(): should emit error in the output stream', async (t) => {
    const errorMessage = 'test emit error';
    const stream = await getTestPackedStream({ errorMessage });
    const outStream = (0, chunk_pb_js_1.packFileBoxChunkToPb)(wechaty_grpc_1.puppet.MessageFileStreamResponse)(stream);
    try {
        await new Promise((resolve, reject) => {
            outStream.on('error', reject);
            outStream.on('end', resolve);
        });
        t.fail('should reject the promise');
    }
    catch (e) {
        t.equal(e.message, errorMessage, 'should get the expected rejection error message');
    }
});
async function getTestChunkStream(options) {
    const { errorMessage } = options;
    const FILE_BOX_DATA = 'test';
    const FILE_BOX_NAME = 'test.dat';
    const fileBox = file_box_1.FileBox.fromBuffer(Buffer.from(FILE_BOX_DATA), FILE_BOX_NAME);
    const chunkStream = await (0, file_box_chunk_js_1.packFileBoxToChunk)(fileBox);
    setImmediate(() => {
        chunkStream.emit('error', new Error(errorMessage));
    });
    return chunkStream;
}
async function getTestPackedStream(options) {
    const { errorMessage } = options;
    const FILE_BOX_DATA = 'test';
    const FILE_BOX_NAME = 'test.dat';
    const fileBox = file_box_1.FileBox.fromBuffer(Buffer.from(FILE_BOX_DATA), FILE_BOX_NAME);
    const chunkStream = await (0, file_box_chunk_js_1.packFileBoxToChunk)(fileBox);
    const packedStream = new stream_1.PassThrough({ objectMode: true });
    chunkStream.on('data', d => {
        const packedChunk = new wechaty_grpc_1.puppet.MessageFileStreamResponse();
        packedChunk.setFileBoxChunk(d);
        packedStream.write(packedChunk);
    }).on('error', e => {
        packedStream.emit('error', e);
    });
    setImmediate(() => {
        chunkStream.emit('error', new Error(errorMessage));
    });
    return packedStream;
}
//# sourceMappingURL=chunk-pb.spec.js.map