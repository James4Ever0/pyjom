#!/usr/bin/env -S node --no-warnings --loader ts-node/esm
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tstest_1 = require("tstest");
const grpc_js_js_1 = require("./grpc-js.js");
const wechaty_token_js_1 = require("./wechaty-token.js");
const resolver_wechaty_js_1 = require("./resolver-wechaty.js");
(0, tstest_1.test)('wechaty resolver smoke testing', async (t) => {
    const TOKEN = '__token__';
    const HOST = '10.1.2.3';
    const PORT = 1024;
    const sandbox = tstest_1.sinon.createSandbox();
    const discoverStub = sandbox.stub(wechaty_token_js_1.WechatyToken.prototype, 'discover');
    discoverStub.resolves({
        host: HOST,
        port: PORT,
    });
    resolver_wechaty_js_1.WechatyResolver.setup();
    const target = grpc_js_js_1.resolverManager.mapUriDefaultScheme((0, grpc_js_js_1.parseUri)(`wechaty:///${TOKEN}`));
    t.equal(target.authority, '', 'should get empty authority');
    t.equal(target.scheme, 'wechaty', 'should get schema');
    t.equal(target.path, TOKEN, 'should get token');
    const rr = {};
    const future = new Promise((resolve, reject) => {
        rr.resolve = resolve;
        rr.reject = reject;
    });
    const listener = {
        onError: (error) => {
            rr.reject(new Error(`Failed with status ${error.details}`));
        },
        onSuccessfulResolution: (addressList, _serviceConfig, _serviceConfigError) => {
            // Only handle the first resolution result
            listener.onSuccessfulResolution = () => { };
            rr.resolve(addressList);
        },
    };
    const resolver = grpc_js_js_1.resolverManager.createResolver(target, listener, {});
    resolver.updateResolution();
    const result = await future;
    t.same(result[0].host, HOST, 'should get puppet server host');
    t.same(result[0].port, PORT, 'should get puppet server port');
    sandbox.restore();
});
(0, tstest_1.test)('wechaty resolver with custom authority', async (t) => {
    const AUTHORITY = 'custom.authority.com';
    const rr = {};
    const future = new Promise((resolve, reject) => {
        rr.resolve = resolve;
        rr.reject = reject;
    });
    const sandbox = tstest_1.sinon.createSandbox();
    sandbox.stub(wechaty_token_js_1.WechatyToken.prototype, 'discover')
        .callsFake(function () {
        rr.resolve(this.authority);
        return Promise.resolve({
            host: '1.1.1.1',
            port: 10,
        });
    });
    resolver_wechaty_js_1.WechatyResolver.setup();
    const target = grpc_js_js_1.resolverManager.mapUriDefaultScheme((0, grpc_js_js_1.parseUri)(`wechaty://${AUTHORITY}/token`));
    const listener = {
        onError: () => { },
        onSuccessfulResolution: () => { },
    };
    const resolver = grpc_js_js_1.resolverManager.createResolver(target, listener, {});
    resolver.updateResolution();
    const result = await future;
    t.equal(result, AUTHORITY, 'should pass authority down to WechatyToken');
    sandbox.restore();
});
//# sourceMappingURL=resolver-wechaty.spec.js.map