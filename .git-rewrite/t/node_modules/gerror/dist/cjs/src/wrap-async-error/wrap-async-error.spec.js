#!/usr/bin/env -S node --no-warnings --loader ts-node/esm
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tstest_1 = require("tstest");
const wrap_async_error_js_1 = require("./wrap-async-error.js");
(0, tstest_1.test)('wrapAsyncError() smoke testing', async (t) => {
    const spy = tstest_1.sinon.spy();
    const wrapAsync = (0, wrap_async_error_js_1.wrapAsyncError)(spy);
    const DATA = 'test';
    const promise = Promise.resolve(DATA);
    const wrappedPromise = wrapAsync(promise);
    t.equal(await wrappedPromise, undefined, 'should resolve Promise<any> to void');
    const rejection = Promise.reject(new Error('test'));
    const wrappedRejection = wrapAsync(rejection);
    t.equal(wrappedRejection, undefined, 'should be void and not to reject');
    t.equal(spy.callCount, 0, 'should have no error before sleep');
    await new Promise(resolve => setImmediate(resolve)); // wait async event loop task to be executed
    t.equal(spy.callCount, 1, 'should emit error when promise reject with error');
});
(0, tstest_1.test)('wrapAsyncError() with async function', async (t) => {
    const spy = tstest_1.sinon.spy();
    const wrapAsync = (0, wrap_async_error_js_1.wrapAsyncError)(spy);
    const ERROR = new Error('test error');
    t.doesNotThrow(() => wrapAsync(async () => 42)(), 'should not throw when wrap async function');
    t.equal(spy.callCount, 0, 'should not emit error when wrap async function with no exception');
    t.doesNotThrow(() => wrapAsync(async () => { throw ERROR; })(), 'should not throw when wrap async function with exception');
    await new Promise(resolve => setImmediate(resolve)); // wait async event loop task to be executed
    t.equal(spy.callCount, 1, 'should emit error when wrap async function with exception');
    t.equal(spy.args[0][0], ERROR, 'should emit error when wrap async function with exception');
});
(0, tstest_1.test)('wrapAsyncError() with a Promise value', async (t) => {
    const spy = tstest_1.sinon.spy();
    const wrapAsync = (0, wrap_async_error_js_1.wrapAsyncError)(spy);
    const ERROR = new Error('test error');
    t.doesNotThrow(() => wrapAsync(Promise.resolve(42)), 'should not throw when wrap a resolved promise');
    t.equal(spy.callCount, 0, 'should not emit error when wrap resolved promise with no rejection');
    t.doesNotThrow(() => wrapAsync(Promise.reject(ERROR)), 'should not throw when wrap rejected promise');
    await new Promise(resolve => setImmediate(resolve)); // wait async event loop task to be executed
    t.equal(spy.callCount, 1, 'should emit error when wrap promise with rejection');
    t.equal(spy.args[0][0], ERROR, 'should emit rejection error when wrap promise with rejection');
});
//# sourceMappingURL=wrap-async-error.spec.js.map