#!/usr/bin/env -S node --no-warnings --loader ts-node/esm
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tstest_1 = require("tstest");
const events_1 = require("events");
const brolog_1 = require("brolog");
const service_ctl_js_1 = require("./service-ctl.js");
(0, tstest_1.test)('ServiceCtl smoke testing', async (t) => {
    const sandbox = tstest_1.sinon.createSandbox();
    const onStartSpy = sandbox.spy();
    const onStopSpy = sandbox.spy();
    class ServiceCtlImpl extends service_ctl_js_1.ServiceCtl {
        async onStart() {
            onStartSpy();
        }
        async onStop() {
            onStopSpy();
        }
    }
    const ctl = new ServiceCtlImpl();
    await ctl.start();
    t.ok(onStartSpy.calledOnce, 'should call onStart()');
    t.ok(onStopSpy.notCalled, 'should not call onStop()');
    await ctl.stop();
    t.ok(onStopSpy.calledOnce, 'should call onStop()');
    await t.resolves(() => ctl.reset(), 'should not reject when calling reset() with an inactive service');
    await ctl.start();
    sandbox.resetHistory();
    await t.resolves(() => ctl.reset(), 'should be able to reset with an active service');
    t.ok(onStartSpy.calledOnce, 'should call onStart() via reset()');
    t.ok(onStopSpy.calledOnce, 'should call onStop() via reset()');
});
(0, tstest_1.test)('ServiceCtlMixin smoke testing', async (t) => {
    const sandbox = tstest_1.sinon.createSandbox();
    const childOnStartSpy = sandbox.spy();
    const childOnStopSpy = sandbox.spy();
    const parentStartSpy = sandbox.spy();
    const parentStopSpy = sandbox.spy();
    const MyEventEmitter = events_1.EventEmitter;
    class MyServiceBase extends MyEventEmitter {
        start() { parentStartSpy(); }
        stop() { parentStopSpy(); }
    }
    const mixinBase = (0, service_ctl_js_1.serviceCtlMixin)('MixinTest', { log: brolog_1.log })(MyServiceBase);
    class ServiceCtlImpl extends mixinBase {
        async onStart() {
            childOnStartSpy();
            this.emit('test', 42);
        }
        async onStop() {
            childOnStopSpy();
            this.emit('test', 'on-stop');
        }
    }
    const ctl = new ServiceCtlImpl();
    ctl.on('test', data => {
        const typeTest = true;
        t.ok(typeTest, 'test event should emit string type payload');
    });
    await ctl.start();
    t.ok(childOnStartSpy.calledOnce, 'should call onStart()');
    t.ok(parentStartSpy.calledOnce, 'should call parent start()');
    t.ok(childOnStopSpy.notCalled, 'should not call onStop()');
    t.ok(parentStopSpy.notCalled, 'should not call parent stop()');
    await ctl.stop();
    t.ok(childOnStopSpy.calledOnce, 'should call onStop()');
    t.ok(parentStopSpy.calledOnce, 'should call parent stop()');
    await t.resolves(() => ctl.reset(), 'should not reject when calling reset() with an inactive service');
    await ctl.start();
    sandbox.resetHistory();
    await t.resolves(() => ctl.reset(), 'should be able to reset with an active service');
    t.ok(childOnStartSpy.calledOnce, 'should call onStart() via reset()');
    t.ok(childOnStopSpy.calledOnce, 'should call onStop() via reset()');
    t.ok(parentStartSpy.calledOnce, 'should call parent start() via reset()');
    t.ok(parentStopSpy.calledOnce, 'should call parent stop() via reset()');
});
//# sourceMappingURL=service-ctl.spec.js.map