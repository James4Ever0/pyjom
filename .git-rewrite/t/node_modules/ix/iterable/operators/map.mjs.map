{"version":3,"sources":["iterable/operators/map.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,SAAS,EAAE,MAAM,cAAc,CAAC;AACzC,OAAO,EAAE,YAAY,EAAE,MAAM,yBAAyB,CAAC;AAGvD,MAAM,OAAO,WAA8B,SAAQ,SAAkB;IAC3D,OAAO,CAAoB;IAC3B,SAAS,CAA6C;IAE9D,YAAY,MAAyB,EAAE,QAAoD;QACzF,KAAK,EAAE,CAAC;QACR,IAAI,CAAC,OAAO,GAAG,MAAM,CAAC;QACtB,IAAI,CAAC,SAAS,GAAG,QAAQ,CAAC;IAC5B,CAAC;IAED,CAAC,CAAC,MAAM,CAAC,QAAQ,CAAC;QAChB,IAAI,CAAC,GAAG,CAAC,CAAC;QACV,KAAK,MAAM,IAAI,IAAI,IAAI,CAAC,OAAO,EAAE;YAC/B,MAAM,IAAI,CAAC,SAAS,CAAC,IAAI,EAAE,CAAC,EAAE,CAAC,CAAC;SACjC;IACH,CAAC;CACF;AAED;;;;;;;;;;;GAWG;AACH,MAAM,UAAU,GAAG,CACjB,QAAoD,EACpD,OAAa;IAEb,OAAO,SAAS,mBAAmB,CAAC,MAAyB;QAC3D,OAAO,IAAI,WAAW,CAAmB,MAAM,EAAE,YAAY,CAAC,QAAQ,EAAE,OAAO,EAAE,CAAC,CAAC,CAAC,CAAC;IACvF,CAAC,CAAC;AACJ,CAAC","file":"map.js","sourcesContent":["import { IterableX } from '../iterablex';\nimport { bindCallback } from '../../util/bindcallback';\nimport { OperatorFunction } from '../../interfaces';\n\nexport class MapIterable<TSource, TResult> extends IterableX<TResult> {\n  private _source: Iterable<TSource>;\n  private _selector: (value: TSource, index: number) => TResult;\n\n  constructor(source: Iterable<TSource>, selector: (value: TSource, index: number) => TResult) {\n    super();\n    this._source = source;\n    this._selector = selector;\n  }\n\n  *[Symbol.iterator]() {\n    let i = 0;\n    for (const item of this._source) {\n      yield this._selector(item, i++);\n    }\n  }\n}\n\n/**\n * Projects each element of an async-enumerable sequence into a new form.\n *\n * @template TSource The type of the elements in the source sequence.\n * @template TResult The type of the elements in the result sequence, obtained by running the selector\n * function for each element in the source sequence.\n * @param {((value: TSource, index: number) => TResult)} selector A transform function\n * to apply to each source element.\n * @param {*} [thisArg] Optional this for binding to the selector.\n * @returns {OperatorFunction<TSource, TResult>} An iterable sequence whose elements are the result of invoking the transform\n * function on each element of source.\n */\nexport function map<TSource, TResult>(\n  selector: (value: TSource, index: number) => TResult,\n  thisArg?: any\n): OperatorFunction<TSource, TResult> {\n  return function mapOperatorFunction(source: Iterable<TSource>): IterableX<TResult> {\n    return new MapIterable<TSource, TResult>(source, bindCallback(selector, thisArg, 2));\n  };\n}\n"]}