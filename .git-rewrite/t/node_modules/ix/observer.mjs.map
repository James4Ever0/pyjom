{"version":3,"sources":["observer.ts"],"names":[],"mappings":"AAmBA,kEAAkE;AAClE,oEAAoE;AACpE,MAAM,CAAC,MAAM,UAAU,GAAG,CAAC,OAAO,MAAM,KAAK,UAAU,IAAI,MAAM,CAAC,UAAU,CAAC,IAAI,cAAc,CAAC","file":"observer.js","sourcesContent":["import { Subscription } from './subscription';\n\n// Older versions of Rx will polyfill Symbol.observable, which gets\n// compiled into our UMD bundle. At runtime, our UMD bundle defines its\n// version of Symbol.observable, and since it's not getting it from Rx via\n// `require()` anymore, Rx defines and looks for a different Symbol.observable,\n// instance, leading to mismatches.\n// Assigning the global Symbol.observable to the one we bundle in here means\n// that Rx's polyfill will pick it up. Alternatively if there's already a global\n// Symbol.observable (like if Rx was required first), we should use that one inside Ix.\n\n// Symbol.observable addition\n// Note: This will add Symbol.observable globally for all TypeScript users\ndeclare global {\n  interface SymbolConstructor {\n    readonly observable: symbol;\n  }\n}\n\n// Symbol.observable or a string \"@@observable\". Used for interop.\n// Referenced via string indexer so closure-compiler doesn't mangle.\nexport const observable = (typeof Symbol === 'function' && Symbol.observable) || '@@observable';\n\nexport interface NextObserver<T> {\n  next: (value: T) => any;\n  error?: (err: any) => any;\n  complete?: () => any;\n}\n\nexport interface ErrorObserver<T> {\n  next?: (value: T) => any;\n  error: (err: any) => any;\n  complete?: () => any;\n}\n\nexport interface CompletionObserver<T> {\n  next?: (value: T) => any;\n  error?: (err: any) => any;\n  complete: () => any;\n}\n\nexport type PartialObserver<T> = NextObserver<T> | ErrorObserver<T> | CompletionObserver<T>;\n\nexport interface NextAsyncObserver<T> {\n  next: (value: T) => any | Promise<any>;\n  error?: (err: any) => any | Promise<any>;\n  complete?: () => any | Promise<any>;\n}\n\nexport interface ErrorAsyncObserver<T> {\n  next?: (value: T) => any | Promise<any>;\n  error: (err: any) => any | Promise<any>;\n  complete?: () => any | Promise<any>;\n}\n\nexport interface CompletionAsyncObserver<T> {\n  next?: (value: T) => any | Promise<any>;\n  error?: (err: any) => any | Promise<any>;\n  complete: () => any | Promise<any>;\n}\n\nexport type PartialAsyncObserver<T> =\n  | NextAsyncObserver<T>\n  | ErrorAsyncObserver<T>\n  | CompletionAsyncObserver<T>;\n\nexport interface Observer<T> {\n  closed?: boolean;\n  next: (value: T) => void;\n  error: (err: any) => void;\n  complete: () => void;\n}\n\nexport interface Observable<T> {\n  subscribe(observer?: PartialObserver<T>): Subscription;\n  subscribe(\n    next?: null | ((value: T) => void),\n    error?: null | ((error: any) => void),\n    complete?: null | (() => void)\n  ): Subscription;\n}\n"]}