{"version":3,"sources":["asynciterable/elementat.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,aAAa,EAAE,MAAM,uBAAuB,CAAC;AACtD,OAAO,EAAE,cAAc,EAAE,MAAM,eAAe,CAAC;AAE/C;;;;;;;;;GASG;AACH,MAAM,CAAC,KAAK,UAAU,SAAS,CAC7B,MAAwB,EACxB,KAAa,EACb,MAAoB;IAEpB,cAAc,CAAC,MAAM,CAAC,CAAC;IACvB,IAAI,CAAC,GAAG,KAAK,CAAC;IACd,IAAI,KAAK,EAAE,MAAM,IAAI,IAAI,aAAa,CAAC,MAAM,EAAE,MAAM,CAAC,EAAE;QACtD,IAAI,CAAC,KAAK,CAAC,EAAE;YACX,OAAO,IAAI,CAAC;SACb;QACD,CAAC,EAAE,CAAC;KACL;IACD,OAAO,SAAS,CAAC;AACnB,CAAC","file":"elementat.js","sourcesContent":["import { wrapWithAbort } from './operators/withabort';\nimport { throwIfAborted } from '../aborterror';\n\n/**\n * Returns the element at a specified index in a sequence or undefined if the index is out of range.\n *\n * @template T The type of the elements in the source sequence.\n * @param {AsyncIterable<T>} source async-iterable sequence to return the element from.\n * @param {number} index The zero-based index of the element to retrieve.\n * @param {AbortSignal} [signal] The optional abort signal to be used for cancelling the sequence at any time.\n * @returns {(Promise<T | undefined>)} An async-iterable sequence that produces the element at the specified\n * position in the source sequence, or undefined if the index is outside the bounds of the source sequence.\n */\nexport async function elementAt<T>(\n  source: AsyncIterable<T>,\n  index: number,\n  signal?: AbortSignal\n): Promise<T | undefined> {\n  throwIfAborted(signal);\n  let i = index;\n  for await (const item of wrapWithAbort(source, signal)) {\n    if (i === 0) {\n      return item;\n    }\n    i--;\n  }\n  return undefined;\n}\n"]}