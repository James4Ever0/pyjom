{"version":3,"sources":["asynciterable/tomap.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,aAAa,EAAE,MAAM,kBAAkB,CAAC;AACjD,OAAO,EAAE,aAAa,EAAE,MAAM,uBAAuB,CAAC;AACtD,OAAO,EAAE,cAAc,EAAE,MAAM,eAAe,CAAC;AA+B/C;;;;;;;;;GASG;AACH,MAAM,CAAC,KAAK,UAAU,KAAK,CACzB,MAA8B,EAC9B,OAAwC;IAExC,MAAM,EACJ,CAAC,QAAQ,CAAC,EAAE,MAAM,EAClB,CAAC,iBAAiB,CAAC,EAAE,eAAe,GAAG,aAAoB,EAC3D,CAAC,aAAa,CAAC,EAAE,WAAW,GAAG,aAAoB,GACpD,GAAG,OAAO,IAAI,EAAE,CAAC;IAClB,cAAc,CAAC,MAAM,CAAC,CAAC;IACvB,MAAM,GAAG,GAAG,IAAI,GAAG,EAA4B,CAAC;IAChD,IAAI,KAAK,EAAE,MAAM,IAAI,IAAI,aAAa,CAAC,MAAM,EAAE,MAAM,CAAC,EAAE;QACtD,MAAM,KAAK,GAAG,MAAM,eAAgB,CAAC,IAAI,EAAE,MAAM,CAAC,CAAC;QACnD,MAAM,GAAG,GAAG,MAAM,WAAW,CAAC,IAAI,EAAE,MAAM,CAAC,CAAC;QAC5C,GAAG,CAAC,GAAG,CAAC,GAAG,EAAE,KAAK,CAAC,CAAC;KACrB;IACD,OAAO,GAAG,CAAC;AACb,CAAC","file":"tomap.js","sourcesContent":["import { identityAsync } from '../util/identity';\nimport { wrapWithAbort } from './operators/withabort';\nimport { throwIfAborted } from '../aborterror';\n\n/**\n * The options for the toMap method which include an optional element selector and abort signal for cancellation.\n *\n * @interface ToMapOptions\n * @template TSource\n * @template TElement\n */\nexport interface ToMapOptions<TSource, TElement> {\n  /**\n   * The selector to get the key for the map.\n   *\n   * @memberof ToMapOptions\n   */\n  keySelector: (item: TSource, signal?: AbortSignal) => TElement | Promise<TElement>;\n  /**\n   * The selector used to get the element for the Map.\n   *\n   * @memberof ToMapOptions\n   */\n  elementSelector?: (item: TSource, signal?: AbortSignal) => TElement | Promise<TElement>;\n  /**\n   * An optional abort signal to cancel the operation at any time.\n   *\n   * @type {AbortSignal}\n   * @memberof ToMapOptions\n   */\n  signal?: AbortSignal;\n}\n\n/**\n * Converts an async-iterable to a map with a key selector and options for an element selector and cancellation.\n *\n * @template TSource The type of elements in the source collection.\n * @template TKey The type of key used for the map.\n * @template TElement The type of element to use for the map.\n * @param {AsyncIterable<TSource>} source The source collection to turn into a map.\n * @param {ToMapOptions<TSource, TElement>} [options]\n * @returns {(Promise<Map<TKey, TElement | TSource>>)}\n */\nexport async function toMap<TSource, TKey, TElement = TSource>(\n  source: AsyncIterable<TSource>,\n  options: ToMapOptions<TSource, TElement>\n): Promise<Map<TKey, TElement | TSource>> {\n  const {\n    ['signal']: signal,\n    ['elementSelector']: elementSelector = identityAsync as any,\n    ['keySelector']: keySelector = identityAsync as any,\n  } = options || {};\n  throwIfAborted(signal);\n  const map = new Map<TKey, TElement | TSource>();\n  for await (const item of wrapWithAbort(source, signal)) {\n    const value = await elementSelector!(item, signal);\n    const key = await keySelector(item, signal);\n    map.set(key, value);\n  }\n  return map;\n}\n"]}