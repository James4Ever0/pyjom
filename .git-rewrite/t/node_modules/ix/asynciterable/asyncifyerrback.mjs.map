{"version":3,"sources":["asynciterable/asyncifyerrback.ts"],"names":[],"mappings":"AACA,OAAO,EAAE,SAAS,EAAE,MAAM,aAAa,CAAC;AACxC,OAAO,EAAE,OAAO,EAAE,MAAM,qBAAqB,CAAC;AAE9C;;;;;;GAMG;AACH,MAAM,UAAU,eAAe,CAC7B,IAA2B;IAE3B,OAAO,UAAU,GAAG,IAAW;QAC7B,MAAM,IAAI,GAAG,IAAI,SAAS,EAAW,CAAC;QAEtC,MAAM,OAAO,GAAG,UAAU,GAAQ,EAAE,GAAG,SAAgB;YACrD,IAAI,GAAG,EAAE;gBACP,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;gBAChB,IAAI,CAAC,GAAG,EAAE,CAAC;aACZ;iBAAM;gBACL,IAAI,CAAC,KAAK,CAAC,SAAS,CAAC,MAAM,KAAK,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC;gBAC9D,IAAI,CAAC,GAAG,EAAE,CAAC;aACZ;QACH,CAAC,CAAC;QAEF,IAAI;YACF,IAAI,CAAC,GAAG,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC,CAAC;SAC/B;QAAC,OAAO,CAAC,EAAE;YACV,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;YACd,IAAI,CAAC,GAAG,EAAE,CAAC;SACZ;QAED,MAAM,OAAO,GAAG,KAAK,SAAS,CAAC;YAC7B,KAAK,IAAI,IAAI,EAAE,CAAC,CAAC,IAAI,GAAG,MAAM,IAAI,CAAC,IAAI,EAAE,CAAC,CAAC,IAAI,GAAI;gBACjD,MAAM,IAAI,CAAC,KAAK,CAAC;aAClB;QACH,CAAC,CAAC;QAEF,OAAO,OAAO,EAAW,CAAC,OAAO,EAAE,CAAC,CAAC;IACvC,CAAC,CAAC;AACJ,CAAC","file":"asyncifyerrback.js","sourcesContent":["import { AsyncIterableX } from './asynciterablex';\nimport { AsyncSink } from './asyncsink';\nimport { memoize } from './operators/memoize';\n\n/**\n * Converts a Node.js style error first callback to an async-iterable sequence.\n *\n * @template TSource The type of the returned value from the callback.\n * @param {Function} func The Node.js error first callback to convert to an async-iterable.\n * @returns {(...args: any[]) => AsyncIterableX<TSource>} A function, when invoked, contains the result of the callback as an async-iterable.\n */\nexport function asyncifyErrback<TSource>(\n  func: (...xs: any[]) => any\n): (...args: any[]) => AsyncIterableX<TSource> {\n  return function (...args: any[]) {\n    const sink = new AsyncSink<TSource>();\n\n    const handler = function (err: any, ...innerArgs: any[]) {\n      if (err) {\n        sink.error(err);\n        sink.end();\n      } else {\n        sink.write(innerArgs.length === 1 ? innerArgs[0] : innerArgs);\n        sink.end();\n      }\n    };\n\n    try {\n      func(...args.concat(handler));\n    } catch (e) {\n      sink.error(e);\n      sink.end();\n    }\n\n    const yielder = async function* () {\n      for (let next; !(next = await sink.next()).done; ) {\n        yield next.value;\n      }\n    };\n\n    return memoize<TSource>()(yielder());\n  };\n}\n"]}