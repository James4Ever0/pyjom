{"version":3,"sources":["asynciterable/operators/map.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,cAAc,EAAE,MAAM,mBAAmB,CAAC;AAEnD,OAAO,EAAE,aAAa,EAAE,MAAM,aAAa,CAAC;AAC5C,OAAO,EAAE,cAAc,EAAE,MAAM,kBAAkB,CAAC;AAElD,MAAM,OAAO,gBAAmC,SAAQ,cAAuB;IACrE,OAAO,CAAyB;IAChC,SAAS,CAIe;IACxB,QAAQ,CAAM;IAEtB,YACE,MAA8B,EAC9B,QAA6F,EAC7F,OAAa;QAEb,KAAK,EAAE,CAAC;QACR,IAAI,CAAC,OAAO,GAAG,MAAM,CAAC;QACtB,IAAI,CAAC,SAAS,GAAG,QAAQ,CAAC;QAC1B,IAAI,CAAC,QAAQ,GAAG,OAAO,CAAC;IAC1B,CAAC;IAED,KAAK,CAAC,CAAC,CAAC,MAAM,CAAC,aAAa,CAAC,CAAC,MAAoB;QAChD,cAAc,CAAC,MAAM,CAAC,CAAC;QACvB,IAAI,CAAC,GAAG,CAAC,CAAC;QACV,IAAI,KAAK,EAAE,MAAM,IAAI,IAAI,aAAa,CAAC,IAAI,CAAC,OAAO,EAAE,MAAM,CAAC,EAAE;YAC5D,MAAM,MAAM,GAAG,MAAM,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,IAAI,CAAC,QAAQ,EAAE,IAAI,EAAE,CAAC,EAAE,EAAE,MAAM,CAAC,CAAC;YAC3E,MAAM,MAAM,CAAC;SACd;IACH,CAAC;CACF;AAED;;;;;;;;;;;GAWG;AACH,MAAM,UAAU,GAAG,CACjB,QAA6F,EAC7F,OAAa;IAEb,OAAO,SAAS,mBAAmB,CAAC,MAA8B;QAChE,OAAO,IAAI,gBAAgB,CAAmB,MAAM,EAAE,QAAQ,EAAE,OAAO,CAAC,CAAC;IAC3E,CAAC,CAAC;AACJ,CAAC","file":"map.js","sourcesContent":["import { AsyncIterableX } from '../asynciterablex';\nimport { OperatorAsyncFunction } from '../../interfaces';\nimport { wrapWithAbort } from './withabort';\nimport { throwIfAborted } from '../../aborterror';\n\nexport class MapAsyncIterable<TSource, TResult> extends AsyncIterableX<TResult> {\n  private _source: AsyncIterable<TSource>;\n  private _selector: (\n    value: TSource,\n    index: number,\n    signal?: AbortSignal\n  ) => Promise<TResult> | TResult;\n  private _thisArg: any;\n\n  constructor(\n    source: AsyncIterable<TSource>,\n    selector: (value: TSource, index: number, signal?: AbortSignal) => Promise<TResult> | TResult,\n    thisArg?: any\n  ) {\n    super();\n    this._source = source;\n    this._selector = selector;\n    this._thisArg = thisArg;\n  }\n\n  async *[Symbol.asyncIterator](signal?: AbortSignal) {\n    throwIfAborted(signal);\n    let i = 0;\n    for await (const item of wrapWithAbort(this._source, signal)) {\n      const result = await this._selector.call(this._thisArg, item, i++, signal);\n      yield result;\n    }\n  }\n}\n\n/**\n * Projects each element of an async-enumerable sequence into a new form.\n *\n * @template TSource The type of the elements in the source sequence.\n * @template TResult The type of the elements in the result sequence, obtained by running the selector\n * function for each element in the source sequence.\n * @param {((value: TSource, index: number, signal?: AbortSignal) => Promise<TResult> | TResult)} selector A transform function\n * to apply to each source element.\n * @param {*} [thisArg] Optional this for binding to the selector.\n * @returns {OperatorAsyncFunction<TSource, TResult>} An async-iterable sequence whose elements are the result of invoking the transform\n * function on each element of source.\n */\nexport function map<TSource, TResult>(\n  selector: (value: TSource, index: number, signal?: AbortSignal) => Promise<TResult> | TResult,\n  thisArg?: any\n): OperatorAsyncFunction<TSource, TResult> {\n  return function mapOperatorFunction(source: AsyncIterable<TSource>): AsyncIterableX<TResult> {\n    return new MapAsyncIterable<TSource, TResult>(source, selector, thisArg);\n  };\n}\n"]}