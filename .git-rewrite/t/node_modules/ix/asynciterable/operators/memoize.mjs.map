{"version":3,"sources":["asynciterable/operators/memoize.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,cAAc,EAAE,MAAM,mBAAmB,CAAC;AACnD,OAAO,EAEL,eAAe,EACf,YAAY,GACb,MAAM,wCAAwC,CAAC;AAChD,OAAO,EAAE,MAAM,EAAE,MAAM,WAAW,CAAC;AAEnC,OAAO,EAAE,cAAc,EAAE,MAAM,kBAAkB,CAAC;AAElD,MAAM,OAAO,kBAAsB,SAAQ,cAAiB;IAChD,OAAO,CAAmB;IAC1B,OAAO,CAAmB;IAC1B,OAAO,CAAoC;IAC3C,MAAM,CAAM;IACZ,QAAQ,CAAU;IAE5B,YAAY,MAAwB,EAAE,MAAwB;QAC5D,KAAK,EAAE,CAAC;QACR,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC;QACnB,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC;QACpB,IAAI,CAAC,QAAQ,GAAG,KAAK,CAAC;QACtB,IAAI,CAAC,OAAO,GAAG,MAAM,CAAC;QACtB,IAAI,CAAC,OAAO,GAAG,MAAM,CAAC;IACxB,CAAC;IAED,CAAC,MAAM,CAAC,aAAa,CAAC,CAAC,MAAoB;QACzC,cAAc,CAAC,MAAM,CAAC,CAAC;QACvB,OAAO,IAAI,CAAC,YAAY,CAAC,CAAC,CAAC,CAAC;IAC9B,CAAC;IAES,KAAK,CAAC,CAAC,YAAY,CAAC,MAAM,GAAG,CAAC;QACtC,IAAI,CAAC,GAAG,MAAM,GAAG,CAAC,CAAC;QACnB,IAAI,IAAI,GAAwB,KAAK,CAAC;QACtC,MAAM,MAAM,GAAG,IAAI,CAAC,OAAO,CAAC;QAE5B,IAAI;YACF,GAAG;gBACD,IAAI,EAAE,CAAC,GAAG,MAAM,CAAC,KAAK,EAAE;oBACtB,MAAM,MAAM,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;oBACpB,SAAS;iBACV;gBAED,IAAI,IAAI,CAAC,QAAQ,EAAE;oBACjB,MAAM,IAAI,CAAC,MAAM,CAAC;iBACnB;gBAED,IAAI,IAAI,CAAC,OAAO,KAAK,IAAI,EAAE;oBACzB,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC,OAAO,CAAC,IAAI,EAAE,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,EAAE;wBAC5C,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC;wBACpB,IAAI,CAAC,CAAC,CAAC,IAAI,EAAE;4BACX,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC;yBACtB;wBACD,OAAO,CAAC,CAAC;oBACX,CAAC,CAAC,CAAC;iBACJ;gBAED,CAAC,EAAE,IAAI,EAAE,GAAG,MAAM,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE,EAAE;oBACzC,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC;oBAChB,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC;oBACrB,MAAM,CAAC,CAAC;gBACV,CAAC,CAAC,CAAC,CAAC;gBAEJ,IAAI,CAAC,IAAI,EAAE;oBACT,MAAM,MAAM,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;iBACrB;aACF,QAAQ,CAAC,IAAI,EAAE;SACjB;gBAAS;YACR,MAAM,CAAC,IAAI,EAAE,CAAC;SACf;IACH,CAAC;CACF;AA6BD;;;;;;;;;;;;GAYG;AACH,MAAM,UAAU,OAAO,CACrB,WAAW,GAAG,CAAC,CAAC,EAChB,QAAoE;IAEpE,OAAO,SAAS,uBAAuB,CACrC,MAA8B;QAE9B,IAAI,CAAC,QAAQ,EAAE;YACb,OAAO,WAAW,KAAK,CAAC,CAAC;gBACvB,CAAC,CAAC,IAAI,kBAAkB,CACpB,MAAM,CAAC,MAAM,CAAC,aAAa,CAAC,EAAE,EAC9B,IAAI,eAAe,EAAW,CAC/B;gBACH,CAAC,CAAC,IAAI,kBAAkB,CACpB,MAAM,CAAC,MAAM,CAAC,aAAa,CAAC,EAAE,EAC9B,IAAI,YAAY,CAAU,WAAW,CAAC,CACvC,CAAC;SACP;QACD,OAAO,MAAM,CAAoB,GAAG,EAAE,CACpC,QAAS,CAAC,OAAO,CAAU,WAAW,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,MAAM,CAAC,aAAa,CAAC,EAAE,CACzE,CAAC;IACJ,CAAC,CAAC;AACJ,CAAC","file":"memoize.js","sourcesContent":["import { AsyncIterableX } from '../asynciterablex';\nimport {\n  IRefCountList,\n  MaxRefCountList,\n  RefCountList,\n} from '../../iterable/operators/_refcountlist';\nimport { create } from '../create';\nimport { OperatorAsyncFunction } from '../../interfaces';\nimport { throwIfAborted } from '../../aborterror';\n\nexport class MemoizeAsyncBuffer<T> extends AsyncIterableX<T> {\n  protected _source: AsyncIterator<T>;\n  protected _buffer: IRefCountList<T>;\n  protected _shared: Promise<IteratorResult<T>> | null;\n  protected _error: any;\n  protected _stopped: boolean;\n\n  constructor(source: AsyncIterator<T>, buffer: IRefCountList<T>) {\n    super();\n    this._error = null;\n    this._shared = null;\n    this._stopped = false;\n    this._source = source;\n    this._buffer = buffer;\n  }\n\n  [Symbol.asyncIterator](signal?: AbortSignal) {\n    throwIfAborted(signal);\n    return this._getIterable(0);\n  }\n\n  protected async *_getIterable(offset = 0) {\n    let i = offset - 1;\n    let done: boolean | undefined = false;\n    const buffer = this._buffer;\n\n    try {\n      do {\n        if (++i < buffer.count) {\n          yield buffer.get(i);\n          continue;\n        }\n\n        if (this._stopped) {\n          throw this._error;\n        }\n\n        if (this._shared === null) {\n          this._shared = this._source.next().then((r) => {\n            this._shared = null;\n            if (!r.done) {\n              buffer.push(r.value);\n            }\n            return r;\n          });\n        }\n\n        ({ done } = await this._shared.catch((e) => {\n          this._error = e;\n          this._stopped = true;\n          throw e;\n        }));\n\n        if (!done) {\n          yield buffer.get(i);\n        }\n      } while (!done);\n    } finally {\n      buffer.done();\n    }\n  }\n}\n\n/**\n * Creates a buffer with a view over the source sequence, causing a specified number of iterators to obtain access\n * to all of the sequence's elements without causing multiple enumerations over the source.\n * @template TSource Source sequence element type.\n * @param {number} [readerCount] Number of iterators that can access the underlying buffer.\n * Once every iterator has obtained an element from the buffer, the element is removed from the buffer.\n * @returns {OperatorAsyncFunction<TSource, TSource>} Buffer enabling a specified number of iterators to retrieve all\n * elements from the shared source sequence, without duplicating source iteration side-effects.\n */\nexport function memoize<TSource>(readerCount?: number): OperatorAsyncFunction<TSource, TSource>;\n/**\n * Memoizes the source sequence within a selector function where a specified number of iterators can get access\n * to all of the sequence's elements without causing multiple iterations over the source.\n *\n * @template TSource Source sequence element type.\n * @template TResult Result sequence element type.\n * @param {number} [readerCount] Number of iterators that can access the underlying buffer. Once every\n * iterator has obtained an element from the buffer, the element is removed from the buffer.\n * @param {(value: AsyncIterableX<TSource>) => AsyncIterable<TResult>} [selector] Selector function with memoized access\n * to the source sequence for a specified number of iterators.\n * @returns {OperatorAsyncFunction<TSource, TResult>} Sequence resulting from applying the selector function to the\n * memoized view over the source sequence.\n */\nexport function memoize<TSource, TResult>(\n  readerCount?: number,\n  selector?: (value: AsyncIterable<TSource>) => AsyncIterable<TResult>\n): OperatorAsyncFunction<TSource, TResult>;\n/**\n * Memoizes the source sequence within a selector function where a specified number of iterators can get access\n * to all of the sequence's elements without causing multiple iterations over the source.\n *\n * @template TSource Source sequence element type.\n * @template TResult Result sequence element type.\n * @param {number} [readerCount=-1] Number of iterators that can access the underlying buffer. Once every\n * iterator has obtained an element from the buffer, the element is removed from the buffer.\n * @param {(value: AsyncIterable<TSource>) => AsyncIterable<TResult>} [selector] Selector function with memoized access\n * to the source sequence for a specified number of iterators.\n * @returns {(OperatorAsyncFunction<TSource, TSource | TResult>)} Sequence resulting from applying the selector function to the\n * memoized view over the source sequence.\n */\nexport function memoize<TSource, TResult = TSource>(\n  readerCount = -1,\n  selector?: (value: AsyncIterable<TSource>) => AsyncIterable<TResult>\n): OperatorAsyncFunction<TSource, TSource | TResult> {\n  return function memoizeOperatorFunction(\n    source: AsyncIterable<TSource>\n  ): AsyncIterableX<TSource | TResult> {\n    if (!selector) {\n      return readerCount === -1\n        ? new MemoizeAsyncBuffer<TSource>(\n            source[Symbol.asyncIterator](),\n            new MaxRefCountList<TSource>()\n          )\n        : new MemoizeAsyncBuffer<TSource>(\n            source[Symbol.asyncIterator](),\n            new RefCountList<TSource>(readerCount)\n          );\n    }\n    return create<TSource | TResult>(() =>\n      selector!(memoize<TSource>(readerCount)(source))[Symbol.asyncIterator]()\n    );\n  };\n}\n"]}