{"version":3,"sources":["asynciterable/operators/batch.ts"],"names":[],"mappings":"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","file":"batch.js","sourcesContent":["import { AsyncIterableX } from '../asynciterablex';\nimport { OperatorAsyncFunction } from '../../interfaces';\nimport { wrapWithAbort } from './withabort';\nimport { throwIfAborted } from '../../aborterror';\n\ninterface AsyncResolver<T> {\n  resolve: (value: T | PromiseLike<T>) => void;\n  reject: (reason?: any) => void;\n}\n\nconst WAITING_TYPE = 'waiting';\nconst BATCHING_TYPE = 'batching';\n\ninterface WaitingState<T> {\n  type: 'waiting';\n  resolver: AsyncResolver<IteratorResult<T[]>>;\n}\ninterface BatchingState<T> {\n  type: 'batching';\n  values: T[];\n}\n\ntype State<T> = WaitingState<T> | BatchingState<T>;\n\nfunction assertNever(value: never): never {\n  throw new Error(`Unhandled discriminated union member ${value}`);\n}\n\nexport class BatchAsyncIterable<TSource> extends AsyncIterableX<TSource[]> {\n  private _source: AsyncIterable<TSource>;\n\n  constructor(source: AsyncIterable<TSource>) {\n    super();\n    this._source = source;\n  }\n\n  [Symbol.asyncIterator](signal?: AbortSignal) {\n    throwIfAborted(signal);\n    const it = wrapWithAbort(this._source, signal)[Symbol.asyncIterator]();\n\n    let state: State<TSource> = { type: BATCHING_TYPE, values: [] };\n    let ended: null | Promise<IteratorResult<TSource[]>> = null;\n    let error: any = null;\n\n    function consumeNext() {\n      it.next().then(\n        (res) => {\n          if (res.done) {\n            ended = Promise.resolve({ done: true } as IteratorResult<TSource[]>);\n\n            if (state.type === WAITING_TYPE) {\n              state.resolver.resolve(ended);\n            }\n          } else {\n            if (state.type === WAITING_TYPE) {\n              const { resolve } = state.resolver;\n              state = { type: BATCHING_TYPE, values: [] };\n              resolve({ done: res.done, value: [res.value] });\n            } else if (state.type === BATCHING_TYPE) {\n              state.values.push(res.value);\n            } else {\n              assertNever(state);\n            }\n\n            consumeNext();\n          }\n        },\n        (err) => {\n          error = err;\n          if (state.type === WAITING_TYPE) {\n            state.resolver.reject(err);\n          }\n        }\n      );\n    }\n\n    consumeNext();\n\n    return {\n      next() {\n        if (error) {\n          return Promise.reject(error);\n        }\n\n        if (state.type === BATCHING_TYPE && state.values.length > 0) {\n          const { values } = state;\n          state.values = [];\n          return Promise.resolve({ done: false, value: values });\n        }\n\n        if (ended) {\n          return ended;\n        }\n\n        if (state.type === WAITING_TYPE) {\n          throw new Error('Previous `next()` is still in progress');\n        }\n\n        return new Promise<IteratorResult<TSource[]>>((resolve, reject) => {\n          state = {\n            type: WAITING_TYPE,\n            resolver: { resolve, reject },\n          };\n        });\n      },\n\n      return(value: any) {\n        return it.return\n          ? it.return(value).then(() => ({ done: true } as IteratorResult<TSource[]>))\n          : Promise.resolve({ done: true } as IteratorResult<TSource[]>);\n      },\n    };\n  }\n}\n\n/**\nReturns an async iterable sequence of batches that are collected from the source sequence between\n * subsequent `next()` calls.\n *\n * @template TSource The type of elements in the source sequence.\n * @returns {OperatorAsyncFunction<TSource, TSource[]>} An operator returning an async-iterable of batches that are collection from the\n * source sequence between subsequent `next()` calls.\n */\nexport function batch<TSource>(): OperatorAsyncFunction<TSource, TSource[]> {\n  return function batchOperator(source: AsyncIterable<TSource>): AsyncIterableX<TSource[]> {\n    return new BatchAsyncIterable(source);\n  };\n}\n"]}