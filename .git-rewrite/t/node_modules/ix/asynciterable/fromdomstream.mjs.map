{"version":3,"sources":["asynciterable/fromdomstream.ts"],"names":[],"mappings":"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","file":"fromdomstream.js","sourcesContent":["import { AsyncIterableX } from './asynciterablex';\n\n/** @ignore */\nconst SharedArrayBuf = typeof SharedArrayBuffer !== 'undefined' ? SharedArrayBuffer : ArrayBuffer;\n\nexport class AsyncIterableReadableStream<T> extends AsyncIterableX<T | undefined> {\n  constructor(protected _stream: ReadableStream<T>) {\n    super();\n  }\n  [Symbol.asyncIterator]() {\n    const stream = this._stream;\n    const reader = stream['getReader']();\n    return _consumeReader(stream, reader, defaultReaderToAsyncIterator(reader));\n  }\n}\n\nexport class AsyncIterableReadableByteStream extends AsyncIterableReadableStream<Uint8Array> {\n  [Symbol.asyncIterator]() {\n    const stream = this._stream;\n    let reader: ReadableStreamReader<Uint8Array>;\n    try {\n      reader = (stream as any)['getReader']({ mode: 'byob' });\n    } catch (e) {\n      return super[Symbol.asyncIterator]();\n    }\n    const iterator = _consumeReader(stream, reader, byobReaderToAsyncIterator(reader));\n    // \"pump\" the iterator once so it initializes and is ready to accept a buffer or bytesToRead\n    iterator.next();\n    return iterator;\n  }\n}\n\nasync function* _consumeReader<T>(\n  stream: ReadableStream<T>,\n  reader: ReadableStreamReader<Uint8Array> | ReadableStreamDefaultReader,\n  iterator: AsyncGenerator<T>\n): AsyncIterator<T, any, undefined> {\n  let threw = false;\n  try {\n    yield* iterator;\n  } catch (e) {\n    if ((threw = true) && reader) {\n      await reader['cancel'](e);\n    }\n  } finally {\n    if (reader) {\n      if (!threw) {\n        await reader['cancel']();\n      }\n      if (stream.locked) {\n        try {\n          reader.closed.catch(() => {\n            /* */\n          });\n          reader.releaseLock();\n        } catch (e) {\n          /* */\n        }\n      }\n    }\n  }\n}\n\n/** @ignore */\nasync function* defaultReaderToAsyncIterator<T = any>(reader: ReadableStreamDefaultReader<T>) {\n  let r: ReadableStreamDefaultReadResult<T>;\n  while (!(r = await reader.read()).done) {\n    yield r.value;\n  }\n}\n\n/** @ignore */\nasync function* byobReaderToAsyncIterator(reader: ReadableStreamReader<Uint8Array>) {\n  let r: ReadableStreamDefaultReadResult<Uint8Array>;\n  let value: number | ArrayBufferLike = yield null!;\n  while (!(r = await readNext(reader, value, 0)).done) {\n    value = yield r.value;\n  }\n}\n\n/** @ignore */\nasync function readNext(\n  reader: ReadableStreamReader<Uint8Array>,\n  bufferOrLen: ArrayBufferLike | number,\n  offset: number\n): Promise<ReadableStreamDefaultReadResult<Uint8Array>> {\n  let size: number;\n  let buffer: ArrayBufferLike;\n\n  if (typeof bufferOrLen === 'number') {\n    buffer = new ArrayBuffer((size = bufferOrLen));\n  } else if (bufferOrLen instanceof ArrayBuffer) {\n    size = (buffer = bufferOrLen).byteLength;\n  } else if (bufferOrLen instanceof SharedArrayBuf) {\n    size = (buffer = bufferOrLen).byteLength;\n  } else {\n    return { done: true, value: undefined! };\n  }\n\n  return await readInto(reader, buffer, offset, size);\n}\n\n/** @ignore */\nasync function readInto(\n  reader: ReadableStreamReader<Uint8Array>,\n  buffer: ArrayBufferLike,\n  offset: number,\n  size: number\n): Promise<ReadableStreamDefaultReadResult<Uint8Array>> {\n  let innerOffset = offset;\n  if (innerOffset >= size) {\n    return { done: false, value: new Uint8Array(buffer, 0, size) };\n  }\n  const { done, value } = await (reader as any).read(\n    new Uint8Array(buffer, innerOffset, size - innerOffset)\n  );\n  if ((innerOffset += value!.byteLength) < size && !done) {\n    return await readInto(reader, value!.buffer, innerOffset, size);\n  }\n  return { done, value: new Uint8Array(value!.buffer, 0, innerOffset) };\n}\n\n/**\n * Creates an async-iterable from an existing DOM stream.\n *\n * @template TSource The type of elements in the source DOM stream.\n * @param {ReadableStream<TSource>} stream The DOM Readable stream to convert to an async-iterable.\n * @returns {AsyncIterableX<TSource>} An async-iterable containing the elements from the ReadableStream.\n */\nexport function fromDOMStream<TSource>(stream: ReadableStream<TSource>): AsyncIterableX<TSource>;\n/**\n * Creates an async-iterable from an existing DOM stream and options.\n *\n * @template TSource  * @template TSource The type of elements in the source DOM stream.\n * @param {ReadableStream<TSource>} stream The readable stream to convert to an async-iterable.\n * @param {{ mode: 'byob' }} options The options to set the mode for the DOM stream.\n * @returns {AsyncIterableX<TSource>} An async-iterable created from the incoming async-iterable.\n */\nexport function fromDOMStream<TSource extends ArrayBufferView>(\n  stream: ReadableStream<TSource>,\n  options: { mode: 'byob' }\n): AsyncIterableX<TSource>;\n\n/**\n * Creates an async-iterable from an existing DOM stream and optional options.\n *\n * @param {ReadableStream} stream The readable stream to convert to an async-iterable.\n * @param {{ mode: 'byob' }} [options] The optional options to set the mode for the DOM stream.\n * @returns {AsyncIterableX<any>} An async-iterable created from the incoming async-iterable.\n */\nexport function fromDOMStream(stream: ReadableStream, options?: { mode: 'byob' }) {\n  return !options || options['mode'] !== 'byob'\n    ? new AsyncIterableReadableStream(stream)\n    : new AsyncIterableReadableByteStream(stream);\n}\n"]}