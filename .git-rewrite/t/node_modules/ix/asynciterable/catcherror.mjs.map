{"version":3,"sources":["asynciterable/catcherror.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,cAAc,EAAE,MAAM,kBAAkB,CAAC;AAClD,OAAO,EAAE,mBAAmB,EAAE,MAAM,wBAAwB,CAAC;AAC7D,OAAO,EAAE,aAAa,EAAE,MAAM,uBAAuB,CAAC;AACtD,OAAO,EAAE,cAAc,EAAE,MAAM,eAAe,CAAC;AAE/C,MAAM,OAAO,qBAA+B,SAAQ,cAAuB;IACjE,OAAO,CAAmC;IAElD,YAAY,MAAwC;QAClD,KAAK,EAAE,CAAC;QACR,IAAI,CAAC,OAAO,GAAG,MAAM,CAAC;IACxB,CAAC;IAED,KAAK,CAAC,CAAC,CAAC,MAAM,CAAC,aAAa,CAAC,CAAC,MAAoB;QAChD,cAAc,CAAC,MAAM,CAAC,CAAC;QAEvB,IAAI,KAAK,GAAG,IAAI,CAAC;QACjB,IAAI,QAAQ,GAAG,KAAK,CAAC;QAErB,KAAK,MAAM,MAAM,IAAI,IAAI,CAAC,OAAO,EAAE;YACjC,MAAM,EAAE,GAAG,aAAa,CAAC,MAAM,EAAE,MAAM,CAAC,CAAC,MAAM,CAAC,aAAa,CAAC,EAAE,CAAC;YAEjE,KAAK,GAAG,IAAI,CAAC;YACb,QAAQ,GAAG,KAAK,CAAC;YAEjB,OAAO,CAAC,EAAE;gBACR,IAAI,CAAC,GAAY,EAAE,CAAC;gBAEpB,IAAI;oBACF,MAAM,EAAE,IAAI,EAAE,KAAK,EAAE,GAAG,MAAM,EAAE,CAAC,IAAI,EAAE,CAAC;oBACxC,IAAI,IAAI,EAAE;wBACR,MAAM,mBAAmB,CAAC,EAAE,CAAC,CAAC;wBAC9B,MAAM;qBACP;oBACD,CAAC,GAAG,KAAK,CAAC;iBACX;gBAAC,OAAO,CAAC,EAAE;oBACV,KAAK,GAAG,CAAC,CAAC;oBACV,QAAQ,GAAG,IAAI,CAAC;oBAChB,MAAM,mBAAmB,CAAC,EAAE,CAAC,CAAC;oBAC9B,MAAM;iBACP;gBAED,MAAM,CAAC,CAAC;aACT;YAED,IAAI,CAAC,QAAQ,EAAE;gBACb,MAAM;aACP;SACF;QAED,IAAI,QAAQ,EAAE;YACZ,MAAM,KAAK,CAAC;SACb;IACH,CAAC;CACF;AAED;;;;;;;GAOG;AACH,MAAM,UAAU,QAAQ,CAAI,MAAkC;IAC5D,OAAO,IAAI,qBAAqB,CAAI,MAAM,CAAC,CAAC;AAC9C,CAAC;AAED;;;;;;;GAOG;AACH,MAAM,UAAU,UAAU,CAAI,GAAG,IAAwB;IACvD,OAAO,IAAI,qBAAqB,CAAI,IAAI,CAAC,CAAC;AAC5C,CAAC","file":"catcherror.js","sourcesContent":["import { AsyncIterableX } from './asynciterablex';\nimport { returnAsyncIterator } from '../util/returniterator';\nimport { wrapWithAbort } from './operators/withabort';\nimport { throwIfAborted } from '../aborterror';\n\nexport class CatchAllAsyncIterable<TSource> extends AsyncIterableX<TSource> {\n  private _source: Iterable<AsyncIterable<TSource>>;\n\n  constructor(source: Iterable<AsyncIterable<TSource>>) {\n    super();\n    this._source = source;\n  }\n\n  async *[Symbol.asyncIterator](signal?: AbortSignal) {\n    throwIfAborted(signal);\n\n    let error = null;\n    let hasError = false;\n\n    for (const source of this._source) {\n      const it = wrapWithAbort(source, signal)[Symbol.asyncIterator]();\n\n      error = null;\n      hasError = false;\n\n      while (1) {\n        let c = <TSource>{};\n\n        try {\n          const { done, value } = await it.next();\n          if (done) {\n            await returnAsyncIterator(it);\n            break;\n          }\n          c = value;\n        } catch (e) {\n          error = e;\n          hasError = true;\n          await returnAsyncIterator(it);\n          break;\n        }\n\n        yield c;\n      }\n\n      if (!hasError) {\n        break;\n      }\n    }\n\n    if (hasError) {\n      throw error;\n    }\n  }\n}\n\n/**\n * Continues an async-iterable sequence that is terminated by an exception with the next async-iterable sequence.\n *\n * @template T The type of the elements in the source and handler sequences.\n * @param {Iterable<AsyncIterable<T>>} source async-iterable sequences to catch exceptions for.\n * @returns {AsyncIterableX<T>} An async-iterable sequence containing elements from consecutive source\n * sequences until a source sequence terminates successfully.\n */\nexport function catchAll<T>(source: Iterable<AsyncIterable<T>>): AsyncIterableX<T> {\n  return new CatchAllAsyncIterable<T>(source);\n}\n\n/**\n * Continues an async-iterable sequence that is terminated by an exception with the next async-iterable sequence.\n *\n * @template T The type of the elements in the source and handler sequences.\n * @param {...AsyncIterable<T>[]} args async-iterable sequences to catch exceptions for.\n * @returns {AsyncIterableX<T>} An async-iterable sequence containing elements from consecutive source\n * sequences until a source sequence terminates successfully.\n */\nexport function catchError<T>(...args: AsyncIterable<T>[]): AsyncIterableX<T> {\n  return new CatchAllAsyncIterable<T>(args);\n}\n"]}