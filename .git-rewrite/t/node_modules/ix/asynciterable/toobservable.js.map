{"version":3,"sources":["asynciterable/toobservable.ts"],"names":[],"mappings":";;;AAAA,mDAAgD;AAChD,0CAA6D;AAI7D,MAAM,mBAAmB;IAChB,cAAc,GAAG,KAAK,CAAC;IAE9B,WAAW;QACT,IAAI,CAAC,cAAc,GAAG,IAAI,CAAC;IAC7B,CAAC;CACF;AAED,MAAM,uBAAuB;IACnB,OAAO,CAAyB;IAExC,YAAY,MAA8B;QACxC,IAAI,CAAC,OAAO,GAAG,MAAM,CAAC;IACxB,CAAC;IAED,CAAC,qBAAgB,CAAC;QAChB,OAAO,IAAI,CAAC;IACd,CAAC;IACD,SAAS,CACP,IAAkE,EAClE,KAAkC,EAClC,QAA6B;QAE7B,MAAM,QAAQ,GAAG,uBAAU,CAAC,IAAI,EAAE,KAAK,EAAE,QAAQ,CAAC,CAAC;QACnD,MAAM,YAAY,GAAG,IAAI,mBAAmB,EAAE,CAAC;QAE/C,MAAM,EAAE,GAAG,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,aAAa,CAAC,EAAE,CAAC;QAChD,MAAM,CAAC,GAAG,GAAG,EAAE;YACb,EAAE,CAAC,IAAI,EAAE;iBACN,IAAI,CAAC,CAAC,EAAE,KAAK,EAAE,IAAI,EAAE,EAAE,EAAE;gBACxB,IAAI,CAAC,YAAY,CAAC,cAAc,EAAE;oBAChC,IAAI,IAAI,EAAE;wBACR,QAAQ,CAAC,QAAQ,EAAE,CAAC;qBACrB;yBAAM;wBACL,QAAQ,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;wBACrB,CAAC,EAAE,CAAC;qBACL;iBACF;YACH,CAAC,CAAC;iBACD,KAAK,CAAC,CAAC,GAAG,EAAE,EAAE;gBACb,IAAI,CAAC,YAAY,CAAC,cAAc,EAAE;oBAChC,QAAQ,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;iBACrB;YACH,CAAC,CAAC,CAAC;QACP,CAAC,CAAC;QACF,CAAC,EAAE,CAAC;QAEJ,OAAO,YAAY,CAAC;IACtB,CAAC;CACF;AAED;;;;;;GAMG;AACH,SAAgB,YAAY,CAAU,MAA8B;IAClE,OAAO,IAAI,uBAAuB,CAAU,MAAM,CAAC,CAAC;AACtD,CAAC;AAFD,oCAEC","file":"toobservable.js","sourcesContent":["import { toObserver } from '../util/toobserver';\nimport { observable as symbolObservable } from '../observer';\nimport { Observable, PartialObserver } from '../observer';\nimport { Subscription } from '../subscription';\n\nclass BooleanSubscription implements Subscription {\n  public isUnsubscribed = false;\n\n  unsubscribe() {\n    this.isUnsubscribed = true;\n  }\n}\n\nclass AsyncIterableObservable<TSource> implements Observable<TSource> {\n  private _source: AsyncIterable<TSource>;\n\n  constructor(source: AsyncIterable<TSource>) {\n    this._source = source;\n  }\n\n  [symbolObservable](): Observable<TSource> {\n    return this;\n  }\n  subscribe(\n    next?: PartialObserver<TSource> | ((value: TSource) => any) | null,\n    error?: ((err: any) => any) | null,\n    complete?: (() => any) | null\n  ) {\n    const observer = toObserver(next, error, complete);\n    const subscription = new BooleanSubscription();\n\n    const it = this._source[Symbol.asyncIterator]();\n    const f = () => {\n      it.next()\n        .then(({ value, done }) => {\n          if (!subscription.isUnsubscribed) {\n            if (done) {\n              observer.complete();\n            } else {\n              observer.next(value);\n              f();\n            }\n          }\n        })\n        .catch((err) => {\n          if (!subscription.isUnsubscribed) {\n            observer.error(err);\n          }\n        });\n    };\n    f();\n\n    return subscription;\n  }\n}\n\n/**\n * Converts the async-iterable sequence to an observable.\n *\n * @template TSource The type of the elements in the source sequence.\n * @param {AsyncIterable<TSource>} source The async-iterable to convert to an observable.\n * @returns {Observable<TSource>} The observable containing the elements from the async-iterable.\n */\nexport function toObservable<TSource>(source: AsyncIterable<TSource>): Observable<TSource> {\n  return new AsyncIterableObservable<TSource>(source);\n}\n"]}