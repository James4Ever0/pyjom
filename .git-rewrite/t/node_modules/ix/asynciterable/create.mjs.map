{"version":3,"sources":["asynciterable/create.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,cAAc,EAAE,MAAM,kBAAkB,CAAC;AAClD,OAAO,EAAE,cAAc,EAAE,MAAM,eAAe,CAAC;AAE/C,MAAM,sBAA0B,SAAQ,cAAiB;IAC/C,GAAG,CAAyE;IAEpF,YAAY,EAA0E;QACpF,KAAK,EAAE,CAAC;QACR,IAAI,CAAC,GAAG,GAAG,EAAE,CAAC;IAChB,CAAC;IAED,KAAK,CAAC,CAAC,CAAC,MAAM,CAAC,aAAa,CAAC,CAAC,MAAoB;QAChD,cAAc,CAAC,MAAM,CAAC,CAAC;QACvB,MAAM,EAAE,GAAG,MAAM,IAAI,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC;QAClC,IAAI,IAAmC,CAAC;QACxC,OAAO,CAAC,CAAC,IAAI,GAAG,MAAM,EAAE,CAAC,IAAI,EAAE,CAAC,CAAC,IAAI,EAAE;YACrC,MAAM,IAAI,CAAC,KAAK,CAAC;SAClB;IACH,CAAC;CACF;AAED;;;;;;GAMG;AACH,MAAM,UAAU,MAAM,CACpB,EAA0E;IAE1E,OAAO,IAAI,sBAAsB,CAAC,EAAE,CAAC,CAAC;AACxC,CAAC","file":"create.js","sourcesContent":["import { AsyncIterableX } from './asynciterablex';\nimport { throwIfAborted } from '../aborterror';\n\nclass AnonymousAsyncIterable<T> extends AsyncIterableX<T> {\n  private _fn: (signal?: AbortSignal) => AsyncIterator<T> | Promise<AsyncIterator<T>>;\n\n  constructor(fn: (signal?: AbortSignal) => AsyncIterator<T> | Promise<AsyncIterator<T>>) {\n    super();\n    this._fn = fn;\n  }\n\n  async *[Symbol.asyncIterator](signal?: AbortSignal) {\n    throwIfAborted(signal);\n    const it = await this._fn(signal);\n    let next: IteratorResult<T> | undefined;\n    while (!(next = await it.next()).done) {\n      yield next.value;\n    }\n  }\n}\n\n/**\n * Creates a new iterable using the specified function implementing the members of AsyncIterable\n *\n * @template T The type of the elements returned by the enumerable sequence.\n * @param {((signal?: AbortSignal) => AsyncIterator<T> | Promise<AsyncIterator<T>>)} fn The function that creates the [Symbol.asyncIterator]() method\n * @returns {AsyncIterableX<T>} A new async-iterable instance.\n */\nexport function create<T>(\n  fn: (signal?: AbortSignal) => AsyncIterator<T> | Promise<AsyncIterator<T>>\n): AsyncIterableX<T> {\n  return new AnonymousAsyncIterable(fn);\n}\n"]}