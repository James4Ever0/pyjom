{"version":3,"sources":["add/asynciterable-operators/groupby.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,cAAc,EAAE,MAAM,oCAAoC,CAAC;AACpE,OAAO,EAAE,oBAAoB,EAAwB,MAAM,uCAAuC,CAAC;AACnG,OAAO,EAAE,aAAa,EAAE,MAAM,qBAAqB,CAAC;AAWpD,MAAM,UAAU,YAAY,CAE1B,WAA2E,EAC3E,kBAGgC,aAAa;IAE7C,OAAO,IAAI,oBAAoB,CAAwB,IAAI,EAAE,WAAW,EAAE,eAAe,CAAC,CAAC;AAC7F,CAAC;AAED,cAAc,CAAC,SAAS,CAAC,OAAO,GAAG,YAAY,CAAC","file":"groupby.js","sourcesContent":["import { AsyncIterableX } from '../../asynciterable/asynciterablex';\nimport { GroupByAsyncIterable, GroupedAsyncIterable } from '../../asynciterable/operators/groupby';\nimport { identityAsync } from '../../util/identity';\n\nexport function groupByProto<TSource, TKey>(\n  this: AsyncIterableX<TSource>,\n  keySelector: (value: TSource, signal?: AbortSignal) => TKey | Promise<TKey>\n): AsyncIterableX<GroupedAsyncIterable<TKey, TSource>>;\nexport function groupByProto<TSource, TKey, TValue>(\n  this: AsyncIterableX<TSource>,\n  keySelector: (value: TSource, signal?: AbortSignal) => TKey | Promise<TKey>,\n  elementSelector?: (value: TSource, signal?: AbortSignal) => TValue | Promise<TValue>\n): AsyncIterableX<GroupedAsyncIterable<TKey, TValue>>;\nexport function groupByProto<TSource, TKey, TValue>(\n  this: AsyncIterableX<TSource>,\n  keySelector: (value: TSource, signal?: AbortSignal) => TKey | Promise<TKey>,\n  elementSelector: (\n    value: TSource,\n    signal?: AbortSignal\n  ) => TValue | Promise<TValue> = identityAsync\n): AsyncIterableX<GroupedAsyncIterable<TKey, TValue>> {\n  return new GroupByAsyncIterable<TSource, TKey, TValue>(this, keySelector, elementSelector);\n}\n\nAsyncIterableX.prototype.groupBy = groupByProto;\n\ndeclare module '../../asynciterable/asynciterablex' {\n  interface AsyncIterableX<T> {\n    groupBy: typeof groupByProto;\n  }\n}\n"]}