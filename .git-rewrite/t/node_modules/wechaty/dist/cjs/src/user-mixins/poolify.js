"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.poolifyMixin = void 0;
const wechaty_puppet_1 = require("wechaty-puppet");
/**
 * https://stackoverflow.com/a/60378737/1123955
 *
 * You want something like partial type parameter inference,
 * which is not currently a feature of TypeScript (see microsoft/TypeScript#26242).
 * Right now you either have to specify all type parameters manually
 * or let the compiler infer all type parameters;
 * there's no partial inference.
 * As you've noticed,
 * generic type parameter defaults do not scratch this itch;
 * a default turns off inference.
 */
const poolifyMixin = (mixinBase) => () => {
    wechaty_puppet_1.log.verbose('PoolifyMixin', 'poolifyMixin(%s)', mixinBase.name);
    class AbstractPoolifyMixin extends mixinBase {
        static _pool;
        static get pool() {
            /**
             * hasOwnProperty() is important because we are calling this from the child classes
             */
            if (!Object.prototype.hasOwnProperty.call(this, '_pool')) {
                wechaty_puppet_1.log.verbose('PoolifyMixin', 'get pool() init pool');
                this._pool = new Map();
            }
            return this._pool; // FIXME: why we need "!" at here?
        }
        static load(id) {
            const existingItem = this.pool.get(id);
            if (existingItem) {
                return existingItem;
            }
            const newItem = new this(id);
            this.pool.set(id, newItem);
            return newItem;
        }
        constructor(...args) {
            super(...args);
        }
    }
    return AbstractPoolifyMixin;
};
exports.poolifyMixin = poolifyMixin;
//# sourceMappingURL=poolify.js.map