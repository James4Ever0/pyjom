#!/usr/bin/env -S node --no-warnings --loader ts-node/esm
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tstest_1 = require("tstest");
const fp_ts_1 = require("fp-ts");
const state_switch_1 = require("state-switch");
/**
 * Huan(202201): must import `./wechaty-impl.js` first
 *
 * Or will throw error:
 *
 * ReferenceError: Cannot access 'wechatifyUserModuleMixin' before initialization
 *   at file:///home/huan/git/wechaty/wechaty/src/wechaty/wechaty-base.ts:58:3 *
 *
 * TODO: find out why
 */
require("../wechaty/wechaty-impl.js");
const config_js_1 = require("../config.js");
const mod_js_1 = require("../wechaty-mixins/mod.js");
const wechaty_skeleton_js_1 = require("../wechaty/wechaty-skeleton.js");
const plugin_mixin_js_1 = require("./plugin-mixin.js");
(0, tstest_1.test)('ProtectedPropertyPluginMixin', async (t) => {
    const noOneLeft = true;
    t.ok(noOneLeft, 'should match Mixin properties for every protected property');
});
(0, tstest_1.test)('PluginMixin smoke testing', async (t) => {
    const sandbox = tstest_1.sinon.createSandbox({
        useFakeTimers: true,
    });
    const mixinBase = fp_ts_1.function.pipe(wechaty_skeleton_js_1.WechatySkeleton, (0, state_switch_1.serviceCtlMixin)('Wechaty', { log: config_js_1.log }), mod_js_1.gErrorMixin, plugin_mixin_js_1.pluginMixin);
    const sleep = () => new Promise(resolve => setTimeout(resolve, 10));
    class PluginMixinTest extends mixinBase {
        counter = 0;
        async onStart() { await sleep(); }
        async onStop() { await sleep(); }
    }
    const Plugin = (wechaty) => {
        wechaty.counter++;
        return () => wechaty.counter--;
    };
    const pluginMixinTest = new PluginMixinTest();
    let future;
    pluginMixinTest.use(Plugin);
    t.equal(pluginMixinTest.counter, 0, 'should not call plugin function before start');
    future = pluginMixinTest.start();
    t.equal(pluginMixinTest.counter, 0, 'should not call plugin function right after start');
    await sandbox.clock.runAllAsync();
    await future;
    t.equal(pluginMixinTest.counter, 1, 'should call plugin function after start');
    future = pluginMixinTest.stop();
    await sandbox.clock.runAllAsync();
    await future;
    t.equal(pluginMixinTest.counter, 0, 'should clean plugin context after stop');
    sandbox.restore();
});
//# sourceMappingURL=plugin-mixin.spec.js.map