{"version":3,"sources":["../src/index.js"],"names":["makeAsync","fn","Promise","resolve","apply","arguments","parseMessage","message","error","format","defaultOnMessage","type","MethodNotFound","method","noop","nextRequestId","Peer","onMessage","_asyncEmitError","process","nextTick","bind","emit","_handle","_deferreds","Object","create","_getDeferred","id","deferred","exec","data","results","all","then","result","undefined","push","reject","JsonRpcError","code","catch","response","failPendingRequests","reason","deferreds","request","params","requestId","notify","notification","end","encoding","cb","write","pipe","writable","listeners","clean","listener","event","removeListener","on","n","length","String","EventEmitter"],"mappings":"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","sourcesContent":["import { EventEmitter } from \"events\";\nimport { forEach, isArray, map } from \"lodash\";\nimport { format, JsonRpcError, MethodNotFound, parse } from \"json-rpc-protocol\";\n\n// ===================================================================\n\n// Give access to low level interface.\nexport * from \"json-rpc-protocol\";\n\n// ===================================================================\n\nfunction makeAsync(fn) {\n  return function() {\n    return new Promise(resolve => resolve(fn.apply(this, arguments)));\n  };\n}\n\nconst parseMessage = message => {\n  try {\n    return parse(message);\n  } catch (error) {\n    throw format.error(null, error);\n  }\n};\n\n// Default onMessage implementation:\n//\n// - ignores notifications\n// - throw MethodNotFound for all requests\nfunction defaultOnMessage(message) {\n  if (message.type === \"request\") {\n    throw new MethodNotFound(message.method);\n  }\n}\n\nfunction noop() {}\n\n// Starts the autoincrement id with the JavaScript minimal safe integer to have\n// more room before running out of integers (it's very far fetched but a very\n// long running process with a LOT of messages could run out).\nlet nextRequestId = -9007199254740991;\n\n// ===================================================================\n\nexport default class Peer extends EventEmitter {\n  constructor(onMessage = defaultOnMessage) {\n    super();\n\n    this._asyncEmitError = process.nextTick.bind(\n      process,\n      this.emit.bind(this),\n      \"error\"\n    );\n    this._handle = makeAsync(onMessage);\n    this._deferreds = Object.create(null);\n  }\n\n  _getDeferred(id) {\n    const deferred = this._deferreds[id];\n    delete this._deferreds[id];\n    return deferred;\n  }\n\n  async exec(message, data) {\n    message = parseMessage(message);\n\n    if (isArray(message)) {\n      const results = [];\n\n      // Only returns non empty results.\n      await Promise.all(\n        map(message, message => {\n          return this.exec(message, data).then(result => {\n            if (result !== undefined) {\n              results.push(result);\n            }\n          });\n        })\n      );\n\n      return results;\n    }\n\n    const { type } = message;\n\n    if (type === \"error\") {\n      const { id } = message;\n\n      // Some errors do not have an identifier, simply discard them.\n      if (id === null) {\n        return;\n      }\n\n      const { error } = message;\n      this._getDeferred(id).reject(\n        // TODO: it would be great if we could return an error with of\n        // a more specific type (and custom types with registration).\n        new JsonRpcError(error.message, error.code, error.data)\n      );\n    } else if (type === \"response\") {\n      this._getDeferred(message.id).resolve(message.result);\n    } else if (type === \"notification\") {\n      this._handle(message, data).catch(noop);\n    } else {\n      return this._handle(message, data)\n        .then(result =>\n          format.response(message.id, result === undefined ? null : result)\n        )\n        .catch(error =>\n          format.error(\n            message.id,\n\n            // If the method name is not defined, default to the method passed\n            // in the request.\n            error instanceof MethodNotFound && !error.data\n              ? new MethodNotFound(message.method)\n              : error\n          )\n        );\n    }\n  }\n\n  // Fails all pending requests.\n  failPendingRequests(reason) {\n    const { _deferreds: deferreds } = this;\n\n    forEach(deferreds, ({ reject }, id) => {\n      reject(reason);\n      delete deferreds[id];\n    });\n  }\n\n  /**\n   * This function should be called to send a request to the other end.\n   *\n   * TODO: handle multi-requests.\n   */\n  request(method, params) {\n    return new Promise((resolve, reject) => {\n      const requestId = nextRequestId++;\n\n      this.push(format.request(requestId, method, params));\n\n      this._deferreds[requestId] = { resolve, reject };\n    });\n  }\n\n  /**\n   * This function should be called to send a notification to the other end.\n   *\n   * TODO: handle multi-notifications.\n   */\n  async notify(method, params) {\n    this.push(format.notification(method, params));\n  }\n\n  // minimal stream interface\n\n  end(data, encoding, cb) {\n    if (typeof data === \"function\") {\n      process.nextTick(data);\n    } else {\n      if (typeof encoding === \"function\") {\n        process.nextTick(encoding);\n      } else if (typeof cb === \"function\") {\n        process.nextTick(cb);\n      }\n\n      if (data !== undefined) {\n        this.write(data);\n      }\n    }\n  }\n\n  pipe(writable) {\n    const listeners = {\n      data: data => writable.write(data),\n      end: () => {\n        writable.end();\n        clean();\n      },\n    };\n\n    const clean = () =>\n      forEach(listeners, (listener, event) => {\n        this.removeListener(event, listener);\n      });\n    forEach(listeners, (listener, event) => {\n      this.on(event, listener);\n    });\n\n    return writable;\n  }\n\n  push(data) {\n    return data === null ? this.emit(\"end\") : this.emit(\"data\", data);\n  }\n\n  write(message) {\n    let cb;\n    const n = arguments.length;\n    if (n > 1 && typeof (cb = arguments[n - 1]) === \"function\") {\n      process.nextTick(cb);\n    }\n\n    this.exec(String(message)).then(response => {\n      if (response !== undefined) {\n        this.push(response);\n      }\n    }, this._asyncEmitError);\n\n    // indicates that other calls to `write` are allowed\n    return true;\n  }\n}\n\nexport { Peer }\n"],"file":"index.js"}