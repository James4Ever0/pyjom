(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('shiftjis')) :
  typeof define === 'function' && define.amd ? define(['exports', 'shiftjis'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.Vmd = {}, global.shiftjis));
}(this, (function (exports, shiftjis) { 'use strict';

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
  }

  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;

    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

    return arr2;
  }

  function _createForOfIteratorHelper(o, allowArrayLike) {
    var it;

    if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
      if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it) o = it;
        var i = 0;

        var F = function () {};

        return {
          s: F,
          n: function () {
            if (i >= o.length) return {
              done: true
            };
            return {
              done: false,
              value: o[i++]
            };
          },
          e: function (e) {
            throw e;
          },
          f: F
        };
      }

      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }

    var normalCompletion = true,
        didErr = false,
        err;
    return {
      s: function () {
        it = o[Symbol.iterator]();
      },
      n: function () {
        var step = it.next();
        normalCompletion = step.done;
        return step;
      },
      e: function (e) {
        didErr = true;
        err = e;
      },
      f: function () {
        try {
          if (!normalCompletion && it.return != null) it.return();
        } finally {
          if (didErr) throw err;
        }
      }
    };
  }

  var _MODEL_NAME_LENGTH;

  /**
   * 一些配置
   */
  var VERSION = {
    V1: 'Vocaloid Motion Data file',
    V2: 'Vocaloid Motion Data 0002'
  };
  var VERSION_BUFFER_LENGTH = 30;
  var MODEL_NAME_LENGTH = (_MODEL_NAME_LENGTH = {}, _defineProperty(_MODEL_NAME_LENGTH, VERSION.V1, 10), _defineProperty(_MODEL_NAME_LENGTH, VERSION.V2, 20), _MODEL_NAME_LENGTH);
  var TYPE = {
    int8_t: Int8Array,
    uint8_t: Uint8Array,
    int16_t: Int16Array,
    uint16_t: Uint16Array,
    int32_t: Int32Array,
    uint32_t: Uint32Array,
    float: Float32Array,
    double: Float64Array
  };
  /**
   * 骨骼名称
   */

  var BONE_NAME = ['センター', '上半身', '首', '頭', '左目', '右目', 'ﾈｸﾀｲ１', 'ﾈｸﾀｲ２', 'ﾈｸﾀｲ３', '下半身', '腰飾り', '左髪１', '左髪２', '左髪３', '左髪４', '左髪５', '左髪６', '左肩', '左腕', '左腕捩', '左ひじ', '左手捩', '左手首', '左袖', '左親指１', '左親指２', '左人指１', '左人指２', '左人指３', '左中指１', '左中指２', '左中指３', '左薬指１', '左薬指２', '左薬指３', '左小指１', '左小指２', '左小指３', '左ｽｶｰﾄ前', '左ｽｶｰﾄ後', '左足', '左ひざ', '左足首', '右髪１', '右髪２', '右髪３', '右髪４', '右髪５', '右髪６', '右肩', '右腕', '右腕捩', '右ひじ', '右手捩', '右手首', '右袖', '右親指１', '右親指２', '右人指１', '右人指２', '右人指３', '右中指１', '右中指２', '右中指３', '右薬指１', '右薬指２', '右薬指３', '右小指１', '右小指２', '右小指３', '右ｽｶｰﾄ前', '右ｽｶｰﾄ後', '右足', '右ひざ', '右足首', '両目', '前髪１', '前髪２', '前髪３', '左目光', '右目光', 'ﾈｸﾀｲ４', '左髪７', '右髪７', '左つま先', '右つま先', 'ﾈｸﾀｲＩＫ', '左髪ＩＫ', '右髪ＩＫ', '左足ＩＫ', '右足ＩＫ', '左つま先ＩＫ', '右つま先ＩＫ', '下半身先', '頭先', '左目先', '右目先', '腰飾り先', '左袖先', '左手先', '左親指先', '左人差指先', '左中指先', '左薬指先', '左小指先', '左スカート前先', '左スカート後先', '右袖先', '右手先', '右親指先', '右人差指先', '右中指先', '右薬指先', '右小指先', '右スカート前先', '右スカート後先', 'センター先', '両目先', 'ﾈｸﾀｲＩＫ先', '左髪ＩＫ先', '右髪ＩＫ先', '左足ＩＫ先', '右足ＩＫ先', '左つま先ＩＫ先', '右つま先ＩＫ先', '前髪１先', '前髪２先', '前髪３先', '左目光先', '右目光先', '左腕捩先', '左手捩先', '右腕捩先', '右手捩先', '左腕捩1', '左腕捩2', '左腕捩3', '右腕捩1', '右腕捩2', '右腕捩3'];

  /**
   * 内部日语用的翻译器
   */
  /**
   * 生成一个Array
   * @param {number} length
   * @param {number} [initValue]
   * @returns {number[]}
   */

  function generateArray(length) {
    var initValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

    if (!length) {
      throw new Error('length is required');
    }

    return Array.from(new Array(length)).map(function () {
      return initValue;
    });
  }
  /**
   * buffer转string
   * @param {ArrayBuffer} arrayBuffer
   */

  function buffer2string(arrayBuffer) {
    var uint8Array = new Uint8Array(arrayBuffer); // 这里因为长度的问题，其实buffer里填充用的，需要过滤掉填充字符

    var emptyFillIndex = uint8Array.indexOf(0);
    var buffer = uint8Array.slice(0, emptyFillIndex === -1 ? undefined : emptyFillIndex);
    var text = shiftjis.decode(buffer);
    return text;
  }
  function string2buffer(text) {
    return shiftjis.encode(text);
  }

  var ReadBufferStream = /*#__PURE__*/function () {
    /**
     * arrayBuffer
     * @param {ArrayBuffer} [buffer]
     */
    function ReadBufferStream(buffer) {
      _classCallCheck(this, ReadBufferStream);

      this.buffer = buffer || new ArrayBuffer(0);
      this.index = 0;
    }
    /**
     * 获取数组
     * @param {*} Constructor
     * @returns {*[]}
     */


    _createClass(ReadBufferStream, [{
      key: "readArrayByConstructor",
      value: function readArrayByConstructor(Constructor) {
        var totalNumber = this.readInt();
        var result = [];

        for (var i = 0; i < totalNumber; i++) {
          var data = new Constructor(this);
          result.push(data);
        }

        return result;
      }
      /**
       * 读取指定字节的数据
       * @param {*} length
       */

    }, {
      key: "readBytes",
      value: function readBytes() {
        var length = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

        if (typeof length !== 'number') {
          throw new Error('readBytes failed, place check arg');
        }

        if (length <= 0) {
          return '';
        }

        if (this.index + length > this.buffer.byteLength) {
          throw new Error("Stackoverflow ".concat(this.index + length, " / ").concat(this.buffer.byteLength));
        }

        var buffer = this.buffer.slice(this.index, this.index + length);
        this.index = length + this.index;
        return buffer;
      }
      /**
       * 读取uint32_t
       * @returns number
       */

    }, {
      key: "readInt",
      value: function readInt() {
        return this.readByType(TYPE.uint32_t);
      }
      /**
       * 读取float
       * @returns number
       */

    }, {
      key: "readFloat",
      value: function readFloat() {
        return this.readByType(TYPE.float);
      }
      /**
       * 读取文字
       * @param {number} [length]
       * @returns {string}
       */

    }, {
      key: "readString",
      value: function readString() {
        var length = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
        var buffer = this.readBytes(length);
        return buffer2string(buffer);
      }
      /**
       * 读取并格式化为具体类型
       * @param { Uint16ArrayConstructor | Uint32ArrayConstructor | Uint8ArrayConstructor | Float32ArrayConstructor | Float64ArrayConstructor } Type
       * @param {number} [offset]
       * @param {boolean} [littleEndian]
       * @returns { number }
       */

    }, {
      key: "readByType",
      value: function readByType(Type) {
        var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        var littleEndian = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

        if (!Type) {
          throw new Error('Type is not define');
        }

        var buffer = this.readBytes(Type.BYTES_PER_ELEMENT);
        var view = new DataView(buffer, 0);
        var method = "get".concat(Type.name.replace('Array', ''));
        return view[method](offset, littleEndian);
      }
      /**
       * 返回一个Typed后的数组
       * @param {number} [length]
       * @param { Uint16ArrayConstructor | Uint32ArrayConstructor | Uint8ArrayConstructor | Float32ArrayConstructor | Float64ArrayConstructor } [Type]
       * @param {number} [offset]
       * @param {boolean} [littleEndian]
       * @returns {number[]}
       */

    }, {
      key: "readArrayByType",
      value: function readArrayByType() {
        var length = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
        var Type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : TYPE.uint32_t;
        var offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
        var littleEndian = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
        var list = [];

        if (length < 0) {
          throw new Error('Invalid array length');
        }

        for (var i = 0; i < length; i++) {
          list.push(this.readByType(Type, offset, littleEndian));
        }

        return list;
      }
      /**
       * 获取剩余的bytes
       */

    }, {
      key: "close",

      /**
       * 清除保存的数据流
       */
      value: function close() {
        this.buffer = null;
        this.index = 0;
      }
    }, {
      key: "restBytes",
      get: function get() {
        return this.buffer.byteLength - this.index;
      }
    }]);

    return ReadBufferStream;
  }();

  var WriteBufferStream = /*#__PURE__*/function () {
    function WriteBufferStream() {
      _classCallCheck(this, WriteBufferStream);

      /**
       * @type { ArrayBuffer[] }
       */
      this.bufferList = [];
    }
    /**
     * 写入数组
     * @param {*[]} array TypedFrames
     * @returns {WriteBufferStream}
     */


    _createClass(WriteBufferStream, [{
      key: "writeTypedFrameArray",
      value: function writeTypedFrameArray(array) {
        var _this = this;

        var totalNumber = array.length;
        this.writeInt(totalNumber);
        array.forEach(function (typedFrame) {
          typedFrame.writeBuffer(_this);
        });
        return this;
      }
      /**
       * 写入指定长度的ArrayBuffer
       * @param {ArrayBuffer} value
       * @param {number} [length] 长度，以传入的arrayBuffer和length最大为准
       * @returns {WriteBufferStream}
       */

    }, {
      key: "writeBytes",
      value: function writeBytes(value) {
        var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        var buffer = new Uint8Array(Math.max(value.byteLength, length));
        buffer.set(value);
        this.bufferList.push(buffer.buffer);
        return this;
      }
      /**
       * 写入uint32_t
       * @param {number} value
       * @returns { WriteBufferStream }
       */

    }, {
      key: "writeInt",
      value: function writeInt(value) {
        return this.writeByType(value, TYPE.uint32_t);
      }
      /**
       * 写入float
       * @param {number} value
       * @returns { WriteBufferStream }
       */

    }, {
      key: "writeFloat",
      value: function writeFloat(value) {
        return this.writeByType(value, TYPE.float);
      }
      /**
       * 写入文字 文字默认为Uint8
       * @param {string} [text]
       * @param {number} [length]
       * @returns {WriteBufferStream}
       */

    }, {
      key: "writeString",
      value: function writeString() {
        var text = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
        var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        var textBuffer = string2buffer(text);
        var buffer = new Uint8Array(length);
        buffer.fill(253, textBuffer.length + 1);
        buffer.set(textBuffer); // 只有version是靠0填充的

        if (text === VERSION.V1 || text === VERSION.V2) {
          buffer.fill(0, textBuffer.length);
        }

        this.bufferList.push(buffer.buffer);
        return this;
      }
      /**
       * 根据类型自动写入
       * @param { number } value
       * @param { Uint16ArrayConstructor | Uint32ArrayConstructor | Uint8ArrayConstructor | Float32ArrayConstructor | Float64ArrayConstructor } Type
       * @param {number} [offset]
       * @param {boolean} [littleEndian]
       * @returns { WriteBufferStream }
       */

    }, {
      key: "writeByType",
      value: function writeByType(value, Type) {
        var offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
        var littleEndian = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;

        if (!Type) {
          throw new Error('Type is not define');
        }

        var view = new DataView(new ArrayBuffer(Type.BYTES_PER_ELEMENT), 0);
        var method = "set".concat(Type.name.replace('Array', ''));
        view[method](offset, value, littleEndian);
        this.bufferList.push(view.buffer);
        return this;
      }
      /**
       * 将一个数组写入
       * @param {number[]} value
       * @param { Uint16ArrayConstructor | Uint32ArrayConstructor | Uint8ArrayConstructor | Float32ArrayConstructor | Float64ArrayConstructor } [Type]
       * @param {number} [offset]
       * @param {boolean} [littleEndian]
       * @returns {WriteBufferStream}
       */

    }, {
      key: "writeArrayByType",
      value: function writeArrayByType(value) {
        var _this2 = this;

        var Type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : TYPE.uint32_t;
        var offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
        var littleEndian = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;

        if (!Array.isArray(value)) {
          throw new Error('value is not array!');
        }

        value.forEach(function (number) {
          _this2.writeByType(number, Type, offset, littleEndian);
        });
        return this;
      }
      /**
       * 清除保存的数据流
       */

    }, {
      key: "getArrayBuffer",
      value: function getArrayBuffer() {
        /**
         * 拼接
         */
        var totalBytes = this.bufferList.reduce(function (_totalBytes, buffer) {
          return _totalBytes + new Uint8Array(buffer).length;
        }, 0);
        var result = new Uint8Array(totalBytes);
        var offset = 0;

        var _iterator = _createForOfIteratorHelper(this.bufferList),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var _buffer = _step.value;
            result.set(new Uint8Array(_buffer), offset);
            offset += _buffer.byteLength;
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }

        var buffer = result.buffer;
        this.bufferList.splice(0);
        return buffer;
      }
    }]);

    return WriteBufferStream;
  }();

  var BoneFrame = /*#__PURE__*/function () {
    /**
     * @param {import('../stream/ReadBufferStream').default} [stream]
     */
    function BoneFrame(stream) {
      _classCallCheck(this, BoneFrame);

      /**
       * 骨骼名称 BoneName
       * byte*15(ShiftJIS)
       */
      this.boneName = '';
      /**
       * 关键帧时间 FrameTime
       * uint32_t
       */

      this.frameTime = 0;
      /**
       * x,y,z空间坐标 Translation.xyz
       * float*3
       */

      this.translation = generateArray(3);
      /**
       * 旋转四元数x,y,z,w Rotation.xyzw
       * float*4
       */

      this.rotation = generateArray(4);
      /**
       * 补间曲线x的坐标 XCurve
       * uint8_t*16
       */

      this.curveX = generateArray(16);
      /**
       * 补间曲线y的坐标 YCurve
       * uint8_t*16
       */

      this.curveY = generateArray(16);
      /**
       * 补间曲线z的坐标 ZCurve
       * uint8_t*16
       */

      this.curveZ = generateArray(16);
      /**
       * 补间曲线旋转的坐标 RCurve
       * uint8_t*16
       */

      this.curveR = generateArray(16);

      if (stream) {
        this.boneName = stream.readString(15);
        this.frameTime = stream.readInt();
        this.translation = stream.readArrayByType(3, TYPE.float);
        this.rotation = stream.readArrayByType(4, TYPE.float);
        this.curveX = stream.readArrayByType(16, TYPE.uint8_t);
        this.curveY = stream.readArrayByType(16, TYPE.uint8_t);
        this.curveZ = stream.readArrayByType(16, TYPE.uint8_t);
        this.curveR = stream.readArrayByType(16, TYPE.uint8_t);
      }
    }
    /**
     * 将本身数据写入stream
     * @param {import('../stream/WriteBufferStream').default} stream
     */


    _createClass(BoneFrame, [{
      key: "writeBuffer",
      value: function writeBuffer(stream) {
        if (!stream) {
          throw new Error('no stream!');
        }

        stream.writeString(this.boneName, 15);
        stream.writeInt(this.frameTime);
        stream.writeArrayByType(this.translation, TYPE.float);
        stream.writeArrayByType(this.rotation, TYPE.float);
        stream.writeArrayByType(this.curveX, TYPE.uint8_t);
        stream.writeArrayByType(this.curveY, TYPE.uint8_t);
        stream.writeArrayByType(this.curveZ, TYPE.uint8_t);
        stream.writeArrayByType(this.curveR, TYPE.uint8_t);
      }
    }]);

    return BoneFrame;
  }();

  var CameraFrame = /*#__PURE__*/function () {
    /**
     * @param {import('../stream/ReadBufferStream').default} stream
     */
    function CameraFrame(stream) {
      _classCallCheck(this, CameraFrame);

      /**
       * 关键帧时间 FrameTime
       * uint32_t
       */
      this.frameTime = 0;
      /**
       * 距离 Distance
       * float
       */

      this.distance = 0;
      /**
       * x,y,z空间坐标 Position.xyz
       * float*3
       */

      this.position = generateArray(3);
      /**
       * 旋转角度（弧度制） Rotation.xyz
       * float*3
       */

      this.rotation = generateArray(3);
      /**
       * 相机曲线 Curve
       * uint8_t*24
       */

      this.curve = generateArray(24);
      /**
       * 镜头FOV角度 ViewAngle
       * float
       */

      this.viewAngle = 0;
      /**
       * Orthographic相机
       * uint8_t
       */

      this.orthographic = 0;

      if (stream) {
        this.frameTime = stream.readInt();
        this.distance = stream.readFloat();
        this.position = stream.readArrayByType(3, TYPE.float);
        this.rotation = stream.readArrayByType(3, TYPE.float);
        this.curve = stream.readArrayByType(24, TYPE.uint8_t);
        this.viewAngle = stream.readInt();
        this.orthographic = stream.readInt();
      }
    }
    /**
     * 将本身数据写入stream
     * @param {import('../stream/WriteBufferStream').default} stream
     */


    _createClass(CameraFrame, [{
      key: "writeBuffer",
      value: function writeBuffer(stream) {
        if (!stream) {
          throw new Error('no stream!');
        }

        stream.writeInt(this.frameTime);
        stream.writeFloat(this.distance);
        stream.writeArrayByType(this.position, TYPE.float);
        stream.writeArrayByType(this.rotation, TYPE.float);
        stream.writeInt(this.viewAngle);
        stream.writeInt(this.orthographic);
      }
    }]);

    return CameraFrame;
  }();

  var LightFrame = /*#__PURE__*/function () {
    /**
     * @param {import('../stream/ReadBufferStream').default} stream
     */
    function LightFrame(stream) {
      _classCallCheck(this, LightFrame);

      /**
       * 关键帧时间 FrameTime
       * uint32_t
       */
      this.frameTime = 0;
      /**
       * RGB颜色空间 color.rgb
       * float*3
       */

      this.rgb = [0, 0, 0];
      /**
       * xyz投射方向 Direction.xyz
       * float*3
       */

      this.direction = [0, 0, 0];

      if (stream) {
        this.frameTime = stream.readInt();
        this.rgb = stream.readArrayByType(3, TYPE.float);
        this.direction = stream.readArrayByType(3, TYPE.float);
      }
    }
    /**
     * 将本身数据写入stream
     * @param {import('../stream/WriteBufferStream').default} stream
     */


    _createClass(LightFrame, [{
      key: "writeBuffer",
      value: function writeBuffer(stream) {
        if (!stream) {
          throw new Error('no stream!');
        }

        stream.writeInt(this.frameTime);
        stream.writeArrayByType(this.rgb, TYPE.float);
        stream.writeArrayByType(this.direction, TYPE.float);
      }
    }]);

    return LightFrame;
  }();

  var MorphFrame = /*#__PURE__*/function () {
    /**
     * @param {import('../stream/ReadBufferStream').default} stream
     */
    function MorphFrame(stream) {
      _classCallCheck(this, MorphFrame);

      /**
       * 表情名称 MorphName
       * byte*15(ShiftJIS)
       */
      this.morphName = '';
      /**
       * 关键帧时间 FrameTime
       * uint32_t
       */

      this.frameTime = 0;
      /**
       * 程度 Weight
       * float
       */

      this.weight = 0;

      if (stream) {
        this.morphName = stream.readString(15);
        this.frameTime = stream.readInt();
        this.weight = stream.readFloat();
      }
    }
    /**
     * 将本身数据写入stream
     * @param {import('../stream/WriteBufferStream').default} stream
     */


    _createClass(MorphFrame, [{
      key: "writeBuffer",
      value: function writeBuffer(stream) {
        if (!stream) {
          throw new Error('no stream!');
        }

        stream.writeString(this.morphName, 15);
        stream.writeInt(this.frameTime);
        stream.writeFloat(this.weight);
      }
    }]);

    return MorphFrame;
  }();

  var Vmd = /*#__PURE__*/function () {
    /**
     * @param { ArrayBuffer } [buffer]
     */
    function Vmd(buffer) {
      _classCallCheck(this, Vmd);

      /**
       * @type {string} 版本
       */
      this.version = VERSION.V2;
      /**
       * @type {string} 当前使用的模型名字
       */

      this.modelName = '';
      /**
       * @type {BoneFrame[]} 骨骼关键帧
       */

      this.boneFrames = []; // 骨骼关键帧

      this.morphFrames = []; // 表情关键帧

      this.cameraFrames = []; // 镜头关键帧

      this.lightFrames = []; // 光线关键帧

      /**
       * 从传入的文件流解析格式，生成配置信息，需要按照顺序读取buffer
       */

      if (buffer) {
        var stream = new ReadBufferStream(buffer);
        this.version = stream.readString(VERSION_BUFFER_LENGTH);
        this.modelName = stream.readString(MODEL_NAME_LENGTH[this.version]); // 骨骼

        this.boneFrames = stream.readArrayByConstructor(BoneFrame); // 表情

        this.morphFrames = stream.readArrayByConstructor(MorphFrame); // 摄像机

        this.cameraFrames = stream.readArrayByConstructor(CameraFrame); // 光线

        this.lightFrames = stream.readArrayByConstructor(LightFrame);
        stream.close();
      }
    }
    /**
     * 时间线
     */


    _createClass(Vmd, [{
      key: "write",

      /**
       * 将内部状态导出
       * @returns {ArrayBuffer}
       */
      value: function write() {
        var stream = new WriteBufferStream();
        stream.writeString(this.version, VERSION_BUFFER_LENGTH);
        stream.writeString(this.modelName, MODEL_NAME_LENGTH[this.version]); // 骨骼

        stream.writeTypedFrameArray(this.boneFrames); // 表情

        stream.writeTypedFrameArray(this.morphFrames); // 摄像机

        stream.writeTypedFrameArray(this.cameraFrames); // 光线

        stream.writeArrayByType(this.lightFrames);
        var arrayBuffer = stream.getArrayBuffer();
        return arrayBuffer;
      }
    }, {
      key: "timeline",
      get: function get() {
        var _this = this;

        var maxFrameTime = this.boneFrames.reduce(function (_maxFrameTime, _ref) {
          var frameTime = _ref.frameTime;
          return Math.max(_maxFrameTime, frameTime);
        }, 0); // frame类别的keys

        var frameTypeKeys = Object.keys(this).filter(function (key) {
          return key.includes('Frames');
        });
        var timeline = [];

        var _loop = function _loop(frameTime) {
          /**
           * 生成对应的frame数据，根据frameTime过滤一次
           */
          var frame = frameTypeKeys.reduce(function (_frame, key) {
            /**
             * @type { BoneFrame[] | MorphFrame[] | CameraFrame[] | LightFrame[] }
             */
            var typedFrames = _this[key];
            _frame[key] = typedFrames.filter(function (typedFrame) {
              return typedFrame.frameTime === frameTime;
            });
            return _frame;
          }, {
            frameTime: frameTime
          });
          timeline.push(frame);
        };

        for (var frameTime = 0; frameTime < maxFrameTime; frameTime++) {
          _loop(frameTime);
        }

        return timeline;
      }
    }]);

    return Vmd;
  }();

  exports.BONE_NAME = BONE_NAME;
  exports.BoneFrame = BoneFrame;
  exports.CameraFrame = CameraFrame;
  exports.LightFrame = LightFrame;
  exports.MorphFrame = MorphFrame;
  exports.VERSION = VERSION;
  exports.Vmd = Vmd;
  exports.default = Vmd;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
