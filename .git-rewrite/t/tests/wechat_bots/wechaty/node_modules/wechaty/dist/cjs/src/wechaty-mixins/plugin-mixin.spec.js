#!/usr/bin/env -S node --no-warnings --loader ts-node/esm
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tstest_1 = require("tstest");
const fp_ts_1 = require("fp-ts");
/**
 * Huan(202201): must import `./wechaty-impl.js` first
 *
 * Or will throw error:
 *
 * ReferenceError: Cannot access 'wechatifyUserModuleMixin' before initialization
 *   at file:///home/huan/git/wechaty/wechaty/src/wechaty/wechaty-base.ts:58:3 *
 *
 * TODO: find out why
 */
require("../wechaty/wechaty-impl.js");
const mod_js_1 = require("../wechaty-mixins/mod.js");
const wechaty_skeleton_js_1 = require("../wechaty/wechaty-skeleton.js");
const plugin_mixin_js_1 = require("./plugin-mixin.js");
const misc_mixin_js_1 = require("./misc-mixin.js");
const puppet_mixin_js_1 = require("./puppet-mixin.js");
const io_mixin_js_1 = require("./io-mixin.js");
const wechatify_user_module_mixin_js_1 = require("./wechatify-user-module-mixin.js");
(0, tstest_1.test)('ProtectedPropertyPluginMixin', async (t) => {
    const noOneLeft = true;
    t.ok(noOneLeft, 'should match Mixin properties for every protected property');
});
(0, tstest_1.test)('PluginMixin smoke testing', async (t) => {
    const sandbox = tstest_1.sinon.createSandbox({
        useFakeTimers: true,
    });
    const mixinBase = fp_ts_1.function.pipe(wechaty_skeleton_js_1.WechatySkeleton, mod_js_1.gErrorMixin, io_mixin_js_1.ioMixin, wechatify_user_module_mixin_js_1.wechatifyUserModuleMixin, puppet_mixin_js_1.puppetMixin, misc_mixin_js_1.miscMixin, plugin_mixin_js_1.pluginMixin);
    class PluginMixinTest extends mixinBase {
        counter = 0;
    }
    const Plugin = (wechaty) => {
        wechaty.counter++;
        return () => wechaty.counter--;
    };
    const pluginMixinTest = new PluginMixinTest({ puppet: 'wechaty-puppet-mock' });
    let future;
    const unuse = pluginMixinTest.use(Plugin);
    t.equal(pluginMixinTest.counter, 1, 'should call plugin function right after use before start');
    future = pluginMixinTest.start();
    t.equal(pluginMixinTest.counter, 1, 'should call plugin function right after start');
    /**
     * finish initializing the system
     */
    await sandbox.clock.runAllAsync();
    await future;
    // t.equal(pluginMixinTest.counter, 1, 'should call plugin function after start')
    future = pluginMixinTest.stop();
    await sandbox.clock.runAllAsync();
    await future;
    t.equal(pluginMixinTest.counter, 1, 'should not clean plugin context after stop');
    unuse();
    t.equal(pluginMixinTest.counter, 0, 'should clean plugin context after call unuse()');
    sandbox.restore();
});
//# sourceMappingURL=plugin-mixin.spec.js.map