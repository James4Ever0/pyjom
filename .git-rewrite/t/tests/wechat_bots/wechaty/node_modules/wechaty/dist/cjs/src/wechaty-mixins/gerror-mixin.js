"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.gErrorMixin = void 0;
const wechaty_puppet_1 = require("wechaty-puppet");
const gerror_1 = require("gerror");
const raven_js_1 = require("../raven.js");
const gErrorMixin = (mixinBase) => {
    wechaty_puppet_1.log.verbose('WechatyGErrorMixin', 'gErrorMixin(%s)', mixinBase.name);
    class GErrorMixin extends mixinBase {
        constructor(...args) {
            super(...args);
        }
        /**
         * Wrap promise in sync way (catch error by emitting it)
         *  1. convert a async callback function to be sync function
         *    by catcing any errors and emit them to error event
         *  2. wrap a Promise by catcing any errors and emit them to error event
         */
        wrapAsync = (0, gerror_1.wrapAsyncError)((e) => this.emit('error', e));
        /**
         * Wechaty internally can use `emit('error' whatever)` to emit any error
         * But the external call can only emit GError.
         * That's the reason why we need the below `emitError(e: any)
         */
        emitError(e) {
            this.emit('error', e);
        }
        /**
         * Convert any error to GError,
         *  and emit `error` event with GError
         */
        emit(event, ...args) {
            if (event !== 'error') {
                return super.emit(event, ...args);
            }
            /**
             * Dealing with the `error` event
             */
            const arg0 = args[0];
            let gerror;
            if (arg0 instanceof gerror_1.GError) {
                gerror = arg0;
            }
            else {
                gerror = gerror_1.GError.from(arg0);
            }
            (0, raven_js_1.wechatyCaptureException)(gerror);
            return super.emit('error', gerror);
        }
    }
    return GErrorMixin;
};
exports.gErrorMixin = gErrorMixin;
//# sourceMappingURL=gerror-mixin.js.map