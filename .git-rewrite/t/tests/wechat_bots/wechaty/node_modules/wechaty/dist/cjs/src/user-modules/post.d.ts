/**
 *   Wechaty Chatbot SDK - https://github.com/wechaty/wechaty
 *
 *   @copyright 2016 Huan LI (李卓桓) <https://github.com/huan>, and
 *                   Wechaty Contributors <https://github.com/wechaty>.
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 */
/**
 * Issue #2245 - New Wechaty User Module (WUM):
 *  `Post` for supporting Moments, Channel, Tweet, Weibo, Facebook feeds, etc.
 *
 *  @see https://github.com/wechaty/wechaty/issues/2245#issuecomment-914886835
 */
import * as PUPPET from 'wechaty-puppet';
import type { Constructor } from 'clone-class';
import type { Sayable } from '../sayable/mod.js';
import type { ContactInterface } from './contact.js';
interface Tap {
    contact: ContactInterface;
    type: PUPPET.types.Tap;
    date: Date;
}
declare class PostBuilder {
    protected Impl: typeof PostMixin;
    payload: PUPPET.payloads.PostClient;
    /**
     * Wechaty Sayable List
     */
    sayableList: Sayable[];
    /**
     * Huan(202201): why use Impl as a parameter?
     */
    static new(Impl: typeof PostMixin): PostBuilder;
    protected constructor(Impl: typeof PostMixin);
    add(sayable: Sayable): this;
    type(type: PUPPET.types.Post): this;
    reply(post: PostInterface): this;
    build(): Promise<PostInterface>;
}
declare const PostMixin_base: ((abstract new (...args: any[]) => {
    readonly wechaty: import("../wechaty/wechaty-impl.js").WechatyInterface;
}) & {
    readonly wechaty: import("../wechaty/wechaty-impl.js").WechatyInterface;
}) & {
    new (): {};
};
declare class PostMixin extends PostMixin_base {
    static builder(): PostBuilder;
    /**
     *
     * Create
     *
     */
    static create(payload: PUPPET.payloads.PostClient): PostInterface;
    static load(id: string): PostInterface;
    static find(filter: PUPPET.filters.Post): Promise<undefined | PostInterface>;
    static findAll(filter: PUPPET.filters.Post, pagination?: PUPPET.filters.PaginationRequest): Promise<[
        postList: PostInterface[],
        nextPageToken?: string
    ]>;
    protected _payload?: PUPPET.payloads.Post;
    get payload(): PUPPET.payloads.Post;
    readonly id?: string;
    constructor(idOrPayload: string | PUPPET.payloads.Post);
    counter(): PUPPET.payloads.PostServer['counter'];
    author(): Promise<ContactInterface>;
    root(): Promise<undefined | PostInterface>;
    parent(): Promise<undefined | PostInterface>;
    sync(): Promise<void>;
    ready(): Promise<void>;
    [Symbol.asyncIterator](): AsyncIterableIterator<Sayable>;
    children(filter?: PUPPET.filters.Post): AsyncIterableIterator<PostInterface>;
    descendants(filter?: PUPPET.filters.Post): AsyncIterableIterator<PostInterface>;
    likes(filter?: PUPPET.filters.Post): AsyncIterableIterator<Tap>;
    taps(filter?: PUPPET.filters.Tap): AsyncIterableIterator<Tap>;
    reply(sayable: Exclude<Sayable, PostInterface> | Exclude<Sayable, PostInterface>[]): Promise<void | PostInterface>;
    like(status: boolean): Promise<void>;
    like(): Promise<boolean>;
    /**
     * Return Date if the bot has tapped the post, otherwise return undefined
     */
    tap(type: PUPPET.types.Tap): Promise<boolean>;
    tap(type: PUPPET.types.Tap, status: boolean): Promise<void>;
    tapFind(filter: PUPPET.filters.Tap, pagination?: PUPPET.filters.PaginationRequest): Promise<[
        tapList: Tap[],
        nextPageToken?: string
    ]>;
}
declare const PostImpl_base: {
    new (...args: any[]): {};
    valid: (o: any) => o is PostInterface;
    validInstance: (target: any) => target is PostMixin;
    validInterface: (target: any) => target is PostInterface;
} & typeof PostMixin;
declare class PostImpl extends PostImpl_base {
}
interface PostInterface extends PostImpl {
}
declare type PostConstructor = Constructor<PostInterface, typeof PostImpl>;
export type { PostConstructor, PostInterface, };
export { PostBuilder, PostImpl, };
//# sourceMappingURL=post.d.ts.map