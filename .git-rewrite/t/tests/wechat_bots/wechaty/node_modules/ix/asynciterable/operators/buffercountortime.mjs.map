{"version":3,"sources":["asynciterable/operators/buffercountortime.ts"],"names":[],"mappings":"AACA,OAAO,EAAE,cAAc,EAAE,QAAQ,EAAE,MAAM,EAAE,EAAE,EAAE,MAAM,KAAK,CAAC;AAC3D,OAAO,EAAE,GAAG,EAAE,MAAM,OAAO,CAAC;AAC5B,OAAO,EAAE,KAAK,EAAE,MAAM,UAAU,CAAC;AACjC,OAAO,EAAE,aAAa,EAAE,MAAM,aAAa,CAAC;AAE5C,MAAM,UAAU,GAAG,EAAE,CAAC;AACtB,MAAM,KAAK,GAAG,EAAE,CAAC;AAEjB,MAAM,iBAA2B,SAAQ,cAAyB;IAE7C;IACA;IACA;IAHnB,YACmB,MAA8B,EAC9B,UAAkB,EAClB,WAAmB;QAEpC,KAAK,EAAE,CAAC;QAJS,WAAM,GAAN,MAAM,CAAwB;QAC9B,eAAU,GAAV,UAAU,CAAQ;QAClB,gBAAW,GAAX,WAAW,CAAQ;IAGtC,CAAC;IAED,KAAK,CAAC,CAAC,CAAC,MAAM,CAAC,aAAa,CAAC,CAAC,MAAoB;QAChD,MAAM,MAAM,GAAc,EAAE,CAAC;QAC7B,MAAM,KAAK,GAAG,QAAQ,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,GAAG,EAAE,CAAC,UAAU,CAAC,CAAC,CAAC;QACrE,MAAM,MAAM,GAAG,MAAM,CAAC,IAAI,CAAC,MAAM,EAAE,EAAE,CAAC,KAAK,CAAC,CAAC,CAAC;QAC9C,MAAM,MAAM,GAAG,KAAK,CAAC,MAAM,EAAE,KAAK,CAAC,CAAC;QAEpC,IAAI,KAAK,EAAE,MAAM,IAAI,IAAI,aAAa,CAAC,MAAM,EAAE,MAAM,CAAC,EAAE;YACtD,IAAI,IAAI,KAAK,KAAK,EAAE;gBAClB,MAAM;aACP;YACD,IAAI,IAAI,KAAK,UAAU,EAAE;gBACvB,MAAM,CAAC,IAAI,CAAC,IAAe,CAAC,CAAC;aAC9B;YACD,IAAI,MAAM,CAAC,MAAM,IAAI,IAAI,CAAC,UAAU,IAAI,CAAC,MAAM,CAAC,MAAM,IAAI,IAAI,KAAK,UAAU,CAAC,EAAE;gBAC9E,MAAM,MAAM,CAAC,KAAK,EAAE,CAAC;gBACrB,MAAM,CAAC,MAAM,GAAG,CAAC,CAAC;aACnB;SACF;QAED,IAAI,MAAM,CAAC,MAAM,EAAE;YACjB,MAAM,MAAM,CAAC;SACd;IACH,CAAC;CACF;AAED;;;;;;;;;GASG;AACH,MAAM,UAAU,iBAAiB,CAC/B,KAAa,EACb,IAAY;IAEZ,OAAO,SAAS,sBAAsB,CACpC,MAA8B;QAE9B,OAAO,IAAI,iBAAiB,CAAU,MAAM,EAAE,KAAK,EAAE,IAAI,CAAC,CAAC;IAC7D,CAAC,CAAC;AACJ,CAAC","file":"buffercountortime.js","sourcesContent":["import { OperatorAsyncFunction } from '../../interfaces';\nimport { AsyncIterableX, interval, concat, of } from '../';\nimport { map } from './map';\nimport { merge } from '../merge';\nimport { wrapWithAbort } from './withabort';\n\nconst timerEvent = {};\nconst ended = {};\n\nclass BufferCountOrTime<TSource> extends AsyncIterableX<TSource[]> {\n  constructor(\n    private readonly source: AsyncIterable<TSource>,\n    private readonly bufferSize: number,\n    private readonly maxWaitTime: number\n  ) {\n    super();\n  }\n\n  async *[Symbol.asyncIterator](signal?: AbortSignal) {\n    const buffer: TSource[] = [];\n    const timer = interval(this.maxWaitTime).pipe(map(() => timerEvent));\n    const source = concat(this.source, of(ended));\n    const merged = merge(source, timer);\n\n    for await (const item of wrapWithAbort(merged, signal)) {\n      if (item === ended) {\n        break;\n      }\n      if (item !== timerEvent) {\n        buffer.push(item as TSource);\n      }\n      if (buffer.length >= this.bufferSize || (buffer.length && item === timerEvent)) {\n        yield buffer.slice();\n        buffer.length = 0;\n      }\n    }\n\n    if (buffer.length) {\n      yield buffer;\n    }\n  }\n}\n\n/**\n * Projects each element of an async-iterable sequence into consecutive buffers\n * which are emitted when either the threshold count or time is met.\n *\n * @template TSource The type of elements in the source sequence.\n * @param {number} count The size of the buffer.\n * @param {number} time The threshold number of milliseconds to wait before flushing a non-full buffer\n * @returns {OperatorAsyncFunction<TSource, TSource[]>} An operator which returns an async-iterable sequence\n * of buffers\n */\nexport function bufferCountOrTime<TSource>(\n  count: number,\n  time: number\n): OperatorAsyncFunction<TSource, TSource[]> {\n  return function bufferOperatorFunction(\n    source: AsyncIterable<TSource>\n  ): AsyncIterableX<TSource[]> {\n    return new BufferCountOrTime<TSource>(source, count, time);\n  };\n}\n"]}