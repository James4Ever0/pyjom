{"version":3,"sources":["asynciterable/generate.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,cAAc,EAAE,MAAM,kBAAkB,CAAC;AAClD,OAAO,EAAE,cAAc,EAAE,MAAM,eAAe,CAAC;AAE/C,MAAM,qBAAuC,SAAQ,cAAuB;IAClE,aAAa,CAAS;IACtB,UAAU,CAAsE;IAChF,QAAQ,CAAoE;IAC5E,eAAe,CAAsE;IAE7F,YACE,YAAoB,EACpB,SAA8E,EAC9E,OAA0E,EAC1E,cAAmF;QAEnF,KAAK,EAAE,CAAC;QACR,IAAI,CAAC,aAAa,GAAG,YAAY,CAAC;QAClC,IAAI,CAAC,UAAU,GAAG,SAAS,CAAC;QAC5B,IAAI,CAAC,QAAQ,GAAG,OAAO,CAAC;QACxB,IAAI,CAAC,eAAe,GAAG,cAAc,CAAC;IACxC,CAAC;IAED,KAAK,CAAC,CAAC,CAAC,MAAM,CAAC,aAAa,CAAC,CAAC,MAAoB;QAChD,cAAc,CAAC,MAAM,CAAC,CAAC;QACvB,KACE,IAAI,CAAC,GAAG,IAAI,CAAC,aAAa,EAC1B,MAAM,IAAI,CAAC,UAAU,CAAC,CAAC,EAAE,MAAM,CAAC,EAChC,CAAC,GAAG,MAAM,IAAI,CAAC,QAAQ,CAAC,CAAC,EAAE,MAAM,CAAC,EAClC;YACA,MAAM,MAAM,IAAI,CAAC,eAAe,CAAC,CAAC,EAAE,MAAM,CAAC,CAAC;SAC7C;IACH,CAAC;CACF;AAED;;;;;;;;;;;GAWG;AACH,MAAM,UAAU,QAAQ,CACtB,YAAoB,EACpB,SAA8E,EAC9E,OAA0E,EAC1E,cAAmF;IAEnF,OAAO,IAAI,qBAAqB,CAC9B,YAAY,EACZ,SAAS,EACT,OAAO,EACP,cAAc,CACf,CAAC;AACJ,CAAC","file":"generate.js","sourcesContent":["import { AsyncIterableX } from './asynciterablex';\nimport { throwIfAborted } from '../aborterror';\n\nclass GenerateAsyncIterable<TState, TResult> extends AsyncIterableX<TResult> {\n  private _initialState: TState;\n  private _condition: (value: TState, signal?: AbortSignal) => boolean | Promise<boolean>;\n  private _iterate: (value: TState, signal?: AbortSignal) => TState | Promise<TState>;\n  private _resultSelector: (value: TState, signal?: AbortSignal) => TResult | Promise<TResult>;\n\n  constructor(\n    initialState: TState,\n    condition: (value: TState, signal?: AbortSignal) => boolean | Promise<boolean>,\n    iterate: (value: TState, signal?: AbortSignal) => TState | Promise<TState>,\n    resultSelector: (value: TState, signal?: AbortSignal) => TResult | Promise<TResult>\n  ) {\n    super();\n    this._initialState = initialState;\n    this._condition = condition;\n    this._iterate = iterate;\n    this._resultSelector = resultSelector;\n  }\n\n  async *[Symbol.asyncIterator](signal?: AbortSignal) {\n    throwIfAborted(signal);\n    for (\n      let i = this._initialState;\n      await this._condition(i, signal);\n      i = await this._iterate(i, signal)\n    ) {\n      yield await this._resultSelector(i, signal);\n    }\n  }\n}\n\n/**\n * Generates an async-iterable sequence by running a state-driven loop producing the sequence's elements.\n *\n * @template TState The type of the state used in the generator loop.\n * @template TResult The type of the elements in the produced sequence.\n * @param {TState} initialState The initial state.\n * @param {((value: TState, signal?: AbortSignal) => boolean | Promise<boolean>)} condition Condition to terminate generation (upon returning false).\n * @param {((value: TState, signal?: AbortSignal) => TState | Promise<TState>)} iterate Iteration step function.\n * @param {((value: TState, signal?: AbortSignal) => TResult | Promise<TResult>)} resultSelector Selector function for results produced in\n * the sequence.\n * @returns {AsyncIterableX<TResult>} The generated async-iterable sequence.\n */\nexport function generate<TState, TResult>(\n  initialState: TState,\n  condition: (value: TState, signal?: AbortSignal) => boolean | Promise<boolean>,\n  iterate: (value: TState, signal?: AbortSignal) => TState | Promise<TState>,\n  resultSelector: (value: TState, signal?: AbortSignal) => TResult | Promise<TResult>\n): AsyncIterableX<TResult> {\n  return new GenerateAsyncIterable<TState, TResult>(\n    initialState,\n    condition,\n    iterate,\n    resultSelector\n  );\n}\n"]}