{"version":3,"sources":["asynciterable/average.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,aAAa,EAAE,MAAM,kBAAkB,CAAC;AACjD,OAAO,EAAE,aAAa,EAAE,MAAM,uBAAuB,CAAC;AACtD,OAAO,EAAE,cAAc,EAAE,MAAM,eAAe,CAAC;AA0B/C;;;;;;GAMG;AACH,MAAM,CAAC,KAAK,UAAU,OAAO,CAC3B,MAA0B,EAC1B,OAA0B;IAE1B,MAAM,EACJ,CAAC,UAAU,CAAC,EAAE,QAAQ,GAAG,aAAoB,EAC7C,CAAC,QAAQ,CAAC,EAAE,MAAM,EAClB,CAAC,SAAS,CAAC,EAAE,OAAO,GACrB,GAAG,OAAO,IAAI,EAAE,CAAC;IAClB,cAAc,CAAC,MAAM,CAAC,CAAC;IACvB,IAAI,GAAG,GAAG,CAAC,CAAC;IACZ,IAAI,KAAK,GAAG,CAAC,CAAC;IACd,IAAI,KAAK,EAAE,MAAM,IAAI,IAAI,aAAa,CAAC,MAAM,EAAE,MAAM,CAAC,EAAE;QACtD,GAAG,IAAI,MAAM,QAAQ,CAAC,IAAI,CAAC,OAAO,EAAE,IAAI,EAAE,MAAM,CAAC,CAAC;QAClD,KAAK,EAAE,CAAC;KACT;IAED,IAAI,KAAK,KAAK,CAAC,EAAE;QACf,MAAM,IAAI,KAAK,CAAC,kBAAkB,CAAC,CAAC;KACrC;IAED,OAAO,GAAG,GAAG,KAAK,CAAC;AACrB,CAAC","file":"average.js","sourcesContent":["import { identityAsync } from '../util/identity';\nimport { wrapWithAbort } from './operators/withabort';\nimport { throwIfAborted } from '../aborterror';\nimport { MathOptions } from './mathoptions';\n\n/**\n * Computes the average of the async-iterable sequence.\n *\n * @param {AsyncIterable<number>} source The source async-iterable sequence to compute the average.\n * @param {AverageOptions<number>} [options] The options for calculating the average.\n * @returns {Promise<number>} A Promise which returns the computed average for the async-iterable sequence.\n */\nexport async function average(\n  source: AsyncIterable<number>,\n  options?: MathOptions<number>\n): Promise<number>;\n/**\n * Computes the average of the async-iterable sequence.\n *\n * @template TSource The type of elements in the source sequence.\n * @param {AsyncIterable<TSource>} source source async-iterable sequence to compute the average.\n * @param {AverageOptions<TSource>} [options] The options for calculating the average.\n * @returns {Promise<number>} A Promise which returns the computed average for the async-iterable sequence.\n */\nexport async function average<TSource>(\n  source: AsyncIterable<TSource>,\n  options?: MathOptions<TSource>\n): Promise<number>;\n/**\n * Computes the average of the async-iterable sequence.\n *\n * @param {AsyncIterable<any>} source source async-iterable sequence to compute the average.\n * @param {AverageOptions<any>} [options] The options for calculating the average.\n * @returns {Promise<number>} A Promise which returns the computed average for the async-iterable sequence.\n */\nexport async function average(\n  source: AsyncIterable<any>,\n  options?: MathOptions<any>\n): Promise<number> {\n  const {\n    ['selector']: selector = identityAsync as any,\n    ['signal']: signal,\n    ['thisArg']: thisArg,\n  } = options || {};\n  throwIfAborted(signal);\n  let sum = 0;\n  let count = 0;\n  for await (const item of wrapWithAbort(source, signal)) {\n    sum += await selector.call(thisArg, item, signal);\n    count++;\n  }\n\n  if (count === 0) {\n    throw new Error('Empty collection');\n  }\n\n  return sum / count;\n}\n"]}