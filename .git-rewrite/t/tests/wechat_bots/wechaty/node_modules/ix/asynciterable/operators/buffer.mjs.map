{"version":3,"sources":["asynciterable/operators/buffer.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,cAAc,EAAE,MAAM,mBAAmB,CAAC;AAEnD,OAAO,EAAE,aAAa,EAAE,MAAM,aAAa,CAAC;AAC5C,OAAO,EAAE,cAAc,EAAE,MAAM,kBAAkB,CAAC;AAElD,MAAM,OAAO,mBAA6B,SAAQ,cAAyB;IACjE,OAAO,CAAyB;IAChC,MAAM,CAAS;IACf,KAAK,CAAS;IAEtB,YAAY,MAA8B,EAAE,KAAa,EAAE,IAAY;QACrE,KAAK,EAAE,CAAC;QACR,IAAI,CAAC,OAAO,GAAG,MAAM,CAAC;QACtB,IAAI,CAAC,MAAM,GAAG,KAAK,CAAC;QACpB,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC;IACpB,CAAC;IAED,KAAK,CAAC,CAAC,CAAC,MAAM,CAAC,aAAa,CAAC,CAAC,MAAoB;QAChD,cAAc,CAAC,MAAM,CAAC,CAAC;QACvB,MAAM,OAAO,GAAgB,EAAE,CAAC;QAChC,IAAI,CAAC,GAAG,CAAC,CAAC;QACV,IAAI,KAAK,EAAE,MAAM,IAAI,IAAI,aAAa,CAAC,IAAI,CAAC,OAAO,EAAE,MAAM,CAAC,EAAE;YAC5D,IAAI,CAAC,GAAG,IAAI,CAAC,KAAK,KAAK,CAAC,EAAE;gBACxB,OAAO,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;aAClB;YAED,KAAK,MAAM,IAAI,IAAI,OAAO,EAAE;gBAC1B,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;aACjB;YAED,IAAI,OAAO,CAAC,MAAM,GAAG,CAAC,IAAI,OAAO,CAAC,CAAC,CAAC,CAAC,MAAM,KAAK,IAAI,CAAC,MAAM,EAAE;gBAC3D,MAAM,OAAO,CAAC,KAAK,EAAG,CAAC;aACxB;YAED,CAAC,EAAE,CAAC;SACL;QAED,OAAO,OAAO,CAAC,MAAM,GAAG,CAAC,EAAE;YACzB,MAAM,OAAO,CAAC,KAAK,EAAG,CAAC;SACxB;IACH,CAAC;CACF;AAED;;;;;;;;;GASG;AACH,MAAM,UAAU,MAAM,CACpB,KAAa,EACb,IAAa;IAEb,IAAI,CAAC,GAAG,IAAI,CAAC;IACb,IAAI,CAAC,IAAI,IAAI,EAAE;QACb,CAAC,GAAG,KAAK,CAAC;KACX;IACD,OAAO,SAAS,sBAAsB,CACpC,MAA8B;QAE9B,OAAO,IAAI,mBAAmB,CAAU,MAAM,EAAE,KAAK,EAAE,CAAE,CAAC,CAAC;IAC7D,CAAC,CAAC;AACJ,CAAC;AAED;;;;;GAKG","file":"buffer.js","sourcesContent":["import { AsyncIterableX } from '../asynciterablex';\nimport { OperatorAsyncFunction } from '../../interfaces';\nimport { wrapWithAbort } from './withabort';\nimport { throwIfAborted } from '../../aborterror';\n\nexport class BufferAsyncIterable<TSource> extends AsyncIterableX<TSource[]> {\n  private _source: AsyncIterable<TSource>;\n  private _count: number;\n  private _skip: number;\n\n  constructor(source: AsyncIterable<TSource>, count: number, skip: number) {\n    super();\n    this._source = source;\n    this._count = count;\n    this._skip = skip;\n  }\n\n  async *[Symbol.asyncIterator](signal?: AbortSignal) {\n    throwIfAborted(signal);\n    const buffers: TSource[][] = [];\n    let i = 0;\n    for await (const item of wrapWithAbort(this._source, signal)) {\n      if (i % this._skip === 0) {\n        buffers.push([]);\n      }\n\n      for (const buff of buffers) {\n        buff.push(item);\n      }\n\n      if (buffers.length > 0 && buffers[0].length === this._count) {\n        yield buffers.shift()!;\n      }\n\n      i++;\n    }\n\n    while (buffers.length > 0) {\n      yield buffers.shift()!;\n    }\n  }\n}\n\n/**\n * Projects each element of an async-iterable sequence into consecutive non-overlapping\n * buffers which are produced based on element count information.\n *\n * @template TSource The type of elements in the source sequence.\n * @param {number} count The length of each buffer.\n * @param {number} [skip] An optional number of elements to skip between creation of consecutive buffers.\n * @returns {OperatorAsyncFunction<TSource, TSource[]>} An operator which returns anm async-iterable sequence with\n * consecutive non-overlapping buffers based upon element count information.\n */\nexport function buffer<TSource>(\n  count: number,\n  skip?: number\n): OperatorAsyncFunction<TSource, TSource[]> {\n  let s = skip;\n  if (s == null) {\n    s = count;\n  }\n  return function bufferOperatorFunction(\n    source: AsyncIterable<TSource>\n  ): AsyncIterableX<TSource[]> {\n    return new BufferAsyncIterable<TSource>(source, count, s!);\n  };\n}\n\n/**\n * Projects each element of an async-iterable sequence into consecutive non-overlapping\n * buffers which are produced based on element count information.\n * @param count Length of each buffer.\n * @param skip Number of elements to skip between creation of consecutive buffers.\n */\n"]}