#!/usr/bin/env -S node --no-warnings --loader ts-node/esm
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tstest_1 = require("tstest");
const busy_indicator_js_1 = require("./busy-indicator.js");
(0, tstest_1.test)('BusyIndicator init state', async (t) => {
    const indicator = new busy_indicator_js_1.BusyIndicator();
    t.equal(indicator.busy(), false, 'should not be not busy after init');
    await t.resolves(() => indicator.idle(), 'should be idle after init');
});
(0, tstest_1.test)('BusyIndicator set busy', async (t) => {
    const sandbox = tstest_1.sinon.createSandbox();
    const spy = sandbox.spy();
    const indicator = new busy_indicator_js_1.BusyIndicator();
    indicator.busy(true);
    t.equal(indicator.busy(), true, 'should not be busy after set busy');
    indicator.idle().then(spy).catch(e => t.fail(e));
    await new Promise(setImmediate);
    t.equal(spy.callCount, 0, 'should not resolve idle() when busy');
    sandbox.restore();
});
(0, tstest_1.test)('BusyIndicator state transition', async (t) => {
    const sandbox = tstest_1.sinon.createSandbox();
    const spy = sandbox.spy();
    const indicator = new busy_indicator_js_1.BusyIndicator();
    indicator.busy(true);
    indicator.idle().then(spy).catch(e => t.fail(e));
    await new Promise(setImmediate);
    t.equal(spy.callCount, 0, 'should not resolve idle() when busy');
    indicator.busy(false);
    await new Promise(setImmediate);
    t.equal(spy.callCount, 1, 'should resolve idle() when set busy to false');
});
//# sourceMappingURL=busy-indicator.spec.js.map