#!/usr/bin/env -S node --no-warnings --loader ts-node/esm
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tstest_1 = require("tstest");
const watchdog_js_1 = require("./watchdog.js");
// const sinonTest   = require('sinon-test')(sinon)
(0, tstest_1.test)('starve to reset', async (t) => {
    const sandbox = tstest_1.sinon.createSandbox({
        useFakeTimers: true,
    });
    const TIMEOUT = 1 * 1000;
    const EXPECTED_FOOD = {
        data: 'dummy',
        timeoutMilliseconds: TIMEOUT,
    };
    const watchdog = new watchdog_js_1.Watchdog(TIMEOUT, 'TestWatchdog');
    watchdog.on('reset', (food, timeout) => {
        t.equal(timeout, TIMEOUT, 'timeout should equal to TIMEOUT when reset');
        t.same(food, EXPECTED_FOOD, 'should get food back when reset');
    });
    watchdog.feed(EXPECTED_FOOD);
    sandbox.clock.tick(TIMEOUT + 1);
    sandbox.restore();
});
(0, tstest_1.test)('feed in the middle', async (t) => {
    const sandbox = tstest_1.sinon.createSandbox({
        useFakeTimers: true,
    });
    // console.log('this', this)
    const TIMEOUT = 1 * 1000;
    const FEED_TIME = 0.3 * 1000;
    const watchdog = new watchdog_js_1.Watchdog(TIMEOUT, 'TestWatchdog');
    watchdog.on('reset', () => {
        t.fail('should not be reset');
    });
    watchdog.feed({ data: 'dummy' });
    sandbox.clock.tick(FEED_TIME);
    const left = watchdog.feed({ data: 'dummy' });
    t.equal(left, TIMEOUT - FEED_TIME, 'should get the time left dependes on the FEED_TIME');
    sandbox.restore();
});
(0, tstest_1.test)('sleep()', async (t) => {
    const sandbox = tstest_1.sinon.createSandbox({
        useFakeTimers: true,
    });
    const TIMEOUT = 1 * 1000;
    const FEED_TIME = 0.3 * 1000;
    const watchdog = new watchdog_js_1.Watchdog(TIMEOUT, 'TestWatchdog');
    watchdog.on('reset', () => {
        t.fail('should not be reset');
    });
    watchdog.feed({ data: 'dummy' });
    sandbox.clock.tick(FEED_TIME);
    watchdog.sleep();
    sandbox.clock.tick(TIMEOUT * 2);
    const left = watchdog.left();
    t.ok(left < 0, 'time should already passed by...');
    sandbox.restore();
});
(0, tstest_1.test)('event:feed', async (t) => {
    const watchdog = new watchdog_js_1.Watchdog();
    const spy = tstest_1.sinon.spy();
    watchdog.on('feed', spy);
    watchdog.feed({ data: 'dummy' });
    watchdog.sleep();
    t.ok(spy.calledOnce, 'should fire event:feed');
});
(0, tstest_1.test)('event:sleep', async (t) => {
    const watchdog = new watchdog_js_1.Watchdog();
    const spy = tstest_1.sinon.spy();
    watchdog.on('sleep', spy);
    watchdog.sleep();
    t.ok(spy.calledOnce, 'should fire event:sleep');
});
(0, tstest_1.test)('version()', async (t) => {
    const dog = new watchdog_js_1.Watchdog();
    t.ok(dog.version(), 'should get version');
});
//# sourceMappingURL=watchdog.spec.js.map