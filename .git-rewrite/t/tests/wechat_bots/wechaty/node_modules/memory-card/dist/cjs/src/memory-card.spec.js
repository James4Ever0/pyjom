#!/usr/bin/env -S node --no-warnings --loader ts-node/esm
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tstest_1 = require("tstest");
const fixtures_js_1 = require("../tests/fixtures.js");
const memory_card_js_1 = require("./memory-card.js");
(0, tstest_1.test)('smoke testing', async (t) => {
    const card = new memory_card_js_1.MemoryCard();
    await card.load();
    t.equal(await card.size, 0, 'init with 0');
    await card.set('a', 'b');
    t.equal(await card.size, 1, 'size with 1');
    t.equal(await card.get('a'), 'b', 'get key a with value b');
    await card.clear();
    t.equal(await card.size, 0, 'clear reset to 0');
});
(0, tstest_1.test)('storage file load/save', async (t) => {
    const EXPECTED_KEY = 'key';
    const EXPECTED_VAL = 'val';
    const NAME = Math.random().toString().substr(2);
    const card = new memory_card_js_1.MemoryCard({
        name: NAME,
        storageOptions: {
            type: 'file',
        },
    });
    await card.load();
    await card.set(EXPECTED_KEY, EXPECTED_VAL);
    await card.save();
    const cardB = new memory_card_js_1.MemoryCard({
        name: NAME,
        storageOptions: {
            type: 'file',
        },
    });
    await cardB.load();
    t.equal(await cardB.get(EXPECTED_KEY), EXPECTED_VAL, 'should get val back from file');
    await card.destroy();
    await cardB.destroy();
});
(0, tstest_1.test)('storage aws s3 load/save', async (t) => {
    if (!fixtures_js_1.AWS_SETTING) {
        await t.skip('AWS S3 environment variable not found.');
        return;
    }
    const EXPECTED_KEY = 'key';
    const EXPECTED_VAL = 'val';
    const NAME = Math.random().toString().substr(2);
    const storageOptions = {
        ...fixtures_js_1.AWS_SETTING,
        type: 's3',
    };
    const card = new memory_card_js_1.MemoryCard({
        name: NAME,
        storageOptions,
    });
    await card.load();
    await card.set(EXPECTED_KEY, EXPECTED_VAL);
    await card.save();
    const cardB = new memory_card_js_1.MemoryCard({
        name: NAME,
        storageOptions,
    });
    await cardB.load();
    t.equal(await cardB.get(EXPECTED_KEY), EXPECTED_VAL, 'should get val back from s3');
    await card.destroy();
    await cardB.destroy();
});
tstest_1.test.skip('storage huawei obs load/save', async (t) => {
    const EXPECTED_KEY = 'key';
    const EXPECTED_VAL = 'val';
    const NAME = Math.random().toString().substr(2);
    const storageOptions = {
        accessKeyId: fixtures_js_1.OBS_SETTING.ACCESS_KEY_ID,
        bucket: fixtures_js_1.OBS_SETTING.BUCKET,
        secretAccessKey: fixtures_js_1.OBS_SETTING.SECRET_ACCESS_KEY,
        server: fixtures_js_1.OBS_SETTING.SERVER,
        type: 'obs',
    };
    const card = new memory_card_js_1.MemoryCard({
        name: NAME,
        storageOptions,
    });
    await card.load();
    await card.set(EXPECTED_KEY, EXPECTED_VAL);
    await card.save();
    const cardB = new memory_card_js_1.MemoryCard({
        name: NAME,
        storageOptions,
    });
    await cardB.load();
    t.equal(await cardB.get(EXPECTED_KEY), EXPECTED_VAL, 'should get val back from obs');
    await card.destroy();
    await cardB.destroy();
});
(0, tstest_1.test)('save() throw exception before load()', async (t) => {
    const NAME = Math.random().toString().substr(2);
    const card = new memory_card_js_1.MemoryCard({
        name: NAME,
        storageOptions: {
            type: 'file',
        },
    });
    try {
        await card.save();
        t.fail('should not call save() success');
    }
    catch (e) {
        t.pass('should throw to call save() before load()');
    }
});
(0, tstest_1.test)('load() twice should throw error', async (t) => {
    const NAME = Math.random().toString().substr(2);
    const card = new memory_card_js_1.MemoryCard({
        name: NAME,
        storageOptions: {
            type: 'file',
        },
    });
    try {
        await card.load();
        await card.load();
        t.fail('should not call load() success after twice');
    }
    catch (e) {
        t.pass('should throw to call load() twice');
    }
});
(0, tstest_1.test)('instanciate MemoryCard with undefined options should get undefined name', async (t) => {
    const UNDEFIEND = undefined;
    const card = new memory_card_js_1.MemoryCard(UNDEFIEND);
    t.equal(card.name, UNDEFIEND, 'should get undefined as name');
});
//# sourceMappingURL=memory-card.spec.js.map