import * as PUPPET from 'wechaty-puppet';
import type { FileBoxInterface, FileBox } from 'file-box';
import { Duck as PuppetDuck } from 'wechaty-redux';
import { Ducks } from 'ducks';
import type { Store } from 'redux';
import { GrpcManager } from './grpc-manager.js';
import { PayloadStore } from './payload-store.js';
export declare type PuppetServiceOptions = PUPPET.PuppetOptions & {
    authority?: string;
    tls?: {
        caCert?: string;
        serverName?: string;
        /**
         * Huan(202108): only for compatible with old clients/servers
         *  for disabling TLS
         */
        disable?: boolean;
    };
};
declare class PuppetService extends PUPPET.Puppet {
    options: PuppetServiceOptions;
    static readonly VERSION: string;
    protected _cleanupCallbackList: (() => void)[];
    protected _payloadStore: PayloadStore;
    /**
     * Wechaty Redux
     */
    protected _ducks: Ducks<{
        puppet: typeof PuppetDuck;
    }>;
    protected _store: Store;
    protected _grpcManager?: GrpcManager;
    get grpcManager(): GrpcManager;
    /**
     * UUIDify:
     *  We need to clone a FileBox
     *  to set uuid loader/saver with this grpc client
     */
    protected FileBoxUuid: typeof FileBox;
    constructor(options?: PuppetServiceOptions);
    protected serializeFileBox(fileBox: FileBoxInterface): Promise<string>;
    name(): string;
    version(): string;
    onStart(): Promise<void>;
    onStop(): Promise<void>;
    protected hookPayloadStore(): void;
    protected bridgeGrpcEventStream(client: GrpcManager): void;
    private onGrpcStreamEvent;
    logout(reason?: string): Promise<void>;
    ding(data: string): void;
    /**
     *
     * Huan(202111) Issue #158 - Refactoring the 'dirty' event, dirtyPayload(),
     *  and XXXPayloadDirty() methods logic & spec
     *
     *    @see https://github.com/wechaty/puppet/issues/158
     *
     */
    dirtyPayload(type: PUPPET.types.Dirty, id: string): Promise<void>;
    /**
     * `onDirty()` is called when the puppet emit `dirty` event.
     *  the event listener will be registered in `start()` from the `PuppetAbstract` class
     */
    onDirty({ payloadType, payloadId, }: PUPPET.payloads.EventDirty): void;
    /**
     *
     * Contact
     *
     */
    contactAlias(contactId: string): Promise<string>;
    contactAlias(contactId: string, alias: string | null): Promise<void>;
    contactPhone(contactId: string, phoneList: string[]): Promise<void>;
    contactCorporationRemark(contactId: string, corporationRemark: string | null): Promise<void>;
    contactDescription(contactId: string, description: string | null): Promise<void>;
    contactList(): Promise<string[]>;
    contactAvatar(contactId: string): Promise<FileBoxInterface>;
    contactAvatar(contactId: string, file: FileBoxInterface): Promise<void>;
    contactRawPayload(id: string): Promise<PUPPET.payloads.Contact>;
    contactRawPayloadParser(payload: PUPPET.payloads.Contact): Promise<PUPPET.payloads.Contact>;
    contactSelfName(name: string): Promise<void>;
    contactSelfQRCode(): Promise<string>;
    contactSelfSignature(signature: string): Promise<void>;
    /**
     *
     * Conversation
     *
     */
    conversationReadMark(conversationId: string, hasRead?: boolean): Promise<void>;
    /**
     *
     * Message
     *
     */
    messageMiniProgram(messageId: string): Promise<PUPPET.payloads.MiniProgram>;
    messageLocation(messageId: string): Promise<PUPPET.payloads.Location>;
    messageImage(messageId: string, imageType: PUPPET.types.Image): Promise<FileBoxInterface>;
    messageContact(messageId: string): Promise<string>;
    messageSendMiniProgram(conversationId: string, miniProgramPayload: PUPPET.payloads.MiniProgram): Promise<void | string>;
    messageSendLocation(conversationId: string, locationPayload: PUPPET.payloads.Location): Promise<void | string>;
    messageRecall(messageId: string): Promise<boolean>;
    messageFile(id: string): Promise<FileBoxInterface>;
    messageForward(conversationId: string, messageId: string): Promise<string | void>;
    messageRawPayload(id: string): Promise<PUPPET.payloads.Message>;
    messageRawPayloadParser(payload: PUPPET.payloads.Message): Promise<PUPPET.payloads.Message>;
    messageSendText(conversationId: string, text: string, mentionIdList?: string[]): Promise<void | string>;
    messageSendFile(conversationId: string, fileBox: FileBoxInterface): Promise<void | string>;
    messageSendContact(conversationId: string, contactId: string): Promise<void | string>;
    messageSendUrl(conversationId: string, urlLinkPayload: PUPPET.payloads.UrlLink): Promise<void | string>;
    messageUrl(messageId: string): Promise<PUPPET.payloads.UrlLink>;
    /**
     *
     * Room
     *
     */
    roomRawPayload(id: string): Promise<PUPPET.payloads.Room>;
    roomRawPayloadParser(payload: PUPPET.payloads.Room): Promise<PUPPET.payloads.Room>;
    roomList(): Promise<string[]>;
    roomDel(roomId: string, contactId: string): Promise<void>;
    roomAvatar(roomId: string): Promise<FileBoxInterface>;
    roomAdd(roomId: string, contactId: string, inviteOnly: boolean): Promise<void>;
    roomTopic(roomId: string): Promise<string>;
    roomTopic(roomId: string, topic: string): Promise<void>;
    roomCreate(contactIdList: string[], topic: string): Promise<string>;
    roomQuit(roomId: string): Promise<void>;
    roomQRCode(roomId: string): Promise<string>;
    roomMemberList(roomId: string): Promise<string[]>;
    roomMemberRawPayload(roomId: string, contactId: string): Promise<PUPPET.payloads.RoomMember>;
    roomMemberRawPayloadParser(payload: PUPPET.payloads.RoomMember): Promise<PUPPET.payloads.RoomMember>;
    roomAnnounce(roomId: string): Promise<string>;
    roomAnnounce(roomId: string, text: string): Promise<void>;
    roomInvitationAccept(roomInvitationId: string): Promise<void>;
    roomInvitationRawPayload(id: string): Promise<PUPPET.payloads.RoomInvitation>;
    roomInvitationRawPayloadParser(payload: PUPPET.payloads.RoomInvitation): Promise<PUPPET.payloads.RoomInvitation>;
    /**
     *
     * Friendship
     *
     */
    friendshipSearchPhone(phone: string): Promise<string | null>;
    friendshipSearchHandle(handle: string): Promise<string | null>;
    friendshipRawPayload(id: string): Promise<PUPPET.payloads.Friendship>;
    friendshipRawPayloadParser(payload: PUPPET.payloads.Friendship): Promise<PUPPET.payloads.Friendship>;
    friendshipAdd(contactId: string, options: PUPPET.types.FriendshipAddOptions): Promise<void>;
    friendshipAccept(friendshipId: string): Promise<void>;
    /**
     *
     * Tag
     *
     */
    tagContactAdd(id: string, contactId: string): Promise<void>;
    tagContactRemove(id: string, contactId: string): Promise<void>;
    tagContactDelete(id: string): Promise<void>;
    tagContactList(contactId?: string): Promise<string[]>;
    /**
     * @deprecated Will be removed in v2.0
     */
    private messageSendFileStream;
}
export { PuppetService, };
export default PuppetService;
//# sourceMappingURL=puppet-service.d.ts.map