"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PayloadStore = void 0;
/**
 *   Wechaty Open Source Software - https://github.com/wechaty
 *
 *   @copyright 2016 Huan LI (李卓桓) <https://github.com/huan>, and
 *                   Wechaty Contributors <https://github.com/wechaty>.
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 */
const path_1 = __importDefault(require("path"));
const os_1 = __importDefault(require("os"));
const fs_1 = __importDefault(require("fs"));
const semver_1 = __importDefault(require("semver"));
const flash_store_1 = require("flash-store");
const config_js_1 = require("../config.js");
const { major, minor } = semver_1.default;
class PayloadStore {
    options;
    // public message?    : LRU<string, MessagePayload>
    contact;
    roomMember;
    room;
    storeDir;
    accountId;
    constructor(options) {
        this.options = options;
        config_js_1.log.verbose('PayloadStore', 'constructor(%s)', JSON.stringify(options));
        this.storeDir = path_1.default.join(os_1.default.homedir(), '.wechaty', 'wechaty-puppet-service', this.options.token, `v${major(config_js_1.VERSION)}.${minor(config_js_1.VERSION)}`);
        config_js_1.log.silly('PayloadStore', 'constructor() storeDir: "%s"', this.storeDir);
    }
    /**
     * When starting the store, we need to know the accountId
     *  so that we can save the payloads under a specific account folder.
     */
    async start(accountId) {
        config_js_1.log.verbose('PayloadStore', 'start(%s)', accountId);
        if (this.accountId) {
            throw new Error('PayloadStore should be stop() before start() again.');
        }
        this.accountId = accountId;
        const accountDir = path_1.default.join(this.storeDir, accountId);
        if (!fs_1.default.existsSync(accountDir)) {
            fs_1.default.mkdirSync(accountDir, { recursive: true });
        }
        this.contact = new flash_store_1.FlashStore(path_1.default.join(accountDir, 'contact-payload'));
        this.roomMember = new flash_store_1.FlashStore(path_1.default.join(accountDir, 'room-member-payload'));
        this.room = new flash_store_1.FlashStore(path_1.default.join(accountDir, 'room-payload'));
        /**
         * LRU
         *
         * Huan(202108): the Wechaty Puppet has LRU cache already,
         *  there's no need to do it again.
         *
         * We can focus on providing a persistent store for the performance.
         */
        // const lruOptions: LRU.Options<string, MessagePayload> = {
        //   dispose (key, val) {
        //     log.silly('PayloadStore', `constructor() lruOptions.dispose(${key}, ${JSON.stringify(val)})`)
        //   },
        //   max    : 1000,  // 1000 messages
        //   maxAge : 60 * 60 * 1000,  // 1 hour
        // }
        // this.message = new LRU(lruOptions)
    }
    async stop() {
        config_js_1.log.verbose('PayloadStore', 'stop()');
        const contactStore = this.contact;
        const roomMemberStore = this.roomMember;
        const roomStore = this.room;
        /**
          * Huan(202108): we must set all the instances of the store to underfined
          *   in the current event loop as soon as possible
          *   to prevent the future store calls.
          */
        this.contact = undefined;
        this.roomMember = undefined;
        this.room = undefined;
        // LRU
        // this.message    = undefined
        // clear accountId
        this.accountId = undefined;
        await contactStore?.close();
        await roomMemberStore?.close();
        await roomStore?.close();
    }
    async destroy() {
        config_js_1.log.verbose('PayloadStore', 'destroy()');
        if (this.accountId) {
            throw new Error('Can not destroy() a start()-ed store. Call stop() to stop it first');
        }
        /**
         * Huan(202108): `fs.rm` was introduced from Node.js v14.14
         *  https://nodejs.org/api/fs.html#fs_fspromises_rm_path_options
         */
        await fs_1.default.promises.rmdir(this.storeDir, {
            // force: true,
            recursive: true,
        });
    }
}
exports.PayloadStore = PayloadStore;
//# sourceMappingURL=payload-store.js.map