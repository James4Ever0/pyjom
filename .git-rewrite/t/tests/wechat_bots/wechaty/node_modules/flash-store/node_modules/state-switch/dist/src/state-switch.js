var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
/**
 *
 * StateSwitch for easy managing the states with async programming
 *
 * Class StateSwitch
 * Licenst: Apache-2.0
 * https://github.com/huan/state-switch
 *
 * Helper Class for Manage State Change
 */
import { EventEmitter } from 'events';
import NOP from 'nop';
import { VERSION } from './version';
let COUNTER = 0;
export class StateSwitch extends EventEmitter {
    constructor(name = `#${COUNTER++}`, options = {}) {
        super();
        this.name = name;
        this.options = options;
        if (options.log) {
            this.setLog(options.log);
        }
        else {
            this.setLog(null);
        }
        this.log.verbose('StateSwitch', 'constructor(%s, "%s")', name, JSON.stringify(options));
        this._onoff = false;
        this._pending = false;
        /**
         * for ready()
         */
        this.offPromise = Promise.resolve();
        this.onPromise = new Promise(resolve => {
            this.onResolver = resolve;
        });
        this.offResolver = NOP;
    }
    /**
     * does the state is not stable(in process)?
     */
    get pending() {
        this.log.silly('StateSwitch', '<%s> pending() is %s', this.name, this._pending);
        return this._pending;
    }
    version() {
        return VERSION;
    }
    setLog(logInstance) {
        if (logInstance) {
            this.log = logInstance;
        }
        else {
            /* eslint @typescript-eslint/no-unused-vars: off */
            this.log = {
                error: NOP,
                silly: NOP,
                verbose: NOP,
                warn: NOP,
            };
        }
    }
    on(state) {
        /**
         * Set
         */
        if (state) {
            this.log.verbose('StateSwitch', '<%s> on(%s) <- (%s)', this.name, state, this.on());
            this._onoff = true;
            this._pending = (state === 'pending');
            this.emit('on', state);
            /**
              * for ready()
              */
            if (this.offResolver === NOP) {
                this.offPromise = new Promise(resolve => (this.offResolver = resolve));
            }
            if (state === true && this.onResolver !== NOP) {
                this.onResolver();
                this.onResolver = NOP;
            }
            return;
        }
        /**
         * Get
         */
        const on = this._onoff
            ? this._pending
                ? 'pending'
                : true
            : false;
        this.log.silly('StateSwitch', '<%s> on() is %s', this.name, on);
        return on;
    }
    off(state) {
        /**
         * Set
         */
        if (state) {
            this.log.verbose('StateSwitch', '<%s> off(%s) <- (%s)', this.name, state, this.off());
            this._onoff = false;
            this._pending = (state === 'pending');
            this.emit('off', state);
            /**
              * for ready()
              */
            if (this.onResolver === NOP) {
                this.onPromise = new Promise(resolve => (this.onResolver = resolve));
            }
            if (state === true && this.offResolver !== NOP) {
                this.offResolver();
                this.offResolver = NOP;
            }
            return;
        }
        /**
         * Get
         */
        const off = !this._onoff
            ? this._pending ? 'pending' : true
            : false;
        this.log.silly('StateSwitch', '<%s> off() is %s', this.name, off);
        return off;
    }
    ready(state = 'on', noCross = false) {
        return __awaiter(this, void 0, void 0, function* () {
            this.log.verbose('StateSwitch', '<%s> ready(%s, noCross=%s)', this.name, state, noCross);
            if (state === 'on') {
                if (this._onoff === false && noCross === true) {
                    throw new Error('ready(on) but the state is off. call ready(on, false) to disable noCross');
                }
                yield this.onPromise;
            }
            else if (state === 'off') {
                if (this._onoff === true && noCross === true) {
                    throw new Error('ready(off) but the state is on. call ready(off, false) to disable noCross');
                }
                yield this.offPromise;
            }
            else {
                throw new Error(`should not go here. ${state} should be of type 'never'`);
            }
            this.log.silly('StateSwitch', '<%s> ready(%s, %s) resolved.', this.name, state, noCross);
        });
    }
    /**
     * Huan(202105): To make RxJS fromEvent happy: type inferencing
     *  https://github.com/ReactiveX/rxjs/blob/92fbdda7c06561bc73dae3c14de3fc7aff92bbd4/src/internal/observable/fromEvent.ts#L39-L50
     */
    addEventListener(event, listener) {
        if (listener) {
            super.addListener(event, listener);
        }
    }
    removeEventListener(event, listener) {
        if (listener) {
            super.removeListener(event, listener);
        }
    }
}
//# sourceMappingURL=state-switch.js.map