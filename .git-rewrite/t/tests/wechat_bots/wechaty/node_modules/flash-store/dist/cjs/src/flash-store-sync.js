"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.FlashStoreSync = void 0;
const cuid_1 = __importDefault(require("cuid"));
const state_switch_1 = require("state-switch");
const config_js_1 = require("./config.js");
const flash_store_js_1 = require("./flash-store.js");
class FlashStoreSync {
    constructor(workdir) {
        this.workdir = workdir;
        config_js_1.log.verbose('CacheStore', 'constructor(%s)', workdir);
        workdir = workdir || '.flash-store-sync';
        this.asyncBusyDict = {};
        this.asyncBusyState = new state_switch_1.StateSwitch('Busy:' + workdir.split('/').pop(), // get the latest folder name
        { log: config_js_1.log });
        this.cacheMap = new Map();
        this.flashStore = new flash_store_js_1.FlashStore(workdir);
        this.asyncBusyAdd(this.loadStoreToCache());
    }
    async loadStoreToCache() {
        this.cacheMap.clear();
        for await (const [key, val] of this.flashStore) {
            this.cacheMap.set(key, val);
        }
    }
    asyncBusyAdd(task) {
        this.asyncBusyState.on(true);
        const id = (0, cuid_1.default)();
        this.asyncBusyDict[id] = task.finally(() => {
            delete this.asyncBusyDict[id];
            if (Object.keys(this.asyncBusyDict).length <= 0) {
                this.asyncBusyState.off(true);
            }
        });
    }
    version() {
        return this.flashStore.version();
    }
    /**
     *
     * Async methods:
     *
     */
    async close() {
        await this.ready();
        await this.flashStore.close();
    }
    async destroy() {
        // this.clear()
        // add destroy task at the end of the event loop
        this.asyncBusyState.ready('off')
            .then(() => this.flashStore.destroy()).catch(console.error);
    }
    async ready() {
        await this.asyncBusyState.ready('off');
    }
    /*******************************************************
     *
     *
     * The following methods is all for ES6 Map Interface
     *
     *
     *******************************************************/
    get size() {
        return this.cacheMap.size;
    }
    get [Symbol.toStringTag]() {
        return 'FlashStoreSync';
    }
    [Symbol.iterator]() {
        return this.cacheMap[Symbol.iterator]();
    }
    entries() {
        return this.cacheMap.entries();
    }
    keys() {
        return this.cacheMap.keys();
    }
    values() {
        return this.cacheMap.values();
    }
    clear() {
        this.asyncBusyAdd(this.flashStore.clear());
        return this.cacheMap.clear();
    }
    delete(key) {
        this.asyncBusyAdd(this.flashStore.delete(key));
        return this.cacheMap.delete(key);
    }
    /**
     * Do not mutate the key/value in the forEach loop!
     */
    forEach(callbackfn, thisArg) {
        /**
         * 1. no need to call flashStore
         * 2. callbackfn should not mutate the data, or the data will be lost sync between cache & store
         */
        return this.cacheMap.forEach(callbackfn, thisArg);
    }
    get(key) {
        return this.cacheMap.get(key);
    }
    has(key) {
        return this.cacheMap.has(key);
    }
    set(key, value) {
        this.asyncBusyAdd(this.flashStore.set(key, value));
        this.cacheMap.set(key, value);
        return this;
    }
}
exports.FlashStoreSync = FlashStoreSync;
FlashStoreSync.VERSION = flash_store_js_1.FlashStore.VERSION;
exports.default = FlashStoreSync;
//# sourceMappingURL=flash-store-sync.js.map