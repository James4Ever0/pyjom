import { From, OutputOf, InputOf, FromFn } from './from';
import { Descriptive, Displayed } from './helpdoc';
import { Default } from './default';
export { identity, OutputOf, InputOf } from './from';
export declare type Type<From_, To> = From<From_, To> & Partial<Descriptive & Displayed & Default<To>>;
/**
 * Get the type definitions or an empty object from a type or a decoding function
 */
export declare function typeDef<T extends From<any, any> | FromFn<any, any>>(from: T): T extends FromFn<any, any> ? {} : Omit<T, 'from'>;
/**
 * Get the decoding function from a type or a function
 */
export declare function fromFn<A, B>(t: FromFn<A, B> | From<A, B>): FromFn<A, B>;
/**
 * Extend a type: take a type and use it as a base for another type. Much like using the spread operator:
 * ```
 * const newType = { ...oldType }
 * ```
 * but composes the `from` arguments
 *
 * @param base A base type from `InputA` to `OutputA`
 * @param nextTypeOrDecodingFunction Either an entire `Type<OutputA, AnyOutput>` or just a decoding function from `OutputA` to any type
 */
export declare function extendType<BaseType extends Type<any, any>, NextType extends Type<OutputOf<BaseType>, any> | FromFn<OutputOf<BaseType>, any>>(base: BaseType, nextTypeOrDecodingFunction: NextType): Omit<BaseType, 'from' | 'defaultValue'> & (NextType extends FromFn<any, any> ? unknown : Omit<NextType, 'from'>) & From<InputOf<BaseType>, OutputOf<NextType>>;
/** Contains a type definition inside */
export declare type HasType<T extends Type<any, any>> = {
    /** The value decoding strategy for this item */
    type: T;
};
