{"version":3,"sources":["asynciterable/todomstream.ts"],"names":[],"mappings":"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","file":"todomstream.js","sourcesContent":["import { publish } from './operators/publish';\nimport { fromDOMStream } from './fromdomstream';\nimport { AsyncIterableX } from './asynciterablex';\n\nexport type ReadableBYOBStreamOptions<T = any> = QueuingStrategy<T> & { type: 'bytes' };\nexport type ReadableByteStreamOptions<T = any> = QueuingStrategy<T> & {\n  type: 'bytes';\n  autoAllocateChunkSize?: number;\n};\n\ntype AsyncSourceIterator<TSource> = AsyncIterator<\n  TSource,\n  any,\n  number | ArrayBufferView | undefined | null\n>;\n\n/** @ignore */\nfunction memcpy<TTarget extends ArrayBufferView, TSource extends ArrayBufferView>(\n  target: TTarget,\n  source: TSource,\n  targetByteOffset = 0,\n  sourceByteLength = source.byteLength\n) {\n  const targetByteLength = target.byteLength;\n  const dst = new Uint8Array(target.buffer, target.byteOffset, targetByteLength);\n  const src = new Uint8Array(\n    source.buffer,\n    source.byteOffset,\n    Math.min(sourceByteLength, targetByteLength, source.buffer.byteLength - source.byteOffset)\n  );\n  dst.set(src, targetByteOffset);\n  return src.byteLength;\n}\n\nabstract class AbstractUnderlyingSource<TSource> {\n  constructor(protected _source: AsyncSourceIterator<TSource> | null) {}\n  async cancel() {\n    const source = this._source;\n    if (source && source.return) {\n      await source.return();\n    }\n    this._source = null;\n  }\n}\n\nclass UnderlyingAsyncIterableDefaultSource<TSource = any> extends AbstractUnderlyingSource<TSource>\n  implements UnderlyingSource<TSource> {\n  constructor(source: AsyncSourceIterator<TSource> | null) {\n    super(source);\n  }\n  // eslint-disable-next-line consistent-return\n  async pull(controller: ReadableStreamDefaultController<TSource>) {\n    const source = this._source;\n    if (source) {\n      const r = await source.next(controller.desiredSize);\n      if (!r.done) {\n        return controller.enqueue(r.value);\n      }\n    }\n    controller.close();\n  }\n}\n\nclass UnderlyingAsyncIterableByteSource<TSource extends ArrayBufferView = Uint8Array>\n  extends AbstractUnderlyingSource<TSource>\n  implements UnderlyingSource<TSource> {\n  //   public readonly type: 'bytes';\n  public readonly autoAllocateChunkSize?: number;\n\n  // If we can't create a \"byob\" reader (no browsers currently suppor it),\n  // fallback to pulling values from the source iterator and enqueueing like\n  // object streams\n  private fallbackDefaultSource: UnderlyingAsyncIterableDefaultSource<TSource>;\n\n  constructor(\n    reader: AsyncSourceIterator<TSource> | null,\n    opts: { autoAllocateChunkSize?: number } = {}\n  ) {\n    super(reader);\n    (this as any).type = 'bytes';\n    this.autoAllocateChunkSize = opts['autoAllocateChunkSize'];\n    this.fallbackDefaultSource = new UnderlyingAsyncIterableDefaultSource<TSource>(reader);\n  }\n\n  // eslint-disable-next-line consistent-return\n  async pull(controller: ReadableStreamController<TSource>) {\n    if (!(controller as any).byobRequest) {\n      return await this.fallbackDefaultSource.pull(controller);\n    }\n    if (this._source) {\n      const { view } = (controller as any).byobRequest;\n      const { done, value } = await this._source.next(view);\n      if (!done) {\n        // Did the source write into the BYOB view itself,\n        // then yield us the `bytesWritten` value? If so,\n        // pass that along\n        if (typeof value === 'number') {\n          return (controller as any).byobRequest.respond(value);\n        }\n        // otherwise if the source is only producing buffers\n        // but doesn't expect to be given one, we should copy\n        // the produced buffer into the front of the BYOB view\n        if (ArrayBuffer.isView(value)) {\n          return value.buffer === view.buffer\n            ? (controller as any).byobRequest.respondWithNewView(value)\n            : (controller as any).byobRequest.respond(memcpy(view, value));\n        }\n      }\n    }\n    controller.close();\n  }\n}\n\n// Generate subclasses of ReadableStream that conform to the\n// AsyncIterable protocol. These classes are dynamically created\n// the first time a ReadableStream is produced because ReadableStream\n// is a browser-only API, and closure-compiler won't compile if they're\n// statically defined at the module scope.\n/** @ignore */\nconst asyncIterableReadableStream = (() => {\n  let AsyncIterableReadableByteStream_: any;\n  let AsyncIterableDefaultReadableStream_: any;\n\n  // A function that's called the first time someone creates a\n  // ReadableStream via `toDOMStream()`\n  const createFirstTime = <T>(source: any, opts?: any) => {\n    // Generate the subclasses with [Symbol.asyncIterator]() methods\n    class AsyncIterableDefaultReadableStream extends ReadableStream<T> {\n      [Symbol.asyncIterator]() {\n        return fromDOMStream(this)[Symbol.asyncIterator]();\n      }\n    }\n    class AsyncIterableReadableByteStream extends ReadableStream<Uint8Array> {\n      [Symbol.asyncIterator]() {\n        return fromDOMStream(this, { mode: 'byob' })[Symbol.asyncIterator]();\n      }\n    }\n    AsyncIterableReadableByteStream_ = AsyncIterableReadableByteStream;\n    AsyncIterableDefaultReadableStream_ = AsyncIterableDefaultReadableStream;\n    // Now point `createAsyncIterableReadableStream` to the function that\n    // instantiates the classes we just created\n\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define, no-use-before-define\n    createAsyncIterableReadableStream = createAsyncIterableReadableStreamEveryOtherTime;\n    // Create and return the first ReadableStream<T> instance\n\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define, no-use-before-define\n    return createAsyncIterableReadableStreamEveryOtherTime<T>(source, opts) as ReadableStream<T>;\n  };\n\n  // Shared function pointer that's called by the wrapper closure we return\n  let createAsyncIterableReadableStream = createFirstTime;\n  // Create instances of the classes generated by `createFirstTime`\n  const createAsyncIterableReadableStreamEveryOtherTime = <T>(source: any, opts?: any) => {\n    return source instanceof UnderlyingAsyncIterableByteSource\n      ? (new AsyncIterableReadableByteStream_(source, opts) as ReadableStream<T>)\n      : (new AsyncIterableDefaultReadableStream_(source, opts) as ReadableStream<T>);\n  };\n\n  return <T>(source: any, opts?: any) => createAsyncIterableReadableStream<T>(source, opts);\n})();\n\n/**\n * Converts an async-iterable instance to a DOM stream.\n * @param source The source async-iterable to convert to a DOM stream.\n * @param strategy The queueing strategy to apply to the DOM stream.\n */\nexport function toDOMStream<T>(\n  source: AsyncIterable<T>,\n  strategy?: QueuingStrategy<T>\n): ReadableStream<T>;\n/**\n * Converts an async-iterable stream to a DOM stream.\n * @param source The async-iterable stream to convert to a DOM stream.\n * @param options The ReadableBYOBStreamOptions to apply to the DOM stream.\n */\nexport function toDOMStream<T>(\n  source: AsyncIterable<T>,\n  options: ReadableBYOBStreamOptions<Uint8Array>\n): ReadableStream<Uint8Array>;\n/**\n * Converts an async-iterable stream to a DOM stream.\n * @param source The async-iterable stream to convert to a DOM stream.\n * @param options The ReadableByteStreamOptions to apply to the DOM stream.\n */\nexport function toDOMStream<T>(\n  source: AsyncIterable<T>,\n  options: ReadableByteStreamOptions<Uint8Array>\n): ReadableStream<Uint8Array>;\n/**\n * Converts an async-iterable stream to a DOM stream.\n * @param source The async-iterable stream to convert to a DOM stream.\n * @param options The options to apply to the DOM stream.\n */\nexport function toDOMStream(\n  source: AsyncIterable<any>,\n  options?: QueuingStrategy<any> | ReadableBYOBStreamOptions | ReadableByteStreamOptions\n) {\n  if (!options || !('type' in options) || options['type'] !== 'bytes') {\n    return asyncIterableReadableStream(\n      new UnderlyingAsyncIterableDefaultSource(source[Symbol.asyncIterator]()),\n      options\n    );\n  }\n  return asyncIterableReadableStream(\n    new UnderlyingAsyncIterableByteSource(\n      source[Symbol.asyncIterator](),\n      options as ReadableByteStreamOptions\n    ),\n    options\n  );\n}\n\nAsyncIterableX.prototype.tee = function <T>(this: AsyncIterableX<T>) {\n  return _getDOMStream(this).tee();\n};\n\nAsyncIterableX.prototype.pipeTo = function <T>(\n  this: AsyncIterableX<T>,\n  writable: WritableStream<T>,\n  options?: StreamPipeOptions\n) {\n  return _getDOMStream(this).pipeTo(writable, options);\n};\n\nAsyncIterableX.prototype.pipeThrough = function <T, R extends ReadableStream<any>>(\n  this: AsyncIterableX<T>,\n  duplex: { writable: WritableStream<T>; readable: R },\n  options?: StreamPipeOptions\n) {\n  return _getDOMStream(this).pipeThrough(duplex, options);\n};\n\nfunction _getDOMStream<T>(self: any) {\n  return self._DOMStream || (self._DOMStream = self.pipe(publish<T>(), toDOMStream));\n}\n\n/**\n * @ignore\n */\nexport function toDOMStreamProto<T>(\n  this: AsyncIterable<T>,\n  strategy?: QueuingStrategy<T>\n): ReadableStream<T>;\nexport function toDOMStreamProto<T>(\n  this: AsyncIterable<T>,\n  options: ReadableBYOBStreamOptions<Uint8Array>\n): ReadableStream<Uint8Array>;\nexport function toDOMStreamProto<T>(\n  this: AsyncIterable<T>,\n  options: ReadableByteStreamOptions<Uint8Array>\n): ReadableStream<Uint8Array>;\nexport function toDOMStreamProto(\n  this: AsyncIterable<any>,\n  options?: QueuingStrategy<any> | ReadableBYOBStreamOptions | ReadableByteStreamOptions\n) {\n  return !options ? toDOMStream(this) : toDOMStream(this, options);\n}\n\nAsyncIterableX.prototype.toDOMStream = toDOMStreamProto;\n\ndeclare module '../asynciterable/asynciterablex' {\n  interface AsyncIterableX<T> {\n    toDOMStream: typeof toDOMStreamProto;\n    tee(): [ReadableStream<T>, ReadableStream<T>];\n    pipeTo(writable: WritableStream<T>, options?: StreamPipeOptions): Promise<void>;\n    pipeThrough<R extends ReadableStream<any>>(\n      duplex: { writable: WritableStream<T>; readable: R },\n      options?: StreamPipeOptions\n    ): R;\n  }\n}\n"]}