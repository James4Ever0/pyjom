{"version":3,"sources":["asynciterable/generatetime.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,cAAc,EAAE,MAAM,kBAAkB,CAAC;AAClD,OAAO,EAAE,KAAK,EAAE,MAAM,UAAU,CAAC;AACjC,OAAO,EAAE,cAAc,EAAE,MAAM,eAAe,CAAC;AAE/C,MAAM,yBAA2C,SAAQ,cAAuB;IACtE,aAAa,CAAS;IACtB,UAAU,CAAsE;IAChF,QAAQ,CAAoE;IAC5E,eAAe,CAAsE;IACrF,aAAa,CAAoE;IAEzF,YACE,YAAoB,EACpB,SAA8E,EAC9E,OAA0E,EAC1E,cAAmF,EACnF,YAA+E;QAE/E,KAAK,EAAE,CAAC;QACR,IAAI,CAAC,aAAa,GAAG,YAAY,CAAC;QAClC,IAAI,CAAC,UAAU,GAAG,SAAS,CAAC;QAC5B,IAAI,CAAC,QAAQ,GAAG,OAAO,CAAC;QACxB,IAAI,CAAC,eAAe,GAAG,cAAc,CAAC;QACtC,IAAI,CAAC,aAAa,GAAG,YAAY,CAAC;IACpC,CAAC;IAED,KAAK,CAAC,CAAC,CAAC,MAAM,CAAC,aAAa,CAAC,CAAC,MAAoB;QAChD,cAAc,CAAC,MAAM,CAAC,CAAC;QACvB,KACE,IAAI,CAAC,GAAG,IAAI,CAAC,aAAa,EAC1B,MAAM,IAAI,CAAC,UAAU,CAAC,CAAC,EAAE,MAAM,CAAC,EAChC,CAAC,GAAG,MAAM,IAAI,CAAC,QAAQ,CAAC,CAAC,EAAE,MAAM,CAAC,EAClC;YACA,MAAM,IAAI,GAAG,MAAM,IAAI,CAAC,aAAa,CAAC,CAAC,EAAE,MAAM,CAAC,CAAC;YACjD,MAAM,KAAK,CAAC,IAAI,EAAE,MAAM,CAAC,CAAC;YAC1B,MAAM,MAAM,IAAI,CAAC,eAAe,CAAC,CAAC,EAAE,MAAM,CAAC,CAAC;SAC7C;IACH,CAAC;CACF;AAED;;;;;;;;;;;;GAYG;AACH,MAAM,UAAU,YAAY,CAC1B,YAAoB,EACpB,SAA8E,EAC9E,OAA0E,EAC1E,cAAmF,EACnF,YAA+E;IAE/E,OAAO,IAAI,yBAAyB,CAClC,YAAY,EACZ,SAAS,EACT,OAAO,EACP,cAAc,EACd,YAAY,CACb,CAAC;AACJ,CAAC","file":"generatetime.js","sourcesContent":["import { AsyncIterableX } from './asynciterablex';\nimport { sleep } from './_sleep';\nimport { throwIfAborted } from '../aborterror';\n\nclass GenerateTimeAsyncIterable<TState, TResult> extends AsyncIterableX<TResult> {\n  private _initialState: TState;\n  private _condition: (value: TState, signal?: AbortSignal) => boolean | Promise<boolean>;\n  private _iterate: (value: TState, signal?: AbortSignal) => TState | Promise<TState>;\n  private _resultSelector: (value: TState, signal?: AbortSignal) => TResult | Promise<TResult>;\n  private _timeSelector: (value: TState, signal?: AbortSignal) => number | Promise<number>;\n\n  constructor(\n    initialState: TState,\n    condition: (value: TState, signal?: AbortSignal) => boolean | Promise<boolean>,\n    iterate: (value: TState, signal?: AbortSignal) => TState | Promise<TState>,\n    resultSelector: (value: TState, signal?: AbortSignal) => TResult | Promise<TResult>,\n    timeSelector: (value: TState, signal?: AbortSignal) => number | Promise<number>\n  ) {\n    super();\n    this._initialState = initialState;\n    this._condition = condition;\n    this._iterate = iterate;\n    this._resultSelector = resultSelector;\n    this._timeSelector = timeSelector;\n  }\n\n  async *[Symbol.asyncIterator](signal?: AbortSignal) {\n    throwIfAborted(signal);\n    for (\n      let i = this._initialState;\n      await this._condition(i, signal);\n      i = await this._iterate(i, signal)\n    ) {\n      const time = await this._timeSelector(i, signal);\n      await sleep(time, signal);\n      yield await this._resultSelector(i, signal);\n    }\n  }\n}\n\n/**\n * Generates an async-iterable sequence by running a time-based state-driven loop producing the sequence's elements.\n *\n * @template TState The type of the state used in the generator loop.\n * @template TResult The type of the elements in the produced sequence.\n * @param {TState} initialState The initial state.\n * @param {((value: TState, signal?: AbortSignal) => boolean | Promise<boolean>)} condition Condition to terminate generation (upon returning false).\n * @param {((value: TState, signal?: AbortSignal) => TState | Promise<TState>)} iterate Iteration step function.\n * @param {((value: TState, signal?: AbortSignal) => TResult | Promise<TResult>)} resultSelector Selector function for results produced in\n * the sequence.\n * @param {((value: TState, signal?: AbortSignal) => number | Promise<number>)} timeSelector Selector function for how much time to wait.\n * @returns {AsyncIterableX<TResult>} The generated async-iterable sequence.\n */\nexport function generateTime<TState, TResult>(\n  initialState: TState,\n  condition: (value: TState, signal?: AbortSignal) => boolean | Promise<boolean>,\n  iterate: (value: TState, signal?: AbortSignal) => TState | Promise<TState>,\n  resultSelector: (value: TState, signal?: AbortSignal) => TResult | Promise<TResult>,\n  timeSelector: (value: TState, signal?: AbortSignal) => number | Promise<number>\n): AsyncIterableX<TResult> {\n  return new GenerateTimeAsyncIterable<TState, TResult>(\n    initialState,\n    condition,\n    iterate,\n    resultSelector,\n    timeSelector\n  );\n}\n"]}