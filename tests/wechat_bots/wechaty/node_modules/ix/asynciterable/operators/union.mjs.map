{"version":3,"sources":["asynciterable/operators/union.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,cAAc,EAAE,MAAM,mBAAmB,CAAC;AACnD,OAAO,EAAE,iBAAiB,EAAE,MAAM,yBAAyB,CAAC;AAC5D,OAAO,EAAE,aAAa,EAAE,MAAM,qBAAqB,CAAC;AAEpD,OAAO,EAAE,aAAa,EAAE,MAAM,aAAa,CAAC;AAC5C,OAAO,EAAE,cAAc,EAAE,MAAM,kBAAkB,CAAC;AAElD,MAAM,OAAO,kBAA4B,SAAQ,cAAuB;IAC9D,KAAK,CAAyB;IAC9B,MAAM,CAAyB;IAC/B,SAAS,CAAyD;IAE1E,YACE,IAA4B,EAC5B,KAA6B,EAC7B,QAAgE;QAEhE,KAAK,EAAE,CAAC;QACR,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC;QAClB,IAAI,CAAC,MAAM,GAAG,KAAK,CAAC;QACpB,IAAI,CAAC,SAAS,GAAG,QAAQ,CAAC;IAC5B,CAAC;IAED,KAAK,CAAC,CAAC,CAAC,MAAM,CAAC,aAAa,CAAC,CAAC,MAAoB;QAChD,cAAc,CAAC,MAAM,CAAC,CAAC;QACvB,MAAM,GAAG,GAAG,EAAe,CAAC;QAC5B,IAAI,KAAK,EAAE,MAAM,KAAK,IAAI,aAAa,CAAC,IAAI,CAAC,KAAK,EAAE,MAAM,CAAC,EAAE;YAC3D,IAAI,CAAC,MAAM,iBAAiB,CAAC,GAAG,EAAE,KAAK,EAAE,IAAI,CAAC,SAAS,CAAC,CAAC,KAAK,CAAC,CAAC,EAAE;gBAChE,GAAG,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;gBAChB,MAAM,KAAK,CAAC;aACb;SACF;QAED,IAAI,KAAK,EAAE,MAAM,KAAK,IAAI,aAAa,CAAC,IAAI,CAAC,MAAM,EAAE,MAAM,CAAC,EAAE;YAC5D,IAAI,CAAC,MAAM,iBAAiB,CAAC,GAAG,EAAE,KAAK,EAAE,IAAI,CAAC,SAAS,CAAC,CAAC,KAAK,CAAC,CAAC,EAAE;gBAChE,GAAG,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;gBAChB,MAAM,KAAK,CAAC;aACb;SACF;IACH,CAAC;CACF;AAED;;;;;;;;GAQG;AACH,MAAM,UAAU,KAAK,CACnB,KAA6B,EAC7B,WAAmE,aAAa;IAEhF,OAAO,SAAS,qBAAqB,CAAC,IAA4B;QAChE,OAAO,IAAI,kBAAkB,CAAU,IAAI,EAAE,KAAK,EAAE,QAAQ,CAAC,CAAC;IAChE,CAAC,CAAC;AACJ,CAAC","file":"union.js","sourcesContent":["import { AsyncIterableX } from '../asynciterablex';\nimport { arrayIndexOfAsync } from '../../util/arrayindexof';\nimport { comparerAsync } from '../../util/comparer';\nimport { MonoTypeOperatorAsyncFunction } from '../../interfaces';\nimport { wrapWithAbort } from './withabort';\nimport { throwIfAborted } from '../../aborterror';\n\nexport class UnionAsyncIterable<TSource> extends AsyncIterableX<TSource> {\n  private _left: AsyncIterable<TSource>;\n  private _right: AsyncIterable<TSource>;\n  private _comparer: (x: TSource, y: TSource) => boolean | Promise<boolean>;\n\n  constructor(\n    left: AsyncIterable<TSource>,\n    right: AsyncIterable<TSource>,\n    comparer: (x: TSource, y: TSource) => boolean | Promise<boolean>\n  ) {\n    super();\n    this._left = left;\n    this._right = right;\n    this._comparer = comparer;\n  }\n\n  async *[Symbol.asyncIterator](signal?: AbortSignal) {\n    throwIfAborted(signal);\n    const map = [] as TSource[];\n    for await (const lItem of wrapWithAbort(this._left, signal)) {\n      if ((await arrayIndexOfAsync(map, lItem, this._comparer)) === -1) {\n        map.push(lItem);\n        yield lItem;\n      }\n    }\n\n    for await (const rItem of wrapWithAbort(this._right, signal)) {\n      if ((await arrayIndexOfAsync(map, rItem, this._comparer)) === -1) {\n        map.push(rItem);\n        yield rItem;\n      }\n    }\n  }\n}\n\n/**\n * Produces the set union of two sequences by using the given equality comparer.\n *\n * @template TSource The type of the elements of the input sequences.\n * @param {AsyncIterable<TSource>} right An async-iterable sequence whose distinct elements form the second set for the union.\n * @param {((x: TSource, y: TSource) => boolean | Promise<boolean>)} [comparer=comparerAsync] The equality comparer to compare values.\n * @returns {MonoTypeOperatorAsyncFunction<TSource>} An async-iterable sequence that contains the elements from both input sequences,\n * excluding duplicates.\n */\nexport function union<TSource>(\n  right: AsyncIterable<TSource>,\n  comparer: (x: TSource, y: TSource) => boolean | Promise<boolean> = comparerAsync\n): MonoTypeOperatorAsyncFunction<TSource> {\n  return function unionOperatorFunction(left: AsyncIterable<TSource>): AsyncIterableX<TSource> {\n    return new UnionAsyncIterable<TSource>(left, right, comparer);\n  };\n}\n"]}