{"version":3,"sources":["asynciterable/operators/skipuntil.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,cAAc,EAAE,MAAM,mBAAmB,CAAC;AAEnD,OAAO,EAAE,aAAa,EAAE,MAAM,aAAa,CAAC;AAC5C,OAAO,EAAE,cAAc,EAAE,MAAM,kBAAkB,CAAC;AAElD,MAAM,OAAO,sBAAgC,SAAQ,cAAuB;IAClE,OAAO,CAAyB;IAChC,MAAM,CAAyC;IAEvD,YAAY,MAA8B,EAAE,KAA6C;QACvF,KAAK,EAAE,CAAC;QACR,IAAI,CAAC,OAAO,GAAG,MAAM,CAAC;QACtB,IAAI,CAAC,MAAM,GAAG,KAAK,CAAC;IACtB,CAAC;IAED,KAAK,CAAC,CAAC,CAAC,MAAM,CAAC,aAAa,CAAC,CAAC,MAAoB;QAChD,cAAc,CAAC,MAAM,CAAC,CAAC;QACvB,IAAI,SAAS,GAAG,KAAK,CAAC;QACtB,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC,IAAI,CAAC,GAAG,EAAE,CAAC,CAAC,SAAS,GAAG,IAAI,CAAC,CAAC,CAAC;QACnD,IAAI,KAAK,EAAE,MAAM,IAAI,IAAI,aAAa,CAAC,IAAI,CAAC,OAAO,EAAE,MAAM,CAAC,EAAE;YAC5D,IAAI,SAAS,EAAE;gBACb,MAAM,IAAI,CAAC;aACZ;SACF;IACH,CAAC;CACF;AAED;;;;;;;;GAQG;AACH,MAAM,UAAU,SAAS,CACvB,KAA6C;IAE7C,OAAO,SAAS,yBAAyB,CACvC,MAA8B;QAE9B,OAAO,IAAI,sBAAsB,CAAU,MAAM,EAAE,KAAK,CAAC,CAAC;IAC5D,CAAC,CAAC;AACJ,CAAC","file":"skipuntil.js","sourcesContent":["import { AsyncIterableX } from '../asynciterablex';\nimport { MonoTypeOperatorAsyncFunction } from '../../interfaces';\nimport { wrapWithAbort } from './withabort';\nimport { throwIfAborted } from '../../aborterror';\n\nexport class SkipUntilAsyncIterable<TSource> extends AsyncIterableX<TSource> {\n  private _source: AsyncIterable<TSource>;\n  private _other: (signal?: AbortSignal) => Promise<any>;\n\n  constructor(source: AsyncIterable<TSource>, other: (signal?: AbortSignal) => Promise<any>) {\n    super();\n    this._source = source;\n    this._other = other;\n  }\n\n  async *[Symbol.asyncIterator](signal?: AbortSignal) {\n    throwIfAborted(signal);\n    let otherDone = false;\n    this._other(signal).then(() => (otherDone = true));\n    for await (const item of wrapWithAbort(this._source, signal)) {\n      if (otherDone) {\n        yield item;\n      }\n    }\n  }\n}\n\n/**\n * Returns the elements from the source observable sequence only after the function that returns a promise produces an element.\n *\n * @template TSource The type of the elements in the source sequence.\n * @param {(signal?: AbortSignal) => Promise<any>} other A function which returns a promise that triggers propagation\n * of elements of the source sequence.\n * @returns {MonoTypeOperatorAsyncFunction<TSource>} An async-iterable sequence containing the elements of the source sequence\n * starting from the point the function that returns a promise triggered propagation.\n */\nexport function skipUntil<TSource>(\n  other: (signal?: AbortSignal) => Promise<any>\n): MonoTypeOperatorAsyncFunction<TSource> {\n  return function skipUntilOperatorFunction(\n    source: AsyncIterable<TSource>\n  ): AsyncIterableX<TSource> {\n    return new SkipUntilAsyncIterable<TSource>(source, other);\n  };\n}\n"]}