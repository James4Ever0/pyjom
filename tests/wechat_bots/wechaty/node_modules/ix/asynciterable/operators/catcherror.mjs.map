{"version":3,"sources":["asynciterable/operators/catcherror.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,cAAc,EAAE,MAAM,mBAAmB,CAAC;AAEnD,OAAO,EAAE,mBAAmB,EAAE,MAAM,2BAA2B,CAAC;AAChE,OAAO,EAAE,aAAa,EAAE,MAAM,aAAa,CAAC;AAC5C,OAAO,EAAE,cAAc,EAAE,MAAM,kBAAkB,CAAC;AAElD,MAAM,OAAO,sBAAyC,SAAQ,cAAiC;IACrF,OAAO,CAAyB;IAChC,QAAQ,CAG8C;IAE9D,YACE,MAA8B,EAC9B,OAG6D;QAE7D,KAAK,EAAE,CAAC;QACR,IAAI,CAAC,OAAO,GAAG,MAAM,CAAC;QACtB,IAAI,CAAC,QAAQ,GAAG,OAAO,CAAC;IAC1B,CAAC;IAED,KAAK,CAAC,CAAC,CAAC,MAAM,CAAC,aAAa,CAAC,CAAC,MAAoB;QAChD,cAAc,CAAC,MAAM,CAAC,CAAC;QACvB,IAAI,GAAuC,CAAC;QAC5C,IAAI,QAAQ,GAAG,KAAK,CAAC;QACrB,MAAM,MAAM,GAAG,aAAa,CAAC,IAAI,CAAC,OAAO,EAAE,MAAM,CAAC,CAAC;QACnD,MAAM,EAAE,GAAG,MAAM,CAAC,MAAM,CAAC,aAAa,CAAC,EAAE,CAAC;QAC1C,OAAO,CAAC,EAAE;YACR,IAAI,CAAC,GAA4B,EAAE,CAAC;YAEpC,IAAI;gBACF,CAAC,GAAG,MAAM,EAAE,CAAC,IAAI,EAAE,CAAC;gBACpB,IAAI,CAAC,CAAC,IAAI,EAAE;oBACV,MAAM,mBAAmB,CAAC,EAAE,CAAC,CAAC;oBAC9B,MAAM;iBACP;aACF;YAAC,OAAO,CAAC,EAAE;gBACV,GAAG,GAAG,MAAM,IAAI,CAAC,QAAQ,CAAC,CAAC,EAAE,MAAM,CAAC,CAAC;gBACrC,QAAQ,GAAG,IAAI,CAAC;gBAChB,MAAM,mBAAmB,CAAC,EAAE,CAAC,CAAC;gBAC9B,MAAM;aACP;YAED,MAAM,CAAC,CAAC,KAAK,CAAC;SACf;QAED,IAAI,QAAQ,EAAE;YACZ,IAAI,KAAK,EAAE,MAAM,IAAI,IAAI,aAAa,CAAC,GAAI,EAAE,MAAM,CAAC,EAAE;gBACpD,MAAM,IAAI,CAAC;aACZ;SACF;IACH,CAAC;CACF;AAED;;;;;;;;;;;;GAYG;AACH,MAAM,UAAU,UAAU,CACxB,OAG6D;IAE7D,OAAO,SAAS,yBAAyB,CACvC,MAA8B;QAE9B,OAAO,IAAI,sBAAsB,CAAmB,MAAM,EAAE,OAAO,CAAC,CAAC;IACvE,CAAC,CAAC;AACJ,CAAC","file":"catcherror.js","sourcesContent":["import { AsyncIterableX } from '../asynciterablex';\nimport { OperatorAsyncFunction } from '../../interfaces';\nimport { returnAsyncIterator } from '../../util/returniterator';\nimport { wrapWithAbort } from './withabort';\nimport { throwIfAborted } from '../../aborterror';\n\nexport class CatchWithAsyncIterable<TSource, TResult> extends AsyncIterableX<TSource | TResult> {\n  private _source: AsyncIterable<TSource>;\n  private _handler: (\n    error: any,\n    signal?: AbortSignal\n  ) => AsyncIterable<TResult> | Promise<AsyncIterable<TResult>>;\n\n  constructor(\n    source: AsyncIterable<TSource>,\n    handler: (\n      error: any,\n      signal?: AbortSignal\n    ) => AsyncIterable<TResult> | Promise<AsyncIterable<TResult>>\n  ) {\n    super();\n    this._source = source;\n    this._handler = handler;\n  }\n\n  async *[Symbol.asyncIterator](signal?: AbortSignal) {\n    throwIfAborted(signal);\n    let err: AsyncIterable<TResult> | undefined;\n    let hasError = false;\n    const source = wrapWithAbort(this._source, signal);\n    const it = source[Symbol.asyncIterator]();\n    while (1) {\n      let c = <IteratorResult<TSource>>{};\n\n      try {\n        c = await it.next();\n        if (c.done) {\n          await returnAsyncIterator(it);\n          break;\n        }\n      } catch (e) {\n        err = await this._handler(e, signal);\n        hasError = true;\n        await returnAsyncIterator(it);\n        break;\n      }\n\n      yield c.value;\n    }\n\n    if (hasError) {\n      for await (const item of wrapWithAbort(err!, signal)) {\n        yield item;\n      }\n    }\n  }\n}\n\n/**\n * Continues an async-iterable sequence that is terminated by an exception with the\n * async-iterable sequence produced by the handler.\n *\n * @template TSource The type of the elements in the source sequence.\n * @template TResult The type of elements from the handler function.\n * @param {((\n *     error: any,\n *     signal?: AbortSignal\n *   ) => AsyncIterable<TResult> | Promise<AsyncIterable<TResult>>)} handler Error handler function, producing another async-iterable sequence.\n * @returns {(OperatorAsyncFunction<TSource, TSource | TResult>)} An operator which continues an async-iterable sequence that is terminated by\n * an exception with the specified handler.\n */\nexport function catchError<TSource, TResult>(\n  handler: (\n    error: any,\n    signal?: AbortSignal\n  ) => AsyncIterable<TResult> | Promise<AsyncIterable<TResult>>\n): OperatorAsyncFunction<TSource, TSource | TResult> {\n  return function catchWithOperatorFunction(\n    source: AsyncIterable<TSource>\n  ): AsyncIterableX<TSource | TResult> {\n    return new CatchWithAsyncIterable<TSource, TResult>(source, handler);\n  };\n}\n"]}