{"version":3,"sources":["asynciterable/operators/groupby.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,cAAc,EAAE,MAAM,mBAAmB,CAAC;AACnD,OAAO,EAAE,aAAa,EAAE,MAAM,qBAAqB,CAAC;AACpD,OAAO,EAAE,cAAc,EAAE,MAAM,aAAa,CAAC;AAE7C,OAAO,EAAE,cAAc,EAAE,MAAM,kBAAkB,CAAC;AAElD,MAAM,OAAO,oBAAmC,SAAQ,cAAsB;IAC5D,GAAG,CAAO;IAClB,OAAO,CAAmB;IAElC,YAAY,GAAS,EAAE,MAAwB;QAC7C,KAAK,EAAE,CAAC;QACR,IAAI,CAAC,GAAG,GAAG,GAAG,CAAC;QACf,IAAI,CAAC,OAAO,GAAG,MAAM,CAAC;IACxB,CAAC;IAED,KAAK,CAAC,CAAC,CAAC,MAAM,CAAC,aAAa,CAAC,CAAC,MAAoB;QAChD,cAAc,CAAC,MAAM,CAAC,CAAC;QACvB,KAAK,MAAM,IAAI,IAAI,IAAI,CAAC,OAAO,EAAE;YAC/B,MAAM,IAAI,CAAC;SACZ;IACH,CAAC;CACF;AAED,MAAM,OAAO,oBAA4C,SAAQ,cAEhE;IACS,OAAO,CAAyB;IAChC,YAAY,CAAiE;IAC7E,gBAAgB,CAAqE;IAE7F,YACE,MAA8B,EAC9B,WAA2E,EAC3E,eAAmF;QAEnF,KAAK,EAAE,CAAC;QACR,IAAI,CAAC,OAAO,GAAG,MAAM,CAAC;QACtB,IAAI,CAAC,YAAY,GAAG,WAAW,CAAC;QAChC,IAAI,CAAC,gBAAgB,GAAG,eAAe,CAAC;IAC1C,CAAC;IAED,KAAK,CAAC,CAAC,CAAC,MAAM,CAAC,aAAa,CAAC,CAAC,MAAoB;QAChD,cAAc,CAAC,MAAM,CAAC,CAAC;QACvB,MAAM,GAAG,GAAG,MAAM,cAAc,CAC9B,IAAI,CAAC,OAAO,EACZ,IAAI,CAAC,YAAY,EACjB,IAAI,CAAC,gBAAgB,EACrB,MAAM,CACP,CAAC;QACF,KAAK,MAAM,CAAC,GAAG,EAAE,MAAM,CAAC,IAAI,GAAG,EAAE;YAC/B,MAAM,IAAI,oBAAoB,CAAe,GAAG,EAAE,MAAM,CAAC,CAAC;SAC3D;IACH,CAAC;CACF;AASD;;;;;;;;;;;;;GAaG;AACH,MAAM,UAAU,OAAO,CACrB,WAA2E,EAC3E,kBAGgC,aAAa;IAE7C,OAAO,SAAS,uBAAuB,CACrC,MAA8B;QAE9B,OAAO,IAAI,oBAAoB,CAAwB,MAAM,EAAE,WAAW,EAAE,eAAe,CAAC,CAAC;IAC/F,CAAC,CAAC;AACJ,CAAC","file":"groupby.js","sourcesContent":["import { AsyncIterableX } from '../asynciterablex';\nimport { identityAsync } from '../../util/identity';\nimport { createGrouping } from './_grouping';\nimport { OperatorAsyncFunction } from '../../interfaces';\nimport { throwIfAborted } from '../../aborterror';\n\nexport class GroupedAsyncIterable<TKey, TValue> extends AsyncIterableX<TValue> {\n  public readonly key: TKey;\n  private _source: Iterable<TValue>;\n\n  constructor(key: TKey, source: Iterable<TValue>) {\n    super();\n    this.key = key;\n    this._source = source;\n  }\n\n  async *[Symbol.asyncIterator](signal?: AbortSignal) {\n    throwIfAborted(signal);\n    for (const item of this._source) {\n      yield item;\n    }\n  }\n}\n\nexport class GroupByAsyncIterable<TSource, TKey, TValue> extends AsyncIterableX<\n  GroupedAsyncIterable<TKey, TValue>\n> {\n  private _source: AsyncIterable<TSource>;\n  private _keySelector: (value: TSource, signal?: AbortSignal) => TKey | Promise<TKey>;\n  private _elementSelector: (value: TSource, signal?: AbortSignal) => TValue | Promise<TValue>;\n\n  constructor(\n    source: AsyncIterable<TSource>,\n    keySelector: (value: TSource, signal?: AbortSignal) => TKey | Promise<TKey>,\n    elementSelector: (value: TSource, signal?: AbortSignal) => TValue | Promise<TValue>\n  ) {\n    super();\n    this._source = source;\n    this._keySelector = keySelector;\n    this._elementSelector = elementSelector;\n  }\n\n  async *[Symbol.asyncIterator](signal?: AbortSignal) {\n    throwIfAborted(signal);\n    const map = await createGrouping(\n      this._source,\n      this._keySelector,\n      this._elementSelector,\n      signal\n    );\n    for (const [key, values] of map) {\n      yield new GroupedAsyncIterable<TKey, TValue>(key, values);\n    }\n  }\n}\n\nexport function groupBy<TSource, TKey>(\n  keySelector: (value: TSource, signal?: AbortSignal) => TKey | Promise<TKey>\n): OperatorAsyncFunction<TSource, GroupedAsyncIterable<TKey, TSource>>;\nexport function groupBy<TSource, TKey, TValue>(\n  keySelector: (value: TSource, signal?: AbortSignal) => TKey | Promise<TKey>,\n  elementSelector?: (value: TSource, signal?: AbortSignal) => TValue | Promise<TValue>\n): OperatorAsyncFunction<TSource, GroupedAsyncIterable<TKey, TValue>>;\n/**\n * Groups the elements of an async-iterable sequence and selects the resulting elements by using a specified function.\n *\n * @template TSource The type of the elements in the source sequence.\n * @template TKey The type of the grouping key computed for each element in the source sequence.\n * @template TValue The type of the elements within the groups computed for each element in the source sequence.\n * @param {((value: TSource, signal?: AbortSignal) => TKey | Promise<TKey>)} keySelector A function to extract the key for each element.\n * @param {((\n *     value: TSource,\n *     signal?: AbortSignal\n *   ) => TValue | Promise<TValue>)} [elementSelector=identityAsync] A function to map each source element to an element in an async-enumerable group.\n * @returns {OperatorAsyncFunction<TSource, TResult>} A sequence of async-iterable groups, each of which corresponds to a unique key value,\n * containing all elements that share that same key value.\n */\nexport function groupBy<TSource, TKey, TValue>(\n  keySelector: (value: TSource, signal?: AbortSignal) => TKey | Promise<TKey>,\n  elementSelector: (\n    value: TSource,\n    signal?: AbortSignal\n  ) => TValue | Promise<TValue> = identityAsync\n): OperatorAsyncFunction<TSource, GroupedAsyncIterable<TKey, TValue>> {\n  return function groupByOperatorFunction(\n    source: AsyncIterable<TSource>\n  ): AsyncIterableX<GroupedAsyncIterable<TKey, TValue>> {\n    return new GroupByAsyncIterable<TSource, TKey, TValue>(source, keySelector, elementSelector);\n  };\n}\n"]}