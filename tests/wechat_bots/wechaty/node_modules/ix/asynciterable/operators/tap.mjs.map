{"version":3,"sources":["asynciterable/operators/tap.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,cAAc,EAAE,MAAM,mBAAmB,CAAC;AAGnD,OAAO,EAAE,UAAU,EAAE,MAAM,uBAAuB,CAAC;AACnD,OAAO,EAAE,aAAa,EAAE,MAAM,aAAa,CAAC;AAC5C,OAAO,EAAE,UAAU,EAAE,cAAc,EAAE,MAAM,kBAAkB,CAAC;AAE9D,MAAM,OAAO,gBAA0B,SAAQ,cAAuB;IAC5D,OAAO,CAAyB;IAChC,SAAS,CAAgC;IAEjD,YAAY,MAA8B,EAAE,QAAuC;QACjF,KAAK,EAAE,CAAC;QACR,IAAI,CAAC,OAAO,GAAG,MAAM,CAAC;QACtB,IAAI,CAAC,SAAS,GAAG,QAAQ,CAAC;IAC5B,CAAC;IAED,KAAK,CAAC,CAAC,CAAC,MAAM,CAAC,aAAa,CAAC,CAAC,MAAoB;QAChD,cAAc,CAAC,MAAM,CAAC,CAAC;QACvB,MAAM,MAAM,GAAG,aAAa,CAAC,IAAI,CAAC,OAAO,EAAE,MAAM,CAAC,CAAC;QACnD,MAAM,EAAE,GAAG,MAAM,CAAC,MAAM,CAAC,aAAa,CAAC,EAAE,CAAC;QAC1C,OAAO,CAAC,EAAE;YACR,IAAI,IAAI,CAAC;YACT,IAAI;gBACF,IAAI,GAAG,MAAM,EAAE,CAAC,IAAI,EAAE,CAAC;aACxB;YAAC,OAAO,CAAC,EAAE;gBACV,IAAI,CAAC,YAAY,UAAU,EAAE;oBAC3B,MAAM,CAAC,CAAC;iBACT;gBAED,IAAI,IAAI,CAAC,SAAS,CAAC,KAAK,EAAE;oBACxB,MAAM,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;iBAC/B;gBACD,MAAM,CAAC,CAAC;aACT;YAED,IAAI,IAAI,CAAC,IAAI,EAAE;gBACb,IAAI,IAAI,CAAC,SAAS,CAAC,QAAQ,EAAE;oBAC3B,MAAM,IAAI,CAAC,SAAS,CAAC,QAAQ,EAAE,CAAC;iBACjC;gBACD,MAAM;aACP;YAED,IAAI,IAAI,CAAC,SAAS,CAAC,IAAI,EAAE;gBACvB,MAAM,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;aACvC;YACD,MAAM,IAAI,CAAC,KAAK,CAAC;SAClB;IACH,CAAC;CACF;AAgCD;;;;;;;;;;;GAWG;AACH,MAAM,UAAU,GAAG,CACjB,cAAiF,EACjF,KAAkC,EAClC,QAA6B;IAE7B,OAAO,SAAS,mBAAmB,CAAC,MAA8B;QAChE,OAAO,IAAI,gBAAgB,CAAU,MAAM,EAAE,UAAU,CAAC,cAAc,EAAE,KAAK,EAAE,QAAQ,CAAC,CAAC,CAAC;IAC5F,CAAC,CAAC;AACJ,CAAC","file":"tap.js","sourcesContent":["import { AsyncIterableX } from '../asynciterablex';\nimport { PartialAsyncObserver } from '../../observer';\nimport { MonoTypeOperatorAsyncFunction } from '../../interfaces';\nimport { toObserver } from '../../util/toobserver';\nimport { wrapWithAbort } from './withabort';\nimport { AbortError, throwIfAborted } from '../../aborterror';\n\nexport class TapAsyncIterable<TSource> extends AsyncIterableX<TSource> {\n  private _source: AsyncIterable<TSource>;\n  private _observer: PartialAsyncObserver<TSource>;\n\n  constructor(source: AsyncIterable<TSource>, observer: PartialAsyncObserver<TSource>) {\n    super();\n    this._source = source;\n    this._observer = observer;\n  }\n\n  async *[Symbol.asyncIterator](signal?: AbortSignal) {\n    throwIfAborted(signal);\n    const source = wrapWithAbort(this._source, signal);\n    const it = source[Symbol.asyncIterator]();\n    while (1) {\n      let next;\n      try {\n        next = await it.next();\n      } catch (e) {\n        if (e instanceof AbortError) {\n          throw e;\n        }\n\n        if (this._observer.error) {\n          await this._observer.error(e);\n        }\n        throw e;\n      }\n\n      if (next.done) {\n        if (this._observer.complete) {\n          await this._observer.complete();\n        }\n        break;\n      }\n\n      if (this._observer.next) {\n        await this._observer.next(next.value);\n      }\n      yield next.value;\n    }\n  }\n}\n\n/**\n * Invokes an action for each element in the async-iterable sequence, and propagates all observer\n * messages through the result sequence. This method can be used for debugging, logging, etc. by\n * intercepting the message stream to run arbitrary actions for messages on the pipeline.\n *\n * @template TSource The type of the elements in the source sequence.\n * @param {PartialAsyncObserver<TSource>} observer Observer whose methods to invoke as part of the source sequence's observation.\n * @returns {MonoTypeOperatorAsyncFunction<TSource>} The source sequence with the side-effecting behavior applied.\n */\nexport function tap<TSource>(\n  observer: PartialAsyncObserver<TSource>\n): MonoTypeOperatorAsyncFunction<TSource>;\n\n/**\n * Invokes an action for each element in the async-iterable sequence, and propagates all observer\n * messages through the result sequence. This method can be used for debugging, logging, etc. by\n * intercepting the message stream to run arbitrary actions for messages on the pipeline.\n *\n * @template TSource The type of the elements in the source sequence.\n * @param {(((value: TSource) => any) | null)} [next] Function to invoke for each element in the async-iterable sequence.\n * @param {(((err: any) => any) | null)} [error] Function to invoke upon exceptional termination of the async-iterable sequence.\n * @param {((() => any) | null)} [complete] Function to invoke upon graceful termination of the async-iterable sequence.\n * @returns {MonoTypeOperatorAsyncFunction<TSource>} The source sequence with the side-effecting behavior applied.\n */\nexport function tap<TSource>(\n  next?: ((value: TSource) => any) | null,\n  error?: ((err: any) => any) | null,\n  complete?: (() => any) | null\n): MonoTypeOperatorAsyncFunction<TSource>;\n\n/**\n * Invokes an action for each element in the async-iterable sequence, and propagates all observer\n * messages through the result sequence. This method can be used for debugging, logging, etc. by\n * intercepting the message stream to run arbitrary actions for messages on the pipeline.\n *\n * @template TSource The type of the elements in the source sequence.\n * @param {(PartialAsyncObserver<TSource> | ((value: TSource) => any) | null)} [observerOrNext] Observer whose methods to invoke as\n * part of the source sequence's observation or a function to invoke for each element in the async-iterable sequence.\n * @param {(((err: any) => any) | null)} [error] Function to invoke upon exceptional termination of the async-iterable sequence.\n * @param {((() => any) | null)} [complete] Function to invoke upon graceful termination of the async-iterable sequence.\n * @returns {MonoTypeOperatorAsyncFunction<TSource>} The source sequence with the side-effecting behavior applied.\n */\nexport function tap<TSource>(\n  observerOrNext?: PartialAsyncObserver<TSource> | ((value: TSource) => any) | null,\n  error?: ((err: any) => any) | null,\n  complete?: (() => any) | null\n): MonoTypeOperatorAsyncFunction<TSource> {\n  return function tapOperatorFunction(source: AsyncIterable<TSource>): AsyncIterableX<TSource> {\n    return new TapAsyncIterable<TSource>(source, toObserver(observerOrNext, error, complete));\n  };\n}\n"]}