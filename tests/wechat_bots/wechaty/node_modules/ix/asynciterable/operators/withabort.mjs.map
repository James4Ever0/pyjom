{"version":3,"sources":["asynciterable/operators/withabort.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,cAAc,EAAE,MAAM,mBAAmB,CAAC;AAGnD,MAAM,OAAO,sBAAgC,SAAQ,cAAuB;IAClE,OAAO,CAAyB;IAChC,OAAO,CAAc;IAE7B,YAAY,MAA8B,EAAE,MAAmB;QAC7D,KAAK,EAAE,CAAC;QACR,IAAI,CAAC,OAAO,GAAG,MAAM,CAAC;QACtB,IAAI,CAAC,OAAO,GAAG,MAAM,CAAC;IACxB,CAAC;IAED,SAAS,CAAC,MAAmB;QAC3B,OAAO,IAAI,sBAAsB,CAAU,IAAI,CAAC,OAAO,EAAE,MAAM,CAAC,CAAC;IACnE,CAAC;IAED,CAAC,MAAM,CAAC,aAAa,CAAC;QACpB,OAAO,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,aAAa,CAAC,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;IAC1D,CAAC;CACF;AAED;;;;;;GAMG;AACH,MAAM,UAAU,SAAS,CAAU,MAAmB;IACpD,OAAO,SAAS,yBAAyB,CACvC,MAA8B;QAE9B,OAAO,IAAI,sBAAsB,CAAC,MAAM,EAAE,MAAM,CAAC,CAAC;IACpD,CAAC,CAAC;AACJ,CAAC;AAED;;;;;;;GAOG;AACH,MAAM,UAAU,aAAa,CAC3B,MAA8B,EAC9B,MAAoB;IAEpB,OAAO,MAAM,CAAC,CAAC,CAAC,IAAI,sBAAsB,CAAC,MAAM,EAAE,MAAM,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC;AACtE,CAAC","file":"withabort.js","sourcesContent":["import { AsyncIterableX } from '../asynciterablex';\nimport { MonoTypeOperatorAsyncFunction } from '../../interfaces';\n\nexport class WithAbortAsyncIterable<TSource> extends AsyncIterableX<TSource> {\n  private _source: AsyncIterable<TSource>;\n  private _signal: AbortSignal;\n\n  constructor(source: AsyncIterable<TSource>, signal: AbortSignal) {\n    super();\n    this._source = source;\n    this._signal = signal;\n  }\n\n  withAbort(signal: AbortSignal) {\n    return new WithAbortAsyncIterable<TSource>(this._source, signal);\n  }\n\n  [Symbol.asyncIterator](): AsyncIterator<TSource> {\n    return this._source[Symbol.asyncIterator](this._signal);\n  }\n}\n\n/**\n * Wraps the existing async-iterable sequence with an abort signal for cancellation.\n *\n * @template TSource The type of the elements in the source sequence.\n * @param {AbortSignal} signal The abort signal used for cancellation.\n * @returns {MonoTypeOperatorAsyncFunction<TSource>} An async-iterable that can be cancelled by the abort signal.\n */\nexport function withAbort<TSource>(signal: AbortSignal): MonoTypeOperatorAsyncFunction<TSource> {\n  return function withAbortOperatorFunction(\n    source: AsyncIterable<TSource>\n  ): AsyncIterableX<TSource> {\n    return new WithAbortAsyncIterable(source, signal);\n  };\n}\n\n/**\n * Wraps an existing async-iterable with a new async-iterable which support cancellation.\n *\n * @template TSource The type of the elements in the source sequence.\n * @param {AsyncIterable<TSource>} source The source sequence to wrap with the abort signal.\n * @param {AbortSignal} [signal] The abort signal used for cancellation.\n * @returns {AsyncIterable<TSource>} The source sequence wrapped with an abort signal for cancellation.\n */\nexport function wrapWithAbort<TSource>(\n  source: AsyncIterable<TSource>,\n  signal?: AbortSignal\n): AsyncIterable<TSource> {\n  return signal ? new WithAbortAsyncIterable(source, signal) : source;\n}\n"]}