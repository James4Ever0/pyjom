{"version":3,"sources":["asynciterable/isempty.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,aAAa,EAAE,MAAM,uBAAuB,CAAC;AACtD,OAAO,EAAE,cAAc,EAAE,MAAM,eAAe,CAAC;AAE/C;;;;;;;GAOG;AACH,MAAM,CAAC,KAAK,UAAU,OAAO,CAAI,MAAwB,EAAE,MAAoB;IAC7E,cAAc,CAAC,MAAM,CAAC,CAAC;IACvB,IAAI,KAAK,EAAE,MAAM,CAAC,IAAI,aAAa,CAAC,MAAM,EAAE,MAAM,CAAC,EAAE;QACnD,OAAO,KAAK,CAAC;KACd;IACD,OAAO,IAAI,CAAC;AACd,CAAC","file":"isempty.js","sourcesContent":["import { wrapWithAbort } from './operators/withabort';\nimport { throwIfAborted } from '../aborterror';\n\n/**\n * Determines whether the given async-iterable is empty.\n *\n * @template T The type of elements in the source sequence.\n * @param {AsyncIterable<T>} source The source async-iterable to determine whether it is empty.\n * @param {AbortSignal} [signal] An optional abort signal to cancel the operation.\n * @returns {Promise<boolean>} Returns a promise containing true if the sequence is empty, otherwise false.\n */\nexport async function isEmpty<T>(source: AsyncIterable<T>, signal?: AbortSignal): Promise<boolean> {\n  throwIfAborted(signal);\n  for await (const _ of wrapWithAbort(source, signal)) {\n    return false;\n  }\n  return true;\n}\n"]}