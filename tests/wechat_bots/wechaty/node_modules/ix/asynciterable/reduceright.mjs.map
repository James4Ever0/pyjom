{"version":3,"sources":["asynciterable/reduceright.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,OAAO,EAAE,MAAM,WAAW,CAAC;AAEpC,OAAO,EAAE,cAAc,EAAE,MAAM,eAAe,CAAC;AAE/C;;;;;;;;;;GAUG;AACH,MAAM,CAAC,KAAK,UAAU,WAAW,CAC/B,MAAwB,EACxB,OAA4B;IAE5B,MAAM,EAAE,CAAC,MAAM,CAAC,EAAE,IAAI,EAAE,CAAC,QAAQ,CAAC,EAAE,MAAM,EAAE,CAAC,UAAU,CAAC,EAAE,QAAQ,EAAE,GAAG,OAAO,CAAC;IAC/E,MAAM,OAAO,GAAG,OAAO,CAAC,cAAc,CAAC,MAAM,CAAC,CAAC;IAC/C,cAAc,CAAC,MAAM,CAAC,CAAC;IACvB,MAAM,KAAK,GAAG,MAAM,OAAO,CAAC,MAAM,EAAE,MAAM,CAAC,CAAC;IAC5C,IAAI,QAAQ,GAAG,KAAK,CAAC;IACrB,IAAI,GAAG,GAAG,IAAa,CAAC;IACxB,KAAK,IAAI,MAAM,GAAG,KAAK,CAAC,MAAM,GAAG,CAAC,EAAE,MAAM,IAAI,CAAC,EAAE,MAAM,EAAE,EAAE;QACzD,MAAM,IAAI,GAAG,KAAK,CAAC,MAAM,CAAC,CAAC;QAC3B,IAAI,QAAQ,IAAI,CAAC,QAAQ,GAAG,OAAO,CAAC,EAAE;YACpC,GAAG,GAAG,MAAM,QAAQ,CAAI,GAAG,EAAE,IAAI,EAAE,MAAM,EAAE,MAAM,CAAC,CAAC;SACpD;aAAM;YACL,GAAG,GAAG,IAAI,CAAC;YACX,QAAQ,GAAG,IAAI,CAAC;SACjB;KACF;IAED,IAAI,CAAC,CAAC,OAAO,IAAI,QAAQ,CAAC,EAAE;QAC1B,MAAM,IAAI,KAAK,CAAC,+BAA+B,CAAC,CAAC;KAClD;IAED,OAAO,GAAQ,CAAC;AAClB,CAAC","file":"reduceright.js","sourcesContent":["import { toArray } from './toarray';\nimport { ReduceOptions } from './reduceoptions';\nimport { throwIfAborted } from '../aborterror';\n\n/**\n * Applies an accumulator function over an async-iterable sequence from the end, returning the result of the aggregation as a\n * single element in the result sequence. The seed value, if specified, is used as the initial accumulator value.\n * For aggregation behavior with incremental intermediate results, scan.\n *\n * @template T The type of the elements in the source sequence.\n * @template R The type of the result of the aggregation.\n * @param {AsyncIterable<T>} source An async-iterable sequence to aggregate over from the right.\n * @param {ReduceOptions<T, R>} options The options which contains a callback, with optional seed and an optional abort signal for cancellation.\n * @returns {Promise<R>} A promise with the final accumulator value.\n */\nexport async function reduceRight<T, R = T>(\n  source: AsyncIterable<T>,\n  options: ReduceOptions<T, R>\n): Promise<R> {\n  const { ['seed']: seed, ['signal']: signal, ['callback']: callback } = options;\n  const hasSeed = options.hasOwnProperty('seed');\n  throwIfAborted(signal);\n  const array = await toArray(source, signal);\n  let hasValue = false;\n  let acc = seed as T | R;\n  for (let offset = array.length - 1; offset >= 0; offset--) {\n    const item = array[offset];\n    if (hasValue || (hasValue = hasSeed)) {\n      acc = await callback(<R>acc, item, offset, signal);\n    } else {\n      acc = item;\n      hasValue = true;\n    }\n  }\n\n  if (!(hasSeed || hasValue)) {\n    throw new Error('Sequence contains no elements');\n  }\n\n  return acc as R;\n}\n"]}