{"version":3,"sources":["iterable/operators/catcherror.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,SAAS,EAAE,MAAM,cAAc,CAAC;AACzC,OAAO,EAAE,cAAc,EAAE,MAAM,2BAA2B,CAAC;AAG3D,MAAM,OAAO,iBAAoC,SAAQ,SAA4B;IAC3E,OAAO,CAAoB;IAC3B,QAAQ,CAAoC;IAEpD,YAAY,MAAyB,EAAE,OAA0C;QAC/E,KAAK,EAAE,CAAC;QACR,IAAI,CAAC,OAAO,GAAG,MAAM,CAAC;QACtB,IAAI,CAAC,QAAQ,GAAG,OAAO,CAAC;IAC1B,CAAC;IAED,CAAC,CAAC,MAAM,CAAC,QAAQ,CAAC;QAChB,IAAI,GAAkC,CAAC;QACvC,IAAI,QAAQ,GAAG,KAAK,CAAC;QACrB,MAAM,EAAE,GAAG,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,QAAQ,CAAC,EAAE,CAAC;QAC3C,OAAO,CAAC,EAAE;YACR,IAAI,IAAyB,CAAC;YAC9B,IAAI,KAAc,CAAC;YAEnB,IAAI;gBACF,CAAC,EAAE,IAAI,EAAE,KAAK,EAAE,GAAG,EAAE,CAAC,IAAI,EAAE,CAAC,CAAC;gBAC9B,IAAI,IAAI,EAAE;oBACR,cAAc,CAAC,EAAE,CAAC,CAAC;oBACnB,MAAM;iBACP;aACF;YAAC,OAAO,CAAC,EAAE;gBACV,GAAG,GAAG,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC;gBACvB,QAAQ,GAAG,IAAI,CAAC;gBAChB,cAAc,CAAC,EAAE,CAAC,CAAC;gBACnB,MAAM;aACP;YAED,MAAM,KAAK,CAAC;SACb;QAED,IAAI,QAAQ,EAAE;YACZ,KAAK,MAAM,IAAI,IAAI,GAAI,EAAE;gBACvB,MAAM,IAAI,CAAC;aACZ;SACF;IACH,CAAC;CACF;AAED;;;;;;;;;GASG;AACH,MAAM,UAAU,UAAU,CACxB,OAA0C;IAE1C,OAAO,SAAS,yBAAyB,CACvC,MAAyB;QAEzB,OAAO,IAAI,iBAAiB,CAAmB,MAAM,EAAE,OAAO,CAAC,CAAC;IAClE,CAAC,CAAC;AACJ,CAAC","file":"catcherror.js","sourcesContent":["import { IterableX } from '../iterablex';\nimport { returnIterator } from '../../util/returniterator';\nimport { OperatorFunction } from '../../interfaces';\n\nexport class CatchWithIterable<TSource, TResult> extends IterableX<TSource | TResult> {\n  private _source: Iterable<TSource>;\n  private _handler: (error: any) => Iterable<TResult>;\n\n  constructor(source: Iterable<TSource>, handler: (error: any) => Iterable<TResult>) {\n    super();\n    this._source = source;\n    this._handler = handler;\n  }\n\n  *[Symbol.iterator]() {\n    let err: Iterable<TResult> | undefined;\n    let hasError = false;\n    const it = this._source[Symbol.iterator]();\n    while (1) {\n      let done: boolean | undefined;\n      let value: TSource;\n\n      try {\n        ({ done, value } = it.next());\n        if (done) {\n          returnIterator(it);\n          break;\n        }\n      } catch (e) {\n        err = this._handler(e);\n        hasError = true;\n        returnIterator(it);\n        break;\n      }\n\n      yield value;\n    }\n\n    if (hasError) {\n      for (const item of err!) {\n        yield item;\n      }\n    }\n  }\n}\n\n/**\n * Continues an async-iterable sequence that is terminated by an exception with the\n * async-iterable sequence produced by the handler.\n *\n * @template TSource The type of the elements in the source sequence.\n * @template TResult The type of elements from the handler function.\n * @param {(error: any) => Iterable<TResult>} handler Error handler function, producing another async-iterable sequence.\n * @returns {(OperatorFunction<TSource, TSource | TResult>)} An operator which continues an async-iterable sequence that is terminated by\n * an exception with the specified handler.\n */\nexport function catchError<TSource, TResult>(\n  handler: (error: any) => Iterable<TResult>\n): OperatorFunction<TSource, TSource | TResult> {\n  return function catchWithOperatorFunction(\n    source: Iterable<TSource>\n  ): IterableX<TSource | TResult> {\n    return new CatchWithIterable<TSource, TResult>(source, handler);\n  };\n}\n"]}