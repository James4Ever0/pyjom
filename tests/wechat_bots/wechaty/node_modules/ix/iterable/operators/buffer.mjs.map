{"version":3,"sources":["iterable/operators/buffer.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,SAAS,EAAE,MAAM,cAAc,CAAC;AAGzC,MAAM,OAAO,cAAwB,SAAQ,SAAoB;IACvD,OAAO,CAAoB;IAC3B,MAAM,CAAS;IACf,KAAK,CAAS;IAEtB,YAAY,MAAyB,EAAE,KAAa,EAAE,IAAY;QAChE,KAAK,EAAE,CAAC;QACR,IAAI,CAAC,OAAO,GAAG,MAAM,CAAC;QACtB,IAAI,CAAC,MAAM,GAAG,KAAK,CAAC;QACpB,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC;IACpB,CAAC;IAED,CAAC,CAAC,MAAM,CAAC,QAAQ,CAAC;QAChB,MAAM,OAAO,GAAgB,EAAE,CAAC;QAChC,IAAI,CAAC,GAAG,CAAC,CAAC;QACV,KAAK,MAAM,IAAI,IAAI,IAAI,CAAC,OAAO,EAAE;YAC/B,IAAI,CAAC,GAAG,IAAI,CAAC,KAAK,KAAK,CAAC,EAAE;gBACxB,OAAO,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;aAClB;YAED,KAAK,MAAM,IAAI,IAAI,OAAO,EAAE;gBAC1B,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;aACjB;YAED,IAAI,OAAO,CAAC,MAAM,GAAG,CAAC,IAAI,OAAO,CAAC,CAAC,CAAC,CAAC,MAAM,KAAK,IAAI,CAAC,MAAM,EAAE;gBAC3D,MAAM,OAAO,CAAC,KAAK,EAAG,CAAC;aACxB;YAED,CAAC,EAAE,CAAC;SACL;QAED,OAAO,OAAO,CAAC,MAAM,GAAG,CAAC,EAAE;YACzB,MAAM,OAAO,CAAC,KAAK,EAAG,CAAC;SACxB;IACH,CAAC;CACF;AAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;GA4BG;AACH,MAAM,UAAU,MAAM,CACpB,KAAa,EACb,IAAa;IAEb,IAAI,CAAC,GAAG,IAAI,CAAC;IACb,IAAI,CAAC,IAAI,IAAI,EAAE;QACb,CAAC,GAAG,KAAK,CAAC;KACX;IACD,OAAO,SAAS,sBAAsB,CAAC,MAAyB;QAC9D,OAAO,IAAI,cAAc,CAAC,MAAM,EAAE,KAAK,EAAE,CAAE,CAAC,CAAC;IAC/C,CAAC,CAAC;AACJ,CAAC","file":"buffer.js","sourcesContent":["import { IterableX } from '../iterablex';\nimport { OperatorFunction } from '../../interfaces';\n\nexport class BufferIterable<TSource> extends IterableX<TSource[]> {\n  private _source: Iterable<TSource>;\n  private _count: number;\n  private _skip: number;\n\n  constructor(source: Iterable<TSource>, count: number, skip: number) {\n    super();\n    this._source = source;\n    this._count = count;\n    this._skip = skip;\n  }\n\n  *[Symbol.iterator]() {\n    const buffers: TSource[][] = [];\n    let i = 0;\n    for (const item of this._source) {\n      if (i % this._skip === 0) {\n        buffers.push([]);\n      }\n\n      for (const buff of buffers) {\n        buff.push(item);\n      }\n\n      if (buffers.length > 0 && buffers[0].length === this._count) {\n        yield buffers.shift()!;\n      }\n\n      i++;\n    }\n\n    while (buffers.length > 0) {\n      yield buffers.shift()!;\n    }\n  }\n}\n\n/**\n * Generates a sequence of buffers over the source sequence, with specified length and possible overlap.\n * @example <caption>Creates a sequence of buffers with and without skip</caption>\n * const source = [1, 2, 3, 4, 5, 6, 7, 8, 9, 0];\n *\n * // Without skip\n * const result = buffer(source, 5);\n * const result = Ix.Iterable.from(source).buffer(5);\n * for (const item of result) {\n *   console.log(result);\n * }\n * // => [0, 1, 2, 3, 4]\n * // => [5, 6, 7, 8, 9]\n *\n * // With skip\n * const result = buffer(source, 3, 4);\n * const result = Ix.Iterable.from(source).buffer(3, 4);\n * for (const item of result) {\n *   console.log(result);\n * }\n * // => [0, 1, 2]\n * // => [4, 5, 6]\n * // => [8, 9]\n * @param {Iterabel<TSource>} source Source sequence\n * @param {number} count Number of elements for allocated buffers.\n * @param {number} [skip] Number of elements to skip between the start of consecutive buffers. If not specified, defaults\n * to the count.\n * @return {IterableX<TSource>[]} Sequence of buffers containing source sequence elements\n */\nexport function buffer<TSource>(\n  count: number,\n  skip?: number\n): OperatorFunction<TSource, TSource[]> {\n  let s = skip;\n  if (s == null) {\n    s = count;\n  }\n  return function bufferOperatorFunction(source: Iterable<TSource>): IterableX<TSource[]> {\n    return new BufferIterable(source, count, s!);\n  };\n}\n"]}