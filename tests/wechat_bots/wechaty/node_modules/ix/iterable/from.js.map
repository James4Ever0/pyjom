{"version":3,"sources":["iterable/from.ts"],"names":[],"mappings":";;;AACA,+CAA4C;AAC5C,uDAAoD;AACpD,mDAAyE;AACzE,+CAA4C;AAe5C,SAAgB,WAAW,CAAC,IAAsB;IAChD,kBAAkB;IAClB,YAAI,GAAG,UACL,MAAkE,EAClE,WAAuD,mBAAQ,EAC/D,OAAa;QAEb,MAAM,EAAE,GAAG,2BAAY,CAAC,QAAQ,EAAE,OAAO,EAAE,CAAC,CAAC,CAAC;QAC9C,IAAI,uBAAU,CAAC,MAAM,CAAC,EAAE;YACtB,OAAO,IAAI,oBAAY,CAAmB,MAAM,EAAE,EAAE,CAAC,CAAC;SACvD;QACD,IAAI,wBAAW,CAAC,MAAM,CAAC,EAAE;YACvB,OAAO,IAAI,oBAAY,CAAmB,MAAM,EAAE,EAAE,CAAC,CAAC;SACvD;QACD,IAAI,uBAAU,CAAC,MAAM,CAAC,EAAE;YACtB,OAAO,IAAI,oBAAY,CAAmB,EAAE,CAAC,MAAM,CAAC,QAAQ,CAAC,EAAE,GAAG,EAAE,CAAC,MAAM,EAAE,EAAE,EAAE,CAAC,CAAC;SACpF;QACD,MAAM,IAAI,SAAS,CAAC,0BAA0B,CAAC,CAAC;IAClD,CAAC,CAAC;IAEF,qCAAqC;IACrC,oBAAY,GAAG,MAAM,YAAyC,SAAQ,IAAa;QACzE,OAAO,CAAyC;QAChD,GAAG,CAA6C;QAExD,YACE,MAA8C,EAC9C,EAA8C;YAE9C,KAAK,EAAE,CAAC;YACR,IAAI,CAAC,OAAO,GAAG,MAAM,CAAC;YACtB,IAAI,CAAC,GAAG,GAAG,EAAE,CAAC;QAChB,CAAC;QAED,CAAC,CAAC,MAAM,CAAC,QAAQ,CAAC;YAChB,MAAM,QAAQ,GAAG,uBAAU,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;YAC1C,IAAI,CAAC,GAAG,CAAC,CAAC;YACV,IAAI,QAAQ,EAAE;gBACZ,KAAK,MAAM,IAAI,IAAwB,IAAI,CAAC,OAAO,EAAE;oBACnD,MAAM,IAAI,CAAC,GAAG,CAAC,IAAI,EAAE,CAAC,EAAE,CAAC,CAAC;iBAC3B;aACF;iBAAM;gBACL,MAAM,MAAM,GAAG,mBAAQ,CAAuB,IAAI,CAAC,OAAQ,CAAC,MAAM,CAAC,CAAC;gBACpE,OAAO,CAAC,GAAG,MAAM,EAAE;oBACjB,MAAM,GAAG,GAAyB,IAAI,CAAC,OAAQ,CAAC,CAAC,CAAC,CAAC;oBACnD,MAAM,IAAI,CAAC,GAAG,CAAC,GAAG,EAAE,CAAC,EAAE,CAAC,CAAC;iBAC1B;aACF;QACH,CAAC;KACF,CAAC;AACJ,CAAC;AAlDD,kCAkDC","file":"from.js","sourcesContent":["import { IterableX } from './iterablex';\nimport { identity } from '../util/identity';\nimport { bindCallback } from '../util/bindcallback';\nimport { isIterable, isArrayLike, isIterator } from '../util/isiterable';\nimport { toLength } from '../util/tolength';\n\n/** @nocollapse */\nexport let from: <TSource, TResult = TSource>(\n  source: Iterable<TSource> | Iterator<TSource> | ArrayLike<TSource>,\n  selector?: (value: TSource, index: number) => TResult,\n  thisArg?: any\n) => IterableX<TResult>;\n\n/** @nocollapse */\nexport let FromIterable: new <TSource, TResult = TSource>(\n  source: Iterable<TSource> | ArrayLike<TSource>,\n  selector: (value: TSource, index: number) => TResult\n) => IterableX<TResult>;\n\nexport function _initialize(Ctor: typeof IterableX) {\n  /** @nocollapse */\n  from = function<TSource, TResult = TSource> (\n    source: Iterable<TSource> | Iterator<TSource> | ArrayLike<TSource>,\n    selector: (value: TSource, index: number) => TResult = identity,\n    thisArg?: any\n  ): IterableX<TResult> {\n    const fn = bindCallback(selector, thisArg, 2);\n    if (isIterable(source)) {\n      return new FromIterable<TSource, TResult>(source, fn);\n    }\n    if (isArrayLike(source)) {\n      return new FromIterable<TSource, TResult>(source, fn);\n    }\n    if (isIterator(source)) {\n      return new FromIterable<TSource, TResult>({ [Symbol.iterator]: () => source }, fn);\n    }\n    throw new TypeError('Input type not supported');\n  };\n\n  // eslint-disable-next-line no-shadow\n  FromIterable = class FromIterable<TSource, TResult = TSource> extends Ctor<TResult> {\n    private _source: Iterable<TSource> | ArrayLike<TSource>;\n    private _fn: (value: TSource, index: number) => TResult;\n\n    constructor(\n      source: Iterable<TSource> | ArrayLike<TSource>,\n      fn: (value: TSource, index: number) => TResult\n    ) {\n      super();\n      this._source = source;\n      this._fn = fn;\n    }\n\n    *[Symbol.iterator]() {\n      const iterable = isIterable(this._source);\n      let i = 0;\n      if (iterable) {\n        for (const item of <Iterable<TSource>> this._source) {\n          yield this._fn(item, i++);\n        }\n      } else {\n        const length = toLength((<ArrayLike<TSource>> this._source).length);\n        while (i < length) {\n          const val = (<ArrayLike<TSource>> this._source)[i];\n          yield this._fn(val, i++);\n        }\n      }\n    }\n  };\n}\n"]}