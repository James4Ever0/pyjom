{"version":3,"sources":["iterable/iterablex.ts"],"names":[],"mappings":"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","file":"iterablex.js","sourcesContent":["import { as as asIterable } from './as';\nimport { _initialize as _initializeFrom } from './from';\nimport { UnaryFunction, OperatorFunction } from '../interfaces';\nimport { bindCallback } from '../util/bindcallback';\nimport { isReadableNodeStream, isWritableNodeStream } from '../util/isiterable';\n\n/**\n * This class serves as the base for all operations which support [Symbol.iterator].\n */\nexport abstract class IterableX<T> implements Iterable<T> {\n  abstract [Symbol.iterator](): Iterator<T>;\n\n  forEach(projection: (value: T, index: number) => void, thisArg?: any): void {\n    const fn = bindCallback(projection, thisArg, 2);\n    let i = 0;\n    for (const item of this) {\n      fn(item, i++);\n    }\n  }\n\n  /** @nocollapse */\n  pipe<R>(...operations: UnaryFunction<Iterable<T>, R>[]): R;\n  pipe<R>(...operations: OperatorFunction<T, R>[]): IterableX<R>;\n  pipe<R extends NodeJS.WritableStream>(writable: R, options?: { end?: boolean }): R;\n  pipe<R>(...args: any[]) {\n    let i = -1;\n    const n = args.length;\n    let acc: any = this;\n    while (++i < n) {\n      acc = args[i](asIterable(acc));\n    }\n    return acc;\n  }\n}\n\n(<any>IterableX.prototype)[Symbol.toStringTag] = 'IterableX';\n\nObject.defineProperty(IterableX, Symbol.hasInstance, {\n  writable: true,\n  configurable: true,\n  value(inst: any) {\n    return !!(inst && inst[Symbol.toStringTag] === 'IterableX');\n  },\n});\n\n_initializeFrom(IterableX);\n\ntype WritableOrOperatorFunction<T, R> =\n  | NodeJS.WritableStream\n  | NodeJS.ReadWriteStream\n  | OperatorFunction<T, R>;\n\ndeclare module '../iterable/iterablex' {\n  interface IterableX<T> extends Iterable<T> {\n    pipe(): IterableX<T>;\n    pipe<A>(op1: OperatorFunction<T, A>): IterableX<A>;\n    pipe<A, B>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>): IterableX<B>;\n    pipe<A, B, C>(\n      op1: OperatorFunction<T, A>,\n      op2: OperatorFunction<A, B>,\n      op3: OperatorFunction<B, C>\n    ): IterableX<C>;\n    pipe<A, B, C, D>(\n      op1: OperatorFunction<T, A>,\n      op2: OperatorFunction<A, B>,\n      op3: OperatorFunction<B, C>,\n      op4: OperatorFunction<C, D>\n    ): IterableX<D>;\n    pipe<A, B, C, D, E>(\n      op1: OperatorFunction<T, A>,\n      op2: OperatorFunction<A, B>,\n      op3: OperatorFunction<B, C>,\n      op4: OperatorFunction<C, D>,\n      op5: OperatorFunction<D, E>\n    ): IterableX<E>;\n    pipe<A, B, C, D, E, F>(\n      op1: OperatorFunction<T, A>,\n      op2: OperatorFunction<A, B>,\n      op3: OperatorFunction<B, C>,\n      op4: OperatorFunction<C, D>,\n      op5: OperatorFunction<D, E>,\n      op6: OperatorFunction<E, F>\n    ): IterableX<F>;\n    pipe<A, B, C, D, E, F, G>(\n      op1: OperatorFunction<T, A>,\n      op2: OperatorFunction<A, B>,\n      op3: OperatorFunction<B, C>,\n      op4: OperatorFunction<C, D>,\n      op5: OperatorFunction<D, E>,\n      op6: OperatorFunction<E, F>,\n      op7: OperatorFunction<F, G>\n    ): IterableX<G>;\n    pipe<A, B, C, D, E, F, G, H>(\n      op1: OperatorFunction<T, A>,\n      op2: OperatorFunction<A, B>,\n      op3: OperatorFunction<B, C>,\n      op4: OperatorFunction<C, D>,\n      op5: OperatorFunction<D, E>,\n      op6: OperatorFunction<E, F>,\n      op7: OperatorFunction<F, G>,\n      op8: OperatorFunction<G, H>\n    ): IterableX<H>;\n    pipe<A, B, C, D, E, F, G, H, I>(\n      op1: OperatorFunction<T, A>,\n      op2: OperatorFunction<A, B>,\n      op3: OperatorFunction<B, C>,\n      op4: OperatorFunction<C, D>,\n      op5: OperatorFunction<D, E>,\n      op6: OperatorFunction<E, F>,\n      op7: OperatorFunction<F, G>,\n      op8: OperatorFunction<G, H>,\n      op9: OperatorFunction<H, I>\n    ): IterableX<I>;\n    pipe<R>(...operations: OperatorFunction<T, R>[]): IterableX<R>;\n    pipe<A extends NodeJS.WritableStream>(op1: A, options?: { end?: boolean }): A;\n  }\n}\n\ntry {\n  ((isBrowser) => {\n    if (isBrowser) {\n      return;\n    }\n\n    IterableX.prototype['pipe'] = nodePipe;\n    const readableOpts = (x: any, opts = x._writableState || { objectMode: true }) => opts;\n\n    function nodePipe<T>(this: IterableX<T>, ...args: any[]) {\n      let i = -1;\n      let end: boolean;\n      const n = args.length;\n      let prev: any = this;\n      let next: WritableOrOperatorFunction<T, any>;\n      while (++i < n) {\n        next = args[i];\n        if (typeof next === 'function') {\n          prev = next(asIterable(prev));\n        } else if (isWritableNodeStream(next)) {\n          ({ end = true } = args[i + 1] || {});\n          // prettier-ignore\n          return isReadableNodeStream(prev) ? prev.pipe(next, {end}) :\n            asIterable(prev).toNodeStream(readableOpts(next)).pipe(next, {end});\n        }\n      }\n      return prev;\n    }\n  })(typeof window === 'object' && typeof document === 'object' && document.nodeType === 9);\n} catch (e) {\n  /* */\n}\n"]}