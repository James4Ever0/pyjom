"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.cacheMixin = void 0;
const gerror_1 = require("gerror");
const config_js_1 = require("../config.js");
const mod_js_1 = require("../schemas/mod.js");
const mod_js_2 = require("../agents/mod.js");
/**
 *
 * Huan(202111) Issue #158 - Refactoring the 'dirty' event, dirtyPayload(),
 *  and XXXPayloadDirty() methods logic & spec
 *
 *    @see https://github.com/wechaty/puppet/issues/158
 *
 */
const cacheMixin = (mixinBase) => {
    class CacheMixin extends mixinBase {
        cache;
        __cacheMixinCleanCallbackList;
        constructor(...args) {
            super(...args);
            config_js_1.log.verbose('PuppetCacheMixin', 'constructor(%s)', args[0]?.cache
                ? '{ cache: ' + JSON.stringify(args[0].cache) + ' }'
                : '');
            const options = args[0] || {};
            this.__cacheMixinCleanCallbackList = [];
            this.cache = new mod_js_2.CacheAgent(options.cache);
        }
        async start() {
            config_js_1.log.verbose('PuppetCacheMixin', 'start()');
            await super.start();
            this.cache.start();
            const onDirty = this.onDirty.bind(this);
            this.on('dirty', onDirty);
            config_js_1.log.verbose('PuppetCacheMixin', 'start() "dirty" event listener added');
            const cleanFn = () => {
                this.off('dirty', onDirty);
                config_js_1.log.verbose('PuppetCacheMixin', 'start() "dirty" event listener removed');
            };
            this.__cacheMixinCleanCallbackList.push(cleanFn);
        }
        async stop() {
            config_js_1.log.verbose('PuppetCacheMixin', 'stop()');
            this.cache.stop();
            this.__cacheMixinCleanCallbackList.map(setImmediate);
            this.__cacheMixinCleanCallbackList.length = 0;
            await super.stop();
        }
        /**
         *
         * @windmemory(202008): add dirty payload methods
         *
         *  @see https://github.com/wechaty/grpc/pull/79
         *
         * Call this method when you want to notify the server that the data cache need to be invalidated.
         */
        dirtyPayload(type, id) {
            config_js_1.log.verbose('PuppetCacheMixin', 'dirtyPayload(%s<%s>, %s)', mod_js_1.DirtyType[type], type, id);
            /**
             * Huan(202111): we return first before emit the `dirty` event?
             */
            setImmediate(() => this.emit('dirty', {
                payloadId: id,
                payloadType: type,
            }));
        }
        /**
         * OnDirty will be registered as a `dirty` event listener,
         *  and it will invalidate the cache.
         */
        onDirty({ payloadType, payloadId, }) {
            config_js_1.log.verbose('PuppetCacheMixin', 'onDirty(%s<%s>, %s)', mod_js_1.DirtyType[payloadType], payloadType, payloadId);
            const dirtyFuncMap = {
                [mod_js_1.DirtyType.Contact]: (id) => this.cache.contact.delete(id),
                [mod_js_1.DirtyType.Friendship]: (id) => this.cache.friendship.delete(id),
                [mod_js_1.DirtyType.Message]: (id) => this.cache.message.delete(id),
                [mod_js_1.DirtyType.Post]: (id) => this.cache.post.delete(id),
                [mod_js_1.DirtyType.Room]: (id) => this.cache.room.delete(id),
                [mod_js_1.DirtyType.RoomMember]: (id) => this.cache.roomMember.delete(id),
                [mod_js_1.DirtyType.Unspecified]: (id) => { throw new Error('Unspecified type with id: ' + id); },
            };
            const dirtyFunc = dirtyFuncMap[payloadType];
            dirtyFunc(payloadId);
        }
        /**
         * When we are using PuppetService, the `dirty` event will be emitted from the server,
         *  and we need to wait for the `dirty` event so we can make sure the cache has been invalidated.
         */
        async __dirtyPayloadAwait(type, id) {
            config_js_1.log.verbose('PuppetCacheMixin', '__dirtyPayloadAwait(%s<%s>, %s)', mod_js_1.DirtyType[type], type, id);
            if (!this.__currentUserId) {
                config_js_1.log.verbose('PuppetCacheMixin', '__dirtyPayloadAwait() will not dirty any payload when the puppet is not logged in');
                return;
            }
            const isCurrentDirtyEvent = (event) => event.payloadId === id && event.payloadType === type;
            const onDirtyResolve = (resolve) => {
                const onDirty = (event) => {
                    if (isCurrentDirtyEvent(event)) {
                        resolve();
                    }
                };
                return onDirty;
            };
            let onDirty;
            const future = new Promise(resolve => {
                onDirty = onDirtyResolve(resolve);
                this.on('dirty', onDirty);
            });
            /**
             * 1. call for sending the `dirty` event
             */
            this.dirtyPayload(type, id);
            /**
             * 2. wait for the `dirty` event arrive, with a 5 seconds timeout
             */
            try {
                await (0, gerror_1.timeoutPromise)(future, 5 * 1000)
                    .finally(() => this.off('dirty', onDirty));
            }
            catch (e) {
                // timeout, log warning & ignore it
                config_js_1.log.warn('PuppetCacheMixin', [
                    '__dirtyPayloadAwait() timeout.',
                    'The `dirty` event should be received but no one found.',
                    'Learn more from https://github.com/wechaty/puppet/issues/158',
                    'payloadType: %s(%s)',
                    'payloadId: %s',
                    'error: %s',
                    'stack: %s',
                ].join('\n  '), mod_js_1.DirtyType[type], type, id, e.message, e.stack);
            }
            /**
             * Huan(202111): wait for all the taks in the event loop queue to be executed
             *  before we return, because there might be other `onDirty` listeners
             */
            await new Promise(setImmediate);
        }
    }
    return CacheMixin;
};
exports.cacheMixin = cacheMixin;
//# sourceMappingURL=cache-mixin.js.map