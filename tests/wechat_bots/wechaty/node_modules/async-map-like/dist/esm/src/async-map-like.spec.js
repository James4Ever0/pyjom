#!/usr/bin/env -S node --no-warnings --loader ts-node/esm
import { test } from 'tstest';
test('AsyncMapLike Interface via object', async (t) => {
    const mapCollection = {
        clear: async () => { },
        delete: async (key) => { return !!key; },
        forEach: async (callbackfn, thisArg) => { void callbackfn; void thisArg; },
        get: async (_) => { },
        has: async (key) => !!key,
        set: async function (_, __) { return {}; },
        size: Promise.resolve(42),
    };
    const mapIterable = {
        entries: () => { return {}; },
        keys: () => { return {}; },
        values: () => { return {}; },
        [Symbol.asyncIterator]: () => { return {}; },
    };
    const mapLike = {
        ...mapCollection,
        ...mapIterable,
    };
    t.ok(mapLike, 'should be assign-able from ES6 Map to our MapLike');
});
test('AsyncMapLike Interface via class', async (t) => {
    class TestAsyncMapLike {
        constructor() { }
        /**
         * Collections
         */
        async clear() { }
        async delete(key) { return !!key; }
        async forEach(callbackfn, thisArg) { void callbackfn; void thisArg; }
        async get(key) { void key; return 42; }
        async has(key) { return !!key; }
        async set(key, value) { void key; void value; return this; }
        get size() { return Promise.resolve(42); }
        /**
         * Iterables
         */
        entries() { return {}; }
        keys() { return {}; }
        values() { return {}; }
        [Symbol.asyncIterator]() { return {}; }
    }
    const mapLike = new TestAsyncMapLike();
    t.ok(mapLike, 'should be implement-able from AsyncMapLike');
});
test('AsyncMapLike Interface via class generic', async (t) => {
    class TestAsyncMapLike {
        constructor() { }
        /**
         * Collections
         */
        async clear() { }
        async delete(key) { return !!key; }
        async forEach(callbackfn, thisArg) { void callbackfn; void thisArg; }
        async get(key) { void key; return 42; }
        async has(key) { return !!key; }
        async set(key, value) { void key; void value; return this; }
        get size() { return Promise.resolve(42); }
        /**
         * AsyncIterables
         */
        entries() { return {}; }
        keys() { return {}; }
        values() { return {}; }
        [Symbol.asyncIterator]() {
            return {
                [Symbol.asyncIterator]: this[Symbol.asyncIterator],
                next: () => Promise.resolve({ done: true, value: undefined }),
            };
        }
    }
    const mapLike = new TestAsyncMapLike();
    t.ok(mapLike, 'should be implement-able from AsyncMapLike');
    /**
     * Just check for the types
     */
    for await (const kv of mapLike) {
        void kv;
    }
});
//# sourceMappingURL=async-map-like.spec.js.map