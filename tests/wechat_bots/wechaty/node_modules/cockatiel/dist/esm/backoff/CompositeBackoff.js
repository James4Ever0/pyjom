/**
 * A backoff that combines two other backoffs. The delay will be the "bias"
 * (max or min) of the two other backoffs, and next() will return as along as
 * both backoffs continue to have next values as well.
 */
export class CompositeBackoff {
    constructor(bias, backoffA, backoffB) {
        this.bias = bias;
        this.backoffA = backoffA;
        this.backoffB = backoffB;
    }
    /**
     * @inheritdoc
     */
    next(context) {
        const nextA = this.backoffA.next(context);
        const nextB = this.backoffB.next(context);
        return nextA && nextB && instance(this.bias, nextA, nextB);
    }
}
const instance = (bias, backoffA, backoffB) => ({
    /**
     * @inheritdoc
     */
    get duration() {
        switch (bias) {
            case 'a':
                return backoffA.duration;
            case 'b':
                return backoffB.duration;
            case 'max':
                return Math.max(backoffB.duration, backoffA.duration);
            case 'min':
                return Math.min(backoffB.duration, backoffA.duration);
            default:
                throw new Error(`Unknown bias "${bias}" given to CompositeBackoff`);
        }
    },
    /**
     * @inheritdoc
     */
    next(context) {
        const nextA = backoffA.next(context);
        const nextB = backoffB.next(context);
        return nextA && nextB && instance(bias, nextA, nextB);
    },
});
//# sourceMappingURL=CompositeBackoff.js.map