"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.streamToBuffer = exports.httpStream = exports.httpHeaderToFileName = exports.httpHeadHeader = exports.dataUrlToBase64 = void 0;
const http_1 = __importDefault(require("http"));
const https_1 = __importDefault(require("https"));
const url_1 = __importDefault(require("url"));
function dataUrlToBase64(dataUrl) {
    const dataList = dataUrl.split(',');
    return dataList[dataList.length - 1];
}
exports.dataUrlToBase64 = dataUrlToBase64;
/**
 * Get http headers for specific `url`
 * follow 302 redirection for max `REDIRECT_TTL` times.
 *
 * @credit https://stackoverflow.com/a/43632171/1123955
 */
async function httpHeadHeader(url) {
    let REDIRECT_TTL = 7;
    while (true) {
        if (REDIRECT_TTL-- <= 0) {
            throw new Error(`ttl expired! too many(>${REDIRECT_TTL}) 302 redirection.`);
        }
        const res = await _headHeader(url);
        if (!/^3/.test(String(res.statusCode))) {
            return res.headers;
        }
        // console.log('302 found for ' + url)
        if (!res.headers.location) {
            throw new Error('302 found but no location!');
        }
        url = res.headers.location;
    }
    async function _headHeader(destUrl) {
        const parsedUrl = url_1.default.parse(destUrl);
        const options = {
            ...parsedUrl,
            method: 'HEAD',
            // method   : 'GET',
        };
        let request;
        if (parsedUrl.protocol === 'https:') {
            request = https_1.default.request;
        }
        else if (parsedUrl.protocol === 'http:') {
            request = http_1.default.request;
        }
        else {
            throw new Error('unknown protocol: ' + parsedUrl.protocol);
        }
        return new Promise((resolve, reject) => {
            request(options, resolve)
                .on('error', reject)
                .end();
        });
    }
}
exports.httpHeadHeader = httpHeadHeader;
function httpHeaderToFileName(headers) {
    const contentDisposition = headers['content-disposition'];
    if (!contentDisposition) {
        return null;
    }
    // 'content-disposition': 'attachment; filename=db-0.0.19.zip'
    const matches = contentDisposition.match(/attachment; filename="?(.+[^"])"?$/i);
    if (matches && matches[1]) {
        return matches[1];
    }
    return null;
}
exports.httpHeaderToFileName = httpHeaderToFileName;
async function httpStream(url, headers = {}) {
    /* eslint node/no-deprecated-api: off */
    // FIXME:
    const parsedUrl = url_1.default.parse(url);
    const protocol = parsedUrl.protocol;
    let options;
    let get;
    if (!protocol) {
        throw new Error('protocol is empty');
    }
    if (protocol.match(/^https:/i)) {
        get = https_1.default.get;
        options = parsedUrl;
        options.agent = https_1.default.globalAgent;
    }
    else if (protocol.match(/^http:/i)) {
        get = http_1.default.get;
        options = parsedUrl;
        options.agent = http_1.default.globalAgent;
    }
    else {
        throw new Error('protocol unknown: ' + protocol);
    }
    options.headers = {
        ...options.headers,
        ...headers,
    };
    const res = await new Promise((resolve, reject) => {
        get(options, resolve)
            .on('error', reject)
            .end();
    });
    return res;
}
exports.httpStream = httpStream;
async function streamToBuffer(stream) {
    return new Promise((resolve, reject) => {
        const bufferList = [];
        stream.once('error', reject);
        stream.once('end', () => {
            const fullBuffer = Buffer.concat(bufferList);
            resolve(fullBuffer);
        });
        stream.on('data', buffer => bufferList.push(buffer));
    });
}
exports.streamToBuffer = streamToBuffer;
//# sourceMappingURL=misc.js.map