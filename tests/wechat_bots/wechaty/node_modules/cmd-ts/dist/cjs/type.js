"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.extendType = exports.fromFn = exports.typeDef = exports.identity = void 0;
var from_1 = require("./from");
Object.defineProperty(exports, "identity", { enumerable: true, get: function () { return from_1.identity; } });
/**
 * Get the type definitions or an empty object from a type or a decoding function
 */
function typeDef(from) {
    if (typeof from === 'function') {
        return {};
    }
    else {
        return from;
    }
}
exports.typeDef = typeDef;
/**
 * Get the decoding function from a type or a function
 */
function fromFn(t) {
    if (typeof t === 'function') {
        return t;
    }
    else {
        return t.from;
    }
}
exports.fromFn = fromFn;
/**
 * Extend a type: take a type and use it as a base for another type. Much like using the spread operator:
 * ```
 * const newType = { ...oldType }
 * ```
 * but composes the `from` arguments
 *
 * @param base A base type from `InputA` to `OutputA`
 * @param nextTypeOrDecodingFunction Either an entire `Type<OutputA, AnyOutput>` or just a decoding function from `OutputA` to any type
 */
function extendType(base, nextTypeOrDecodingFunction) {
    const { defaultValue: _defaultValue, from: _from, ...t1WithoutDefault } = base;
    const t2Object = typeDef(nextTypeOrDecodingFunction);
    const t2From = fromFn(nextTypeOrDecodingFunction);
    return {
        ...t1WithoutDefault,
        ...t2Object,
        async from(a) {
            const f1Result = await base.from(a);
            return await t2From(f1Result);
        },
    };
}
exports.extendType = extendType;
//# sourceMappingURL=type.js.map