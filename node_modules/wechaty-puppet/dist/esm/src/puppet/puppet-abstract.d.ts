import type { PuppetOptions } from '../schemas/mod.js';
import { PuppetSkeleton } from './puppet-skeleton.js';
/**
 * Huan(202111): validateMixin can not put in the piped list,
 *  because it import-ed the `PuppetInterface` which is depended on `PuppetImpl`
 *  which caused circle-dependency.
 *
 * TODO: put `validateMixin` back in to piped list
 */
declare const MixinBase: ((abstract new (...args: any[]) => {
    readonly id: string;
    readonly options: PuppetOptions;
    wrapAsync: import("gerror/dist/esm/src/wrap-async-error/wrap-async-error.js").WrapAsync;
    start(): Promise<void>;
    stop(): Promise<void>;
    emit(event: any, ...args: any): boolean;
    addListener<E extends keyof import("./events.js").PuppetEventListener>(event: E, listener: import("./events.js").PuppetEventListener[E]): any;
    on<E_1 extends keyof import("./events.js").PuppetEventListener>(event: E_1, listener: import("./events.js").PuppetEventListener[E_1]): any;
    once<E_2 extends keyof import("./events.js").PuppetEventListener>(event: E_2, listener: import("./events.js").PuppetEventListener[E_2]): any;
    prependListener<E_3 extends keyof import("./events.js").PuppetEventListener>(event: E_3, listener: import("./events.js").PuppetEventListener[E_3]): any;
    prependOnceListener<E_4 extends keyof import("./events.js").PuppetEventListener>(event: E_4, listener: import("./events.js").PuppetEventListener[E_4]): any;
    off<E_5 extends keyof import("./events.js").PuppetEventListener>(event: E_5, listener: import("./events.js").PuppetEventListener[E_5]): any;
    removeAllListeners<E_6 extends keyof import("./events.js").PuppetEventListener>(event?: E_6 | undefined): any;
    removeListener<E_7 extends keyof import("./events.js").PuppetEventListener>(event: E_7, listener: import("./events.js").PuppetEventListener[E_7]): any;
    eventNames(): (string | symbol)[];
    rawListeners<E_8 extends keyof import("./events.js").PuppetEventListener>(event: E_8): Function[];
    listeners<E_9 extends keyof import("./events.js").PuppetEventListener>(event: E_9): Function[];
    listenerCount<E_10 extends keyof import("./events.js").PuppetEventListener>(event: E_10): number;
    getMaxListeners(): number;
    setMaxListeners(maxListeners: number): any;
    __events: import("./events.js").PuppetEventListener;
}) & {
    validInterface(target: any): target is import("./puppet-interface.js").PuppetInterface;
    validInstance(target: any): target is Puppet;
    valid(target: any): target is import("./puppet-interface.js").PuppetInterface;
}) & (abstract new (...args: any[]) => {
    tap(postId: string, type?: import("../schemas/tap.js").TapType | undefined, tap?: boolean | undefined): Promise<boolean | void>;
    tapSearch(postId: string, query?: import("../schemas/tap.js").TapQueryFilter | undefined, pagination?: import("../schemas/pagination.js").PaginationRequest | undefined): Promise<import("../schemas/pagination.js").PaginationResponse<import("../schemas/tap.js").TapPayload>>;
    readonly id: string;
    readonly options: PuppetOptions;
    wrapAsync: import("gerror/dist/esm/src/wrap-async-error/wrap-async-error.js").WrapAsync;
    start: (() => Promise<void>) & (() => Promise<void>) & (() => Promise<void>);
    stop: (() => Promise<void>) & (() => Promise<void>) & (() => Promise<void>);
    emit(event: any, ...args: any): boolean;
    addListener<E_11 extends keyof import("./events.js").PuppetEventListener>(event: E_11, listener: import("./events.js").PuppetEventListener[E_11]): any;
    on<E_12 extends keyof import("./events.js").PuppetEventListener>(event: E_12, listener: import("./events.js").PuppetEventListener[E_12]): any;
    once<E_13 extends keyof import("./events.js").PuppetEventListener>(event: E_13, listener: import("./events.js").PuppetEventListener[E_13]): any;
    prependListener<E_14 extends keyof import("./events.js").PuppetEventListener>(event: E_14, listener: import("./events.js").PuppetEventListener[E_14]): any;
    prependOnceListener<E_15 extends keyof import("./events.js").PuppetEventListener>(event: E_15, listener: import("./events.js").PuppetEventListener[E_15]): any;
    off<E_16 extends keyof import("./events.js").PuppetEventListener>(event: E_16, listener: import("./events.js").PuppetEventListener[E_16]): any;
    removeAllListeners<E_17 extends keyof import("./events.js").PuppetEventListener>(event?: E_17 | undefined): any;
    removeListener<E_18 extends keyof import("./events.js").PuppetEventListener>(event: E_18, listener: import("./events.js").PuppetEventListener[E_18]): any;
    eventNames(): (string | symbol)[];
    rawListeners<E_8 extends keyof import("./events.js").PuppetEventListener>(event: E_8): Function[];
    listeners<E_9 extends keyof import("./events.js").PuppetEventListener>(event: E_9): Function[];
    listenerCount<E_10 extends keyof import("./events.js").PuppetEventListener>(event: E_10): number;
    getMaxListeners(): number;
    setMaxListeners(maxListeners: number): any;
    __events: import("./events.js").PuppetEventListener;
    cache: import("../agents/cache-agent.js").CacheAgent;
    __cacheMixinCleanCallbackList: (() => void)[];
    dirtyPayload(type: import("../schemas/dirty.js").DirtyType, id: string): void;
    onDirty({ payloadType, payloadId, }: import("../schemas/event.js").EventDirtyPayload): void;
    __dirtyPayloadAwait(type: import("../schemas/dirty.js").DirtyType, id: string): Promise<void>;
    __currentUserId?: string | undefined;
    readonly currentUserId: string;
    readonly isLoggedIn: boolean;
    __authQrCode?: string | undefined;
    readonly authQrCode: string | undefined;
    login(userId: string): void;
    logout(reason?: string): Promise<void>;
    selfId(): string;
    logonoff(): boolean;
}) & (abstract new (...args: any[]) => {
    sayablePayload(sayableId: string): Promise<import("../schemas/sayable.js").SayablePayload | undefined>;
    readonly id: string;
    readonly options: PuppetOptions;
    wrapAsync: import("gerror/dist/esm/src/wrap-async-error/wrap-async-error.js").WrapAsync;
    start: (() => Promise<void>) & (() => Promise<void>) & (() => Promise<void>);
    stop: (() => Promise<void>) & (() => Promise<void>) & (() => Promise<void>);
    emit(event: any, ...args: any): boolean;
    addListener<E_19 extends keyof import("./events.js").PuppetEventListener>(event: E_19, listener: import("./events.js").PuppetEventListener[E_19]): any;
    on<E_20 extends keyof import("./events.js").PuppetEventListener>(event: E_20, listener: import("./events.js").PuppetEventListener[E_20]): any;
    once<E_21 extends keyof import("./events.js").PuppetEventListener>(event: E_21, listener: import("./events.js").PuppetEventListener[E_21]): any;
    prependListener<E_22 extends keyof import("./events.js").PuppetEventListener>(event: E_22, listener: import("./events.js").PuppetEventListener[E_22]): any;
    prependOnceListener<E_23 extends keyof import("./events.js").PuppetEventListener>(event: E_23, listener: import("./events.js").PuppetEventListener[E_23]): any;
    off<E_24 extends keyof import("./events.js").PuppetEventListener>(event: E_24, listener: import("./events.js").PuppetEventListener[E_24]): any;
    removeAllListeners<E_25 extends keyof import("./events.js").PuppetEventListener>(event?: E_25 | undefined): any;
    removeListener<E_26 extends keyof import("./events.js").PuppetEventListener>(event: E_26, listener: import("./events.js").PuppetEventListener[E_26]): any;
    eventNames(): (string | symbol)[];
    rawListeners<E_8 extends keyof import("./events.js").PuppetEventListener>(event: E_8): Function[];
    listeners<E_9 extends keyof import("./events.js").PuppetEventListener>(event: E_9): Function[];
    listenerCount<E_10 extends keyof import("./events.js").PuppetEventListener>(event: E_10): number;
    getMaxListeners(): number;
    setMaxListeners(maxListeners: number): any;
    __events: import("./events.js").PuppetEventListener;
    conversationReadMark(conversationId: string, hasRead?: boolean | undefined): Promise<boolean | void>;
    messageContact(messageId: string): Promise<string>;
    messageFile(messageId: string): Promise<import("file-box/dist/esm/src/interface.js").FileBoxInterface>;
    messageImage(messageId: string, imageType: import("../schemas/image.js").ImageType): Promise<import("file-box/dist/esm/src/interface.js").FileBoxInterface>;
    messageMiniProgram(messageId: string): Promise<import("../schemas/mini-program.js").MiniProgramPayload>;
    messageUrl(messageId: string): Promise<import("../schemas/url-link.js").UrlLinkPayload>;
    messageLocation(messageId: string): Promise<import("../schemas/location.js").LocationPayload>;
    messageForward(conversationId: string, messageId: string): Promise<string | void>;
    messageSendContact(conversationId: string, contactId: string): Promise<string | void>;
    messageSendFile(conversationId: string, file: import("file-box/dist/esm/src/interface.js").FileBoxInterface): Promise<string | void>;
    messageSendLocation(conversationId: string, locationPayload: import("../schemas/location.js").LocationPayload): Promise<string | void>;
    messageSendMiniProgram(conversationId: string, miniProgramPayload: import("../schemas/mini-program.js").MiniProgramPayload): Promise<string | void>;
    messageSendPost(conversationId: string, postPayload: import("../schemas/post.js").PostPayload): Promise<string | void>;
    messageSendText(conversationId: string, text: string, mentionIdList?: string[] | undefined): Promise<string | void>;
    messageSendUrl(conversationId: string, urlLinkPayload: import("../schemas/url-link.js").UrlLinkPayload): Promise<string | void>;
    messageRecall(messageId: string): Promise<boolean>;
    messageRawPayload(messageId: string): Promise<any>;
    messageRawPayloadParser(rawPayload: any): Promise<import("../schemas/message.js").MessagePayload>;
    messagePayloadCache(messageId: string): import("../schemas/message.js").MessagePayload | undefined;
    messagePayload(messageId: string): Promise<import("../schemas/message.js").MessagePayload>;
    messageList(): string[];
    messageSearch(query?: import("../schemas/message.js").MessageQueryFilter | undefined): Promise<string[]>;
    messageQueryFilterFactory(query: import("../schemas/message.js").MessageQueryFilter): import("../schemas/message.js").MessagePayloadFilterFunction;
    messagePayloadDirty(id: string): Promise<void>;
    messageSend(conversationId: string, sayable: import("../schemas/sayable.js").SayablePayload): Promise<string | void>;
    cache: import("../agents/cache-agent.js").CacheAgent;
    __cacheMixinCleanCallbackList: (() => void)[];
    dirtyPayload(type: import("../schemas/dirty.js").DirtyType, id: string): void;
    onDirty({ payloadType, payloadId, }: import("../schemas/event.js").EventDirtyPayload): void;
    __dirtyPayloadAwait(type: import("../schemas/dirty.js").DirtyType, id: string): Promise<void>;
    __currentUserId?: string | undefined;
    readonly currentUserId: string;
    readonly isLoggedIn: boolean;
    __authQrCode?: string | undefined;
    readonly authQrCode: string | undefined;
    login(userId: string): void;
    logout(reason?: string): Promise<void>;
    selfId(): string;
    logonoff(): boolean;
    postRawPayload(postId: string): Promise<any>;
    postRawPayloadParser(rawPayload: any): Promise<import("../schemas/post.js").PostPayload>;
    postPayloadCache(postId: string): import("../schemas/post.js").PostPayload | undefined;
    postPayload(postId: string): Promise<import("../schemas/post.js").PostPayload>;
    postPublish(payload: import("../schemas/post.js").PostPayload): Promise<string | void>;
    postSearch(filter: import("../schemas/post.js").PostQueryFilter, pagination?: import("../schemas/pagination.js").PaginationRequest | undefined): Promise<import("../schemas/pagination.js").PaginationResponse<string[]>>;
    postList(): string[];
    postPayloadDirty(id: string): Promise<void>;
}) & (abstract new (...args: any[]) => {
    postRawPayload(postId: string): Promise<any>;
    postRawPayloadParser(rawPayload: any): Promise<import("../schemas/post.js").PostPayload>;
    postPayloadCache(postId: string): import("../schemas/post.js").PostPayload | undefined;
    postPayload(postId: string): Promise<import("../schemas/post.js").PostPayload>;
    postPublish(payload: import("../schemas/post.js").PostPayload): Promise<string | void>;
    postSearch(filter: import("../schemas/post.js").PostQueryFilter, pagination?: import("../schemas/pagination.js").PaginationRequest | undefined): Promise<import("../schemas/pagination.js").PaginationResponse<string[]>>;
    postList(): string[];
    postPayloadDirty(id: string): Promise<void>;
    readonly id: string;
    readonly options: PuppetOptions;
    wrapAsync: import("gerror/dist/esm/src/wrap-async-error/wrap-async-error.js").WrapAsync;
    start: (() => Promise<void>) & (() => Promise<void>) & (() => Promise<void>);
    stop: (() => Promise<void>) & (() => Promise<void>) & (() => Promise<void>);
    emit(event: any, ...args: any): boolean;
    addListener<E_27 extends keyof import("./events.js").PuppetEventListener>(event: E_27, listener: import("./events.js").PuppetEventListener[E_27]): any;
    on<E_28 extends keyof import("./events.js").PuppetEventListener>(event: E_28, listener: import("./events.js").PuppetEventListener[E_28]): any;
    once<E_29 extends keyof import("./events.js").PuppetEventListener>(event: E_29, listener: import("./events.js").PuppetEventListener[E_29]): any;
    prependListener<E_30 extends keyof import("./events.js").PuppetEventListener>(event: E_30, listener: import("./events.js").PuppetEventListener[E_30]): any;
    prependOnceListener<E_31 extends keyof import("./events.js").PuppetEventListener>(event: E_31, listener: import("./events.js").PuppetEventListener[E_31]): any;
    off<E_32 extends keyof import("./events.js").PuppetEventListener>(event: E_32, listener: import("./events.js").PuppetEventListener[E_32]): any;
    removeAllListeners<E_33 extends keyof import("./events.js").PuppetEventListener>(event?: E_33 | undefined): any;
    removeListener<E_34 extends keyof import("./events.js").PuppetEventListener>(event: E_34, listener: import("./events.js").PuppetEventListener[E_34]): any;
    eventNames(): (string | symbol)[];
    rawListeners<E_8 extends keyof import("./events.js").PuppetEventListener>(event: E_8): Function[];
    listeners<E_9 extends keyof import("./events.js").PuppetEventListener>(event: E_9): Function[];
    listenerCount<E_10 extends keyof import("./events.js").PuppetEventListener>(event: E_10): number;
    getMaxListeners(): number;
    setMaxListeners(maxListeners: number): any;
    __events: import("./events.js").PuppetEventListener;
    cache: import("../agents/cache-agent.js").CacheAgent;
    __cacheMixinCleanCallbackList: (() => void)[];
    dirtyPayload(type: import("../schemas/dirty.js").DirtyType, id: string): void;
    onDirty({ payloadType, payloadId, }: import("../schemas/event.js").EventDirtyPayload): void;
    __dirtyPayloadAwait(type: import("../schemas/dirty.js").DirtyType, id: string): Promise<void>;
    __currentUserId?: string | undefined;
    readonly currentUserId: string;
    readonly isLoggedIn: boolean;
    __authQrCode?: string | undefined;
    readonly authQrCode: string | undefined;
    login(userId: string): void;
    logout(reason?: string): Promise<void>;
    selfId(): string;
    logonoff(): boolean;
}) & (abstract new (...args: any[]) => {
    readyIndicator: import("state-switch/dist/esm/src/boolean-indicator.js").BooleanIndicator;
    start(): Promise<void>;
    stop(): Promise<void>;
    readonly id: string;
    readonly options: PuppetOptions;
    wrapAsync: import("gerror/dist/esm/src/wrap-async-error/wrap-async-error.js").WrapAsync;
    emit(event: any, ...args: any): boolean;
    addListener<E_35 extends keyof import("./events.js").PuppetEventListener>(event: E_35, listener: import("./events.js").PuppetEventListener[E_35]): any;
    on<E_36 extends keyof import("./events.js").PuppetEventListener>(event: E_36, listener: import("./events.js").PuppetEventListener[E_36]): any;
    once<E_37 extends keyof import("./events.js").PuppetEventListener>(event: E_37, listener: import("./events.js").PuppetEventListener[E_37]): any;
    prependListener<E_38 extends keyof import("./events.js").PuppetEventListener>(event: E_38, listener: import("./events.js").PuppetEventListener[E_38]): any;
    prependOnceListener<E_39 extends keyof import("./events.js").PuppetEventListener>(event: E_39, listener: import("./events.js").PuppetEventListener[E_39]): any;
    off<E_40 extends keyof import("./events.js").PuppetEventListener>(event: E_40, listener: import("./events.js").PuppetEventListener[E_40]): any;
    removeAllListeners<E_41 extends keyof import("./events.js").PuppetEventListener>(event?: E_41 | undefined): any;
    removeListener<E_42 extends keyof import("./events.js").PuppetEventListener>(event: E_42, listener: import("./events.js").PuppetEventListener[E_42]): any;
    eventNames(): (string | symbol)[];
    rawListeners<E_8 extends keyof import("./events.js").PuppetEventListener>(event: E_8): Function[];
    listeners<E_9 extends keyof import("./events.js").PuppetEventListener>(event: E_9): Function[];
    listenerCount<E_10 extends keyof import("./events.js").PuppetEventListener>(event: E_10): number;
    getMaxListeners(): number;
    setMaxListeners(maxListeners: number): any;
    __events: import("./events.js").PuppetEventListener;
}) & ((abstract new (...args: any[]) => {
    readonly __counter: number;
    readonly __watchdog: import("../agents/watchdog-agent.js").WatchdogAgent;
    start(): Promise<void>;
    stop(): Promise<void>;
    state: import("state-switch/dist/esm/src/interfaces.js").StateSwitchInterface;
    __serviceCtlResettingIndicator: import("state-switch/dist/esm/src/busy-indicator.js").BusyIndicator;
    __serviceCtlLogger: import("brolog/dist/esm/src/logger.js").Loggable;
    reset(): Promise<void>;
    onStart(): Promise<void>;
    onStop(): Promise<void>;
    emit: ((..._: any[]) => any) & ((event: any, ...args: any) => boolean);
    readonly id: string;
    readonly options: PuppetOptions;
    wrapAsync: import("gerror/dist/esm/src/wrap-async-error/wrap-async-error.js").WrapAsync;
    addListener<E_43 extends keyof import("./events.js").PuppetEventListener>(event: E_43, listener: import("./events.js").PuppetEventListener[E_43]): any;
    on<E_44 extends keyof import("./events.js").PuppetEventListener>(event: E_44, listener: import("./events.js").PuppetEventListener[E_44]): any;
    once<E_45 extends keyof import("./events.js").PuppetEventListener>(event: E_45, listener: import("./events.js").PuppetEventListener[E_45]): any;
    prependListener<E_46 extends keyof import("./events.js").PuppetEventListener>(event: E_46, listener: import("./events.js").PuppetEventListener[E_46]): any;
    prependOnceListener<E_47 extends keyof import("./events.js").PuppetEventListener>(event: E_47, listener: import("./events.js").PuppetEventListener[E_47]): any;
    off<E_48 extends keyof import("./events.js").PuppetEventListener>(event: E_48, listener: import("./events.js").PuppetEventListener[E_48]): any;
    removeAllListeners<E_49 extends keyof import("./events.js").PuppetEventListener>(event?: E_49 | undefined): any;
    removeListener<E_50 extends keyof import("./events.js").PuppetEventListener>(event: E_50, listener: import("./events.js").PuppetEventListener[E_50]): any;
    eventNames(): (string | symbol)[];
    rawListeners<E_8 extends keyof import("./events.js").PuppetEventListener>(event: E_8): Function[];
    listeners<E_9 extends keyof import("./events.js").PuppetEventListener>(event: E_9): Function[];
    listenerCount<E_10 extends keyof import("./events.js").PuppetEventListener>(event: E_10): number;
    getMaxListeners(): number;
    setMaxListeners(maxListeners: number): any;
    __events: import("./events.js").PuppetEventListener;
}) & {
    VERSION: string;
}) & (abstract new (...args: any[]) => {
    toString(): string;
    ding(data?: string | undefined): void;
    name(): string;
    version(): string;
    wechatyVersionRange(strict?: boolean): string;
    readonly id: string;
    readonly options: PuppetOptions;
    wrapAsync: import("gerror/dist/esm/src/wrap-async-error/wrap-async-error.js").WrapAsync;
    start: (() => Promise<void>) & (() => Promise<void>);
    stop: (() => Promise<void>) & (() => Promise<void>);
    emit(event: any, ...args: any): boolean;
    addListener<E_51 extends keyof import("./events.js").PuppetEventListener>(event: E_51, listener: import("./events.js").PuppetEventListener[E_51]): any;
    on<E_52 extends keyof import("./events.js").PuppetEventListener>(event: E_52, listener: import("./events.js").PuppetEventListener[E_52]): any;
    once<E_53 extends keyof import("./events.js").PuppetEventListener>(event: E_53, listener: import("./events.js").PuppetEventListener[E_53]): any;
    prependListener<E_54 extends keyof import("./events.js").PuppetEventListener>(event: E_54, listener: import("./events.js").PuppetEventListener[E_54]): any;
    prependOnceListener<E_55 extends keyof import("./events.js").PuppetEventListener>(event: E_55, listener: import("./events.js").PuppetEventListener[E_55]): any;
    off<E_56 extends keyof import("./events.js").PuppetEventListener>(event: E_56, listener: import("./events.js").PuppetEventListener[E_56]): any;
    removeAllListeners<E_57 extends keyof import("./events.js").PuppetEventListener>(event?: E_57 | undefined): any;
    removeListener<E_58 extends keyof import("./events.js").PuppetEventListener>(event: E_58, listener: import("./events.js").PuppetEventListener[E_58]): any;
    eventNames(): (string | symbol)[];
    rawListeners<E_8 extends keyof import("./events.js").PuppetEventListener>(event: E_8): Function[];
    listeners<E_9 extends keyof import("./events.js").PuppetEventListener>(event: E_9): Function[];
    listenerCount<E_10 extends keyof import("./events.js").PuppetEventListener>(event: E_10): number;
    getMaxListeners(): number;
    setMaxListeners(maxListeners: number): any;
    __events: import("./events.js").PuppetEventListener;
    _memory: import("memory-card/dist/esm/src/memory-card.js").MemoryCard;
    readonly memory: import("memory-card/dist/esm/src/memory-card.js").MemoryCard;
    setMemory(memory: import("memory-card/dist/esm/src/memory-card.js").MemoryCard): void;
}) & (abstract new (...args: any[]) => {
    conversationReadMark(conversationId: string, hasRead?: boolean | undefined): Promise<boolean | void>;
    messageContact(messageId: string): Promise<string>;
    messageFile(messageId: string): Promise<import("file-box/dist/esm/src/interface.js").FileBoxInterface>;
    messageImage(messageId: string, imageType: import("../schemas/image.js").ImageType): Promise<import("file-box/dist/esm/src/interface.js").FileBoxInterface>;
    messageMiniProgram(messageId: string): Promise<import("../schemas/mini-program.js").MiniProgramPayload>;
    messageUrl(messageId: string): Promise<import("../schemas/url-link.js").UrlLinkPayload>;
    messageLocation(messageId: string): Promise<import("../schemas/location.js").LocationPayload>;
    messageForward(conversationId: string, messageId: string): Promise<string | void>;
    messageSendContact(conversationId: string, contactId: string): Promise<string | void>;
    messageSendFile(conversationId: string, file: import("file-box/dist/esm/src/interface.js").FileBoxInterface): Promise<string | void>;
    messageSendLocation(conversationId: string, locationPayload: import("../schemas/location.js").LocationPayload): Promise<string | void>;
    messageSendMiniProgram(conversationId: string, miniProgramPayload: import("../schemas/mini-program.js").MiniProgramPayload): Promise<string | void>;
    messageSendPost(conversationId: string, postPayload: import("../schemas/post.js").PostPayload): Promise<string | void>;
    messageSendText(conversationId: string, text: string, mentionIdList?: string[] | undefined): Promise<string | void>;
    messageSendUrl(conversationId: string, urlLinkPayload: import("../schemas/url-link.js").UrlLinkPayload): Promise<string | void>;
    messageRecall(messageId: string): Promise<boolean>;
    messageRawPayload(messageId: string): Promise<any>;
    messageRawPayloadParser(rawPayload: any): Promise<import("../schemas/message.js").MessagePayload>;
    messagePayloadCache(messageId: string): import("../schemas/message.js").MessagePayload | undefined;
    messagePayload(messageId: string): Promise<import("../schemas/message.js").MessagePayload>;
    messageList(): string[];
    messageSearch(query?: import("../schemas/message.js").MessageQueryFilter | undefined): Promise<string[]>;
    messageQueryFilterFactory(query: import("../schemas/message.js").MessageQueryFilter): import("../schemas/message.js").MessagePayloadFilterFunction;
    messagePayloadDirty(id: string): Promise<void>;
    messageSend(conversationId: string, sayable: import("../schemas/sayable.js").SayablePayload): Promise<string | void>;
    readonly id: string;
    readonly options: PuppetOptions;
    wrapAsync: import("gerror/dist/esm/src/wrap-async-error/wrap-async-error.js").WrapAsync;
    start: (() => Promise<void>) & (() => Promise<void>) & (() => Promise<void>);
    stop: (() => Promise<void>) & (() => Promise<void>) & (() => Promise<void>);
    emit(event: any, ...args: any): boolean;
    addListener<E_59 extends keyof import("./events.js").PuppetEventListener>(event: E_59, listener: import("./events.js").PuppetEventListener[E_59]): any;
    on<E_60 extends keyof import("./events.js").PuppetEventListener>(event: E_60, listener: import("./events.js").PuppetEventListener[E_60]): any;
    once<E_61 extends keyof import("./events.js").PuppetEventListener>(event: E_61, listener: import("./events.js").PuppetEventListener[E_61]): any;
    prependListener<E_62 extends keyof import("./events.js").PuppetEventListener>(event: E_62, listener: import("./events.js").PuppetEventListener[E_62]): any;
    prependOnceListener<E_63 extends keyof import("./events.js").PuppetEventListener>(event: E_63, listener: import("./events.js").PuppetEventListener[E_63]): any;
    off<E_64 extends keyof import("./events.js").PuppetEventListener>(event: E_64, listener: import("./events.js").PuppetEventListener[E_64]): any;
    removeAllListeners<E_65 extends keyof import("./events.js").PuppetEventListener>(event?: E_65 | undefined): any;
    removeListener<E_66 extends keyof import("./events.js").PuppetEventListener>(event: E_66, listener: import("./events.js").PuppetEventListener[E_66]): any;
    eventNames(): (string | symbol)[];
    rawListeners<E_8 extends keyof import("./events.js").PuppetEventListener>(event: E_8): Function[];
    listeners<E_9 extends keyof import("./events.js").PuppetEventListener>(event: E_9): Function[];
    listenerCount<E_10 extends keyof import("./events.js").PuppetEventListener>(event: E_10): number;
    getMaxListeners(): number;
    setMaxListeners(maxListeners: number): any;
    __events: import("./events.js").PuppetEventListener;
    cache: import("../agents/cache-agent.js").CacheAgent;
    __cacheMixinCleanCallbackList: (() => void)[];
    dirtyPayload(type: import("../schemas/dirty.js").DirtyType, id: string): void;
    onDirty({ payloadType, payloadId, }: import("../schemas/event.js").EventDirtyPayload): void;
    __dirtyPayloadAwait(type: import("../schemas/dirty.js").DirtyType, id: string): Promise<void>;
    __currentUserId?: string | undefined;
    readonly currentUserId: string;
    readonly isLoggedIn: boolean;
    __authQrCode?: string | undefined;
    readonly authQrCode: string | undefined;
    login(userId: string): void;
    logout(reason?: string): Promise<void>;
    selfId(): string;
    logonoff(): boolean;
}) & (abstract new (...args: any[]) => {
    roomInvitationPayloadCache(roomInvitationId: string): import("../schemas/room-invitation.js").RoomInvitationPayload | undefined;
    roomInvitationAccept(roomInvitationId: string): Promise<void>;
    roomInvitationRawPayload(roomInvitationId: string): Promise<any>;
    roomInvitationRawPayloadParser(rawPayload: any): Promise<import("../schemas/room-invitation.js").RoomInvitationPayload>;
    roomInvitationPayload(roomInvitationId: string): Promise<import("../schemas/room-invitation.js").RoomInvitationPayload>;
    roomInvitationPayload(roomInvitationId: string, newPayload: import("../schemas/room-invitation.js").RoomInvitationPayload): Promise<void>;
    readonly id: string;
    readonly options: PuppetOptions;
    wrapAsync: import("gerror/dist/esm/src/wrap-async-error/wrap-async-error.js").WrapAsync;
    start: (() => Promise<void>) & (() => Promise<void>) & (() => Promise<void>);
    stop: (() => Promise<void>) & (() => Promise<void>) & (() => Promise<void>);
    emit(event: any, ...args: any): boolean;
    addListener<E_67 extends keyof import("./events.js").PuppetEventListener>(event: E_67, listener: import("./events.js").PuppetEventListener[E_67]): any;
    on<E_68 extends keyof import("./events.js").PuppetEventListener>(event: E_68, listener: import("./events.js").PuppetEventListener[E_68]): any;
    once<E_69 extends keyof import("./events.js").PuppetEventListener>(event: E_69, listener: import("./events.js").PuppetEventListener[E_69]): any;
    prependListener<E_70 extends keyof import("./events.js").PuppetEventListener>(event: E_70, listener: import("./events.js").PuppetEventListener[E_70]): any;
    prependOnceListener<E_71 extends keyof import("./events.js").PuppetEventListener>(event: E_71, listener: import("./events.js").PuppetEventListener[E_71]): any;
    off<E_72 extends keyof import("./events.js").PuppetEventListener>(event: E_72, listener: import("./events.js").PuppetEventListener[E_72]): any;
    removeAllListeners<E_73 extends keyof import("./events.js").PuppetEventListener>(event?: E_73 | undefined): any;
    removeListener<E_74 extends keyof import("./events.js").PuppetEventListener>(event: E_74, listener: import("./events.js").PuppetEventListener[E_74]): any;
    eventNames(): (string | symbol)[];
    rawListeners<E_8 extends keyof import("./events.js").PuppetEventListener>(event: E_8): Function[];
    listeners<E_9 extends keyof import("./events.js").PuppetEventListener>(event: E_9): Function[];
    listenerCount<E_10 extends keyof import("./events.js").PuppetEventListener>(event: E_10): number;
    getMaxListeners(): number;
    setMaxListeners(maxListeners: number): any;
    __events: import("./events.js").PuppetEventListener;
    cache: import("../agents/cache-agent.js").CacheAgent;
    __cacheMixinCleanCallbackList: (() => void)[];
    dirtyPayload(type: import("../schemas/dirty.js").DirtyType, id: string): void;
    onDirty({ payloadType, payloadId, }: import("../schemas/event.js").EventDirtyPayload): void;
    __dirtyPayloadAwait(type: import("../schemas/dirty.js").DirtyType, id: string): Promise<void>;
    __currentUserId?: string | undefined;
    readonly currentUserId: string;
    readonly isLoggedIn: boolean;
    __authQrCode?: string | undefined;
    readonly authQrCode: string | undefined;
    login(userId: string): void;
    logout(reason?: string): Promise<void>;
    selfId(): string;
    logonoff(): boolean;
}) & (abstract new (...args: any[]) => {
    tagContactAdd(tagId: string, contactId: string): Promise<void>;
    tagContactDelete(tagId: string): Promise<void>;
    tagContactList(contactId: string): Promise<string[]>;
    tagContactList(): Promise<string[]>;
    tagContactRemove(tagId: string, contactId: string): Promise<void>;
    readonly id: string;
    readonly options: PuppetOptions;
    wrapAsync: import("gerror/dist/esm/src/wrap-async-error/wrap-async-error.js").WrapAsync;
    start(): Promise<void>;
    stop(): Promise<void>;
    emit(event: any, ...args: any): boolean;
    addListener<E_75 extends keyof import("./events.js").PuppetEventListener>(event: E_75, listener: import("./events.js").PuppetEventListener[E_75]): any;
    on<E_76 extends keyof import("./events.js").PuppetEventListener>(event: E_76, listener: import("./events.js").PuppetEventListener[E_76]): any;
    once<E_77 extends keyof import("./events.js").PuppetEventListener>(event: E_77, listener: import("./events.js").PuppetEventListener[E_77]): any;
    prependListener<E_78 extends keyof import("./events.js").PuppetEventListener>(event: E_78, listener: import("./events.js").PuppetEventListener[E_78]): any;
    prependOnceListener<E_79 extends keyof import("./events.js").PuppetEventListener>(event: E_79, listener: import("./events.js").PuppetEventListener[E_79]): any;
    off<E_80 extends keyof import("./events.js").PuppetEventListener>(event: E_80, listener: import("./events.js").PuppetEventListener[E_80]): any;
    removeAllListeners<E_81 extends keyof import("./events.js").PuppetEventListener>(event?: E_81 | undefined): any;
    removeListener<E_82 extends keyof import("./events.js").PuppetEventListener>(event: E_82, listener: import("./events.js").PuppetEventListener[E_82]): any;
    eventNames(): (string | symbol)[];
    rawListeners<E_8 extends keyof import("./events.js").PuppetEventListener>(event: E_8): Function[];
    listeners<E_9 extends keyof import("./events.js").PuppetEventListener>(event: E_9): Function[];
    listenerCount<E_10 extends keyof import("./events.js").PuppetEventListener>(event: E_10): number;
    getMaxListeners(): number;
    setMaxListeners(maxListeners: number): any;
    __events: import("./events.js").PuppetEventListener;
}) & (abstract new (...args: any[]) => {
    friendshipAccept(friendshipId: string): Promise<void>;
    friendshipAdd(contactId: string, option?: import("../schemas/friendship.js").FriendshipAddOptions | undefined): Promise<void>;
    friendshipSearchPhone(phone: string): Promise<string | null>;
    friendshipSearchHandle(handle: string): Promise<string | null>;
    friendshipSearchWeixin(weixin: string): Promise<string | null>;
    friendshipRawPayload(friendshipId: string): Promise<any>;
    friendshipRawPayloadParser(rawPayload: any): Promise<import("../schemas/friendship.js").FriendshipPayload>;
    friendshipSearch(searchQueryFilter: import("../schemas/friendship.js").FriendshipSearchQueryFilter): Promise<string | null>;
    friendshipPayloadCache(friendshipId: string): import("../schemas/friendship.js").FriendshipPayload | undefined;
    friendshipPayload(friendshipId: string): Promise<import("../schemas/friendship.js").FriendshipPayload>;
    friendshipPayload(friendshipId: string, newPayload: import("../schemas/friendship.js").FriendshipPayload): Promise<void>;
    friendshipPayloadDirty(id: string): Promise<void>;
    readonly id: string;
    readonly options: PuppetOptions;
    wrapAsync: import("gerror/dist/esm/src/wrap-async-error/wrap-async-error.js").WrapAsync;
    start: (() => Promise<void>) & (() => Promise<void>) & (() => Promise<void>);
    stop: (() => Promise<void>) & (() => Promise<void>) & (() => Promise<void>);
    emit(event: any, ...args: any): boolean;
    addListener<E_83 extends keyof import("./events.js").PuppetEventListener>(event: E_83, listener: import("./events.js").PuppetEventListener[E_83]): any;
    on<E_84 extends keyof import("./events.js").PuppetEventListener>(event: E_84, listener: import("./events.js").PuppetEventListener[E_84]): any;
    once<E_85 extends keyof import("./events.js").PuppetEventListener>(event: E_85, listener: import("./events.js").PuppetEventListener[E_85]): any;
    prependListener<E_86 extends keyof import("./events.js").PuppetEventListener>(event: E_86, listener: import("./events.js").PuppetEventListener[E_86]): any;
    prependOnceListener<E_87 extends keyof import("./events.js").PuppetEventListener>(event: E_87, listener: import("./events.js").PuppetEventListener[E_87]): any;
    off<E_88 extends keyof import("./events.js").PuppetEventListener>(event: E_88, listener: import("./events.js").PuppetEventListener[E_88]): any;
    removeAllListeners<E_89 extends keyof import("./events.js").PuppetEventListener>(event?: E_89 | undefined): any;
    removeListener<E_90 extends keyof import("./events.js").PuppetEventListener>(event: E_90, listener: import("./events.js").PuppetEventListener[E_90]): any;
    eventNames(): (string | symbol)[];
    rawListeners<E_8 extends keyof import("./events.js").PuppetEventListener>(event: E_8): Function[];
    listeners<E_9 extends keyof import("./events.js").PuppetEventListener>(event: E_9): Function[];
    listenerCount<E_10 extends keyof import("./events.js").PuppetEventListener>(event: E_10): number;
    getMaxListeners(): number;
    setMaxListeners(maxListeners: number): any;
    __events: import("./events.js").PuppetEventListener;
    cache: import("../agents/cache-agent.js").CacheAgent;
    __cacheMixinCleanCallbackList: (() => void)[];
    dirtyPayload(type: import("../schemas/dirty.js").DirtyType, id: string): void;
    onDirty({ payloadType, payloadId, }: import("../schemas/event.js").EventDirtyPayload): void;
    __dirtyPayloadAwait(type: import("../schemas/dirty.js").DirtyType, id: string): Promise<void>;
    __currentUserId?: string | undefined;
    readonly currentUserId: string;
    readonly isLoggedIn: boolean;
    __authQrCode?: string | undefined;
    readonly authQrCode: string | undefined;
    login(userId: string): void;
    logout(reason?: string): Promise<void>;
    selfId(): string;
    logonoff(): boolean;
}) & (abstract new (...args: any[]) => {
    roomAdd(roomId: string, contactId: string, inviteOnly?: boolean | undefined): Promise<void>;
    roomAvatar(roomId: string): Promise<import("file-box/dist/esm/src/interface.js").FileBoxInterface>;
    roomCreate(contactIdList: string[], topic?: string | undefined): Promise<string>;
    roomDel(roomId: string, contactId: string): Promise<void>;
    roomList(): Promise<string[]>;
    roomQRCode(roomId: string): Promise<string>;
    roomQuit(roomId: string): Promise<void>;
    roomTopic(roomId: string): Promise<string>;
    roomTopic(roomId: string, topic: string): Promise<void>;
    roomRawPayload(roomId: string): Promise<any>;
    roomRawPayloadParser(rawPayload: any): Promise<import("../schemas/room.js").RoomPayload>;
    roomAnnounce(roomId: string): Promise<string>;
    roomAnnounce(roomId: string, text: string): Promise<void>;
    roomSearch(query?: import("../schemas/room.js").RoomQueryFilter | undefined): Promise<string[]>;
    roomQueryFilterFactory(query: import("../schemas/room.js").RoomQueryFilter): import("../schemas/room.js").RoomPayloadFilterFunction;
    roomValidate(roomId: string): Promise<boolean>;
    roomPayloadCache(roomId: string): import("../schemas/room.js").RoomPayload | undefined;
    roomPayload(roomId: string): Promise<import("../schemas/room.js").RoomPayload>;
    roomPayloadDirty(id: string): Promise<void>;
    readonly id: string;
    readonly options: PuppetOptions;
    wrapAsync: import("gerror/dist/esm/src/wrap-async-error/wrap-async-error.js").WrapAsync;
    start: (() => Promise<void>) & (() => Promise<void>) & (() => Promise<void>);
    stop: (() => Promise<void>) & (() => Promise<void>) & (() => Promise<void>);
    emit(event: any, ...args: any): boolean;
    addListener<E_91 extends keyof import("./events.js").PuppetEventListener>(event: E_91, listener: import("./events.js").PuppetEventListener[E_91]): any;
    on<E_92 extends keyof import("./events.js").PuppetEventListener>(event: E_92, listener: import("./events.js").PuppetEventListener[E_92]): any;
    once<E_93 extends keyof import("./events.js").PuppetEventListener>(event: E_93, listener: import("./events.js").PuppetEventListener[E_93]): any;
    prependListener<E_94 extends keyof import("./events.js").PuppetEventListener>(event: E_94, listener: import("./events.js").PuppetEventListener[E_94]): any;
    prependOnceListener<E_95 extends keyof import("./events.js").PuppetEventListener>(event: E_95, listener: import("./events.js").PuppetEventListener[E_95]): any;
    off<E_96 extends keyof import("./events.js").PuppetEventListener>(event: E_96, listener: import("./events.js").PuppetEventListener[E_96]): any;
    removeAllListeners<E_97 extends keyof import("./events.js").PuppetEventListener>(event?: E_97 | undefined): any;
    removeListener<E_98 extends keyof import("./events.js").PuppetEventListener>(event: E_98, listener: import("./events.js").PuppetEventListener[E_98]): any;
    eventNames(): (string | symbol)[];
    rawListeners<E_8 extends keyof import("./events.js").PuppetEventListener>(event: E_8): Function[];
    listeners<E_9 extends keyof import("./events.js").PuppetEventListener>(event: E_9): Function[];
    listenerCount<E_10 extends keyof import("./events.js").PuppetEventListener>(event: E_10): number;
    getMaxListeners(): number;
    setMaxListeners(maxListeners: number): any;
    __events: import("./events.js").PuppetEventListener;
    contactSelfName(name: string): Promise<void>;
    contactSelfQRCode(): Promise<string>;
    contactSelfSignature(signature: string): Promise<void>;
    contactAlias(contactId: string): Promise<string>;
    contactAlias(contactId: string, alias: string | null): Promise<void>;
    contactAvatar(contactId: string): Promise<import("file-box/dist/esm/src/interface.js").FileBoxInterface>;
    contactAvatar(contactId: string, file: import("file-box/dist/esm/src/interface.js").FileBoxInterface): Promise<void>;
    contactPhone(contactId: string, phoneList: string[]): Promise<void>;
    contactCorporationRemark(contactId: string, corporationRemark: string | null): Promise<void>;
    contactDescription(contactId: string, description: string | null): Promise<void>;
    contactList(): Promise<string[]>;
    contactRawPayload(contactId: string): Promise<any>;
    contactRawPayloadParser(rawPayload: any): Promise<import("../schemas/contact.js").ContactPayload>;
    contactSearch(query?: string | import("../schemas/contact.js").ContactQueryFilter | undefined, searchIdList?: string[] | undefined): Promise<string[]>;
    contactQueryFilterFactory(query: import("../schemas/contact.js").ContactQueryFilter): import("../schemas/contact.js").ContactPayloadFilterFunction;
    contactValidate(contactId: string): Promise<boolean>;
    contactPayloadCache(contactId: string): import("../schemas/contact.js").ContactPayload | undefined;
    contactPayload(contactId: string): Promise<import("../schemas/contact.js").ContactPayload>;
    contactPayloadDirty(id: string): Promise<void>;
    cache: import("../agents/cache-agent.js").CacheAgent;
    __cacheMixinCleanCallbackList: (() => void)[];
    dirtyPayload(type: import("../schemas/dirty.js").DirtyType, id: string): void;
    onDirty({ payloadType, payloadId, }: import("../schemas/event.js").EventDirtyPayload): void;
    __dirtyPayloadAwait(type: import("../schemas/dirty.js").DirtyType, id: string): Promise<void>;
    __currentUserId?: string | undefined;
    readonly currentUserId: string;
    readonly isLoggedIn: boolean;
    __authQrCode?: string | undefined;
    readonly authQrCode: string | undefined;
    login(userId: string): void;
    logout(reason?: string): Promise<void>;
    selfId(): string;
    logonoff(): boolean;
    roomMemberList(roomId: string): Promise<string[]>;
    roomMemberRawPayload(roomId: string, contactId: string): Promise<any>;
    roomMemberRawPayloadParser(rawPayload: any): Promise<import("../schemas/room.js").RoomMemberPayload>;
    roomMemberSearch(roomId: string, query: string | symbol | import("../schemas/room.js").RoomMemberQueryFilter): Promise<string[]>;
    roomMemberPayload(roomId: string, memberId: string): Promise<import("../schemas/room.js").RoomMemberPayload>;
    roomMemberPayloadDirty(id: string): Promise<void>;
}) & (abstract new (...args: any[]) => {
    roomMemberList(roomId: string): Promise<string[]>;
    roomMemberRawPayload(roomId: string, contactId: string): Promise<any>;
    roomMemberRawPayloadParser(rawPayload: any): Promise<import("../schemas/room.js").RoomMemberPayload>;
    roomMemberSearch(roomId: string, query: string | symbol | import("../schemas/room.js").RoomMemberQueryFilter): Promise<string[]>;
    roomMemberPayload(roomId: string, memberId: string): Promise<import("../schemas/room.js").RoomMemberPayload>;
    roomMemberPayloadDirty(id: string): Promise<void>;
    readonly id: string;
    readonly options: PuppetOptions;
    wrapAsync: import("gerror/dist/esm/src/wrap-async-error/wrap-async-error.js").WrapAsync;
    start: (() => Promise<void>) & (() => Promise<void>) & (() => Promise<void>);
    stop: (() => Promise<void>) & (() => Promise<void>) & (() => Promise<void>);
    emit(event: any, ...args: any): boolean;
    addListener<E_99 extends keyof import("./events.js").PuppetEventListener>(event: E_99, listener: import("./events.js").PuppetEventListener[E_99]): any;
    on<E_100 extends keyof import("./events.js").PuppetEventListener>(event: E_100, listener: import("./events.js").PuppetEventListener[E_100]): any;
    once<E_101 extends keyof import("./events.js").PuppetEventListener>(event: E_101, listener: import("./events.js").PuppetEventListener[E_101]): any;
    prependListener<E_102 extends keyof import("./events.js").PuppetEventListener>(event: E_102, listener: import("./events.js").PuppetEventListener[E_102]): any;
    prependOnceListener<E_103 extends keyof import("./events.js").PuppetEventListener>(event: E_103, listener: import("./events.js").PuppetEventListener[E_103]): any;
    off<E_104 extends keyof import("./events.js").PuppetEventListener>(event: E_104, listener: import("./events.js").PuppetEventListener[E_104]): any;
    removeAllListeners<E_105 extends keyof import("./events.js").PuppetEventListener>(event?: E_105 | undefined): any;
    removeListener<E_106 extends keyof import("./events.js").PuppetEventListener>(event: E_106, listener: import("./events.js").PuppetEventListener[E_106]): any;
    eventNames(): (string | symbol)[];
    rawListeners<E_8 extends keyof import("./events.js").PuppetEventListener>(event: E_8): Function[];
    listeners<E_9 extends keyof import("./events.js").PuppetEventListener>(event: E_9): Function[];
    listenerCount<E_10 extends keyof import("./events.js").PuppetEventListener>(event: E_10): number;
    getMaxListeners(): number;
    setMaxListeners(maxListeners: number): any;
    __events: import("./events.js").PuppetEventListener;
    contactSelfName(name: string): Promise<void>;
    contactSelfQRCode(): Promise<string>;
    contactSelfSignature(signature: string): Promise<void>;
    contactAlias(contactId: string): Promise<string>;
    contactAlias(contactId: string, alias: string | null): Promise<void>;
    contactAvatar(contactId: string): Promise<import("file-box/dist/esm/src/interface.js").FileBoxInterface>;
    contactAvatar(contactId: string, file: import("file-box/dist/esm/src/interface.js").FileBoxInterface): Promise<void>;
    contactPhone(contactId: string, phoneList: string[]): Promise<void>;
    contactCorporationRemark(contactId: string, corporationRemark: string | null): Promise<void>;
    contactDescription(contactId: string, description: string | null): Promise<void>;
    contactList(): Promise<string[]>;
    contactRawPayload(contactId: string): Promise<any>;
    contactRawPayloadParser(rawPayload: any): Promise<import("../schemas/contact.js").ContactPayload>;
    contactSearch(query?: string | import("../schemas/contact.js").ContactQueryFilter | undefined, searchIdList?: string[] | undefined): Promise<string[]>;
    contactQueryFilterFactory(query: import("../schemas/contact.js").ContactQueryFilter): import("../schemas/contact.js").ContactPayloadFilterFunction;
    contactValidate(contactId: string): Promise<boolean>;
    contactPayloadCache(contactId: string): import("../schemas/contact.js").ContactPayload | undefined;
    contactPayload(contactId: string): Promise<import("../schemas/contact.js").ContactPayload>;
    contactPayloadDirty(id: string): Promise<void>;
    cache: import("../agents/cache-agent.js").CacheAgent;
    __cacheMixinCleanCallbackList: (() => void)[];
    dirtyPayload(type: import("../schemas/dirty.js").DirtyType, id: string): void;
    onDirty({ payloadType, payloadId, }: import("../schemas/event.js").EventDirtyPayload): void;
    __dirtyPayloadAwait(type: import("../schemas/dirty.js").DirtyType, id: string): Promise<void>;
    __currentUserId?: string | undefined;
    readonly currentUserId: string;
    readonly isLoggedIn: boolean;
    __authQrCode?: string | undefined;
    readonly authQrCode: string | undefined;
    login(userId: string): void;
    logout(reason?: string): Promise<void>;
    selfId(): string;
    logonoff(): boolean;
}) & (abstract new (...args: any[]) => {
    contactSelfName(name: string): Promise<void>;
    contactSelfQRCode(): Promise<string>;
    contactSelfSignature(signature: string): Promise<void>;
    contactAlias(contactId: string): Promise<string>;
    contactAlias(contactId: string, alias: string | null): Promise<void>;
    contactAvatar(contactId: string): Promise<import("file-box/dist/esm/src/interface.js").FileBoxInterface>;
    contactAvatar(contactId: string, file: import("file-box/dist/esm/src/interface.js").FileBoxInterface): Promise<void>;
    contactPhone(contactId: string, phoneList: string[]): Promise<void>;
    contactCorporationRemark(contactId: string, corporationRemark: string | null): Promise<void>;
    contactDescription(contactId: string, description: string | null): Promise<void>;
    contactList(): Promise<string[]>;
    contactRawPayload(contactId: string): Promise<any>;
    contactRawPayloadParser(rawPayload: any): Promise<import("../schemas/contact.js").ContactPayload>;
    contactSearch(query?: string | import("../schemas/contact.js").ContactQueryFilter | undefined, searchIdList?: string[] | undefined): Promise<string[]>;
    contactQueryFilterFactory(query: import("../schemas/contact.js").ContactQueryFilter): import("../schemas/contact.js").ContactPayloadFilterFunction;
    contactValidate(contactId: string): Promise<boolean>;
    contactPayloadCache(contactId: string): import("../schemas/contact.js").ContactPayload | undefined;
    contactPayload(contactId: string): Promise<import("../schemas/contact.js").ContactPayload>;
    contactPayloadDirty(id: string): Promise<void>;
    cache: import("../agents/cache-agent.js").CacheAgent;
    __cacheMixinCleanCallbackList: (() => void)[];
    start: (() => Promise<void>) & (() => Promise<void>) & (() => Promise<void>);
    stop: (() => Promise<void>) & (() => Promise<void>) & (() => Promise<void>);
    dirtyPayload(type: import("../schemas/dirty.js").DirtyType, id: string): void;
    onDirty({ payloadType, payloadId, }: import("../schemas/event.js").EventDirtyPayload): void;
    __dirtyPayloadAwait(type: import("../schemas/dirty.js").DirtyType, id: string): Promise<void>;
    readonly id: string;
    readonly options: PuppetOptions;
    wrapAsync: import("gerror/dist/esm/src/wrap-async-error/wrap-async-error.js").WrapAsync;
    emit(event: any, ...args: any): boolean;
    addListener<E_107 extends keyof import("./events.js").PuppetEventListener>(event: E_107, listener: import("./events.js").PuppetEventListener[E_107]): any;
    on<E_108 extends keyof import("./events.js").PuppetEventListener>(event: E_108, listener: import("./events.js").PuppetEventListener[E_108]): any;
    once<E_109 extends keyof import("./events.js").PuppetEventListener>(event: E_109, listener: import("./events.js").PuppetEventListener[E_109]): any;
    prependListener<E_110 extends keyof import("./events.js").PuppetEventListener>(event: E_110, listener: import("./events.js").PuppetEventListener[E_110]): any;
    prependOnceListener<E_111 extends keyof import("./events.js").PuppetEventListener>(event: E_111, listener: import("./events.js").PuppetEventListener[E_111]): any;
    off<E_112 extends keyof import("./events.js").PuppetEventListener>(event: E_112, listener: import("./events.js").PuppetEventListener[E_112]): any;
    removeAllListeners<E_113 extends keyof import("./events.js").PuppetEventListener>(event?: E_113 | undefined): any;
    removeListener<E_114 extends keyof import("./events.js").PuppetEventListener>(event: E_114, listener: import("./events.js").PuppetEventListener[E_114]): any;
    eventNames(): (string | symbol)[];
    rawListeners<E_8 extends keyof import("./events.js").PuppetEventListener>(event: E_8): Function[];
    listeners<E_9 extends keyof import("./events.js").PuppetEventListener>(event: E_9): Function[];
    listenerCount<E_10 extends keyof import("./events.js").PuppetEventListener>(event: E_10): number;
    getMaxListeners(): number;
    setMaxListeners(maxListeners: number): any;
    __events: import("./events.js").PuppetEventListener;
    __currentUserId?: string | undefined;
    readonly currentUserId: string;
    readonly isLoggedIn: boolean;
    __authQrCode?: string | undefined;
    readonly authQrCode: string | undefined;
    login(userId: string): void;
    logout(reason?: string): Promise<void>;
    selfId(): string;
    logonoff(): boolean;
}) & (abstract new (...args: any[]) => {
    cache: import("../agents/cache-agent.js").CacheAgent;
    __cacheMixinCleanCallbackList: (() => void)[];
    start(): Promise<void>;
    stop(): Promise<void>;
    dirtyPayload(type: import("../schemas/dirty.js").DirtyType, id: string): void;
    onDirty({ payloadType, payloadId, }: import("../schemas/event.js").EventDirtyPayload): void;
    __dirtyPayloadAwait(type: import("../schemas/dirty.js").DirtyType, id: string): Promise<void>;
    readonly id: string;
    readonly options: PuppetOptions;
    wrapAsync: import("gerror/dist/esm/src/wrap-async-error/wrap-async-error.js").WrapAsync;
    emit(event: any, ...args: any): boolean;
    addListener<E_115 extends keyof import("./events.js").PuppetEventListener>(event: E_115, listener: import("./events.js").PuppetEventListener[E_115]): any;
    on<E_116 extends keyof import("./events.js").PuppetEventListener>(event: E_116, listener: import("./events.js").PuppetEventListener[E_116]): any;
    once<E_117 extends keyof import("./events.js").PuppetEventListener>(event: E_117, listener: import("./events.js").PuppetEventListener[E_117]): any;
    prependListener<E_118 extends keyof import("./events.js").PuppetEventListener>(event: E_118, listener: import("./events.js").PuppetEventListener[E_118]): any;
    prependOnceListener<E_119 extends keyof import("./events.js").PuppetEventListener>(event: E_119, listener: import("./events.js").PuppetEventListener[E_119]): any;
    off<E_120 extends keyof import("./events.js").PuppetEventListener>(event: E_120, listener: import("./events.js").PuppetEventListener[E_120]): any;
    removeAllListeners<E_121 extends keyof import("./events.js").PuppetEventListener>(event?: E_121 | undefined): any;
    removeListener<E_122 extends keyof import("./events.js").PuppetEventListener>(event: E_122, listener: import("./events.js").PuppetEventListener[E_122]): any;
    eventNames(): (string | symbol)[];
    rawListeners<E_8 extends keyof import("./events.js").PuppetEventListener>(event: E_8): Function[];
    listeners<E_9 extends keyof import("./events.js").PuppetEventListener>(event: E_9): Function[];
    listenerCount<E_10 extends keyof import("./events.js").PuppetEventListener>(event: E_10): number;
    getMaxListeners(): number;
    setMaxListeners(maxListeners: number): any;
    __events: import("./events.js").PuppetEventListener;
    __currentUserId?: string | undefined;
    readonly currentUserId: string;
    readonly isLoggedIn: boolean;
    __authQrCode?: string | undefined;
    readonly authQrCode: string | undefined;
    login(userId: string): void;
    logout(reason?: string): Promise<void>;
    selfId(): string;
    logonoff(): boolean;
}) & (abstract new (...args: any[]) => {
    __currentUserId?: string | undefined;
    readonly currentUserId: string;
    readonly isLoggedIn: boolean;
    __authQrCode?: string | undefined;
    readonly authQrCode: string | undefined;
    start(): Promise<void>;
    stop(): Promise<void>;
    login(userId: string): void;
    logout(reason?: string): Promise<void>;
    selfId(): string;
    logonoff(): boolean;
    readonly id: string;
    readonly options: PuppetOptions;
    wrapAsync: import("gerror/dist/esm/src/wrap-async-error/wrap-async-error.js").WrapAsync;
    emit(event: any, ...args: any): boolean;
    addListener<E_123 extends keyof import("./events.js").PuppetEventListener>(event: E_123, listener: import("./events.js").PuppetEventListener[E_123]): any;
    on<E_124 extends keyof import("./events.js").PuppetEventListener>(event: E_124, listener: import("./events.js").PuppetEventListener[E_124]): any;
    once<E_125 extends keyof import("./events.js").PuppetEventListener>(event: E_125, listener: import("./events.js").PuppetEventListener[E_125]): any;
    prependListener<E_126 extends keyof import("./events.js").PuppetEventListener>(event: E_126, listener: import("./events.js").PuppetEventListener[E_126]): any;
    prependOnceListener<E_127 extends keyof import("./events.js").PuppetEventListener>(event: E_127, listener: import("./events.js").PuppetEventListener[E_127]): any;
    off<E_128 extends keyof import("./events.js").PuppetEventListener>(event: E_128, listener: import("./events.js").PuppetEventListener[E_128]): any;
    removeAllListeners<E_129 extends keyof import("./events.js").PuppetEventListener>(event?: E_129 | undefined): any;
    removeListener<E_130 extends keyof import("./events.js").PuppetEventListener>(event: E_130, listener: import("./events.js").PuppetEventListener[E_130]): any;
    eventNames(): (string | symbol)[];
    rawListeners<E_8 extends keyof import("./events.js").PuppetEventListener>(event: E_8): Function[];
    listeners<E_9 extends keyof import("./events.js").PuppetEventListener>(event: E_9): Function[];
    listenerCount<E_10 extends keyof import("./events.js").PuppetEventListener>(event: E_10): number;
    getMaxListeners(): number;
    setMaxListeners(maxListeners: number): any;
    __events: import("./events.js").PuppetEventListener;
}) & (abstract new (...args: any[]) => {
    _memory: import("memory-card/dist/esm/src/memory-card.js").MemoryCard;
    readonly memory: import("memory-card/dist/esm/src/memory-card.js").MemoryCard;
    start(): Promise<void>;
    stop(): Promise<void>;
    setMemory(memory: import("memory-card/dist/esm/src/memory-card.js").MemoryCard): void;
    readonly id: string;
    readonly options: PuppetOptions;
    wrapAsync: import("gerror/dist/esm/src/wrap-async-error/wrap-async-error.js").WrapAsync;
    emit(event: any, ...args: any): boolean;
    addListener<E_131 extends keyof import("./events.js").PuppetEventListener>(event: E_131, listener: import("./events.js").PuppetEventListener[E_131]): any;
    on<E_132 extends keyof import("./events.js").PuppetEventListener>(event: E_132, listener: import("./events.js").PuppetEventListener[E_132]): any;
    once<E_133 extends keyof import("./events.js").PuppetEventListener>(event: E_133, listener: import("./events.js").PuppetEventListener[E_133]): any;
    prependListener<E_134 extends keyof import("./events.js").PuppetEventListener>(event: E_134, listener: import("./events.js").PuppetEventListener[E_134]): any;
    prependOnceListener<E_135 extends keyof import("./events.js").PuppetEventListener>(event: E_135, listener: import("./events.js").PuppetEventListener[E_135]): any;
    off<E_136 extends keyof import("./events.js").PuppetEventListener>(event: E_136, listener: import("./events.js").PuppetEventListener[E_136]): any;
    removeAllListeners<E_137 extends keyof import("./events.js").PuppetEventListener>(event?: E_137 | undefined): any;
    removeListener<E_138 extends keyof import("./events.js").PuppetEventListener>(event: E_138, listener: import("./events.js").PuppetEventListener[E_138]): any;
    eventNames(): (string | symbol)[];
    rawListeners<E_8 extends keyof import("./events.js").PuppetEventListener>(event: E_8): Function[];
    listeners<E_9 extends keyof import("./events.js").PuppetEventListener>(event: E_9): Function[];
    listenerCount<E_10 extends keyof import("./events.js").PuppetEventListener>(event: E_10): number;
    getMaxListeners(): number;
    setMaxListeners(maxListeners: number): any;
    __events: import("./events.js").PuppetEventListener;
}) & typeof PuppetSkeleton;
/**
 *
 * Puppet Base Class
 *
 * See: https://github.com/wechaty/wechaty/wiki/Puppet
 *
 */
declare abstract class Puppet extends MixinBase {
    /**
     * Must overwrite by child class to identify their version
     *
     * Huan(202111): we must put the `VERSION` in the outter side of all the Mixins
     *  because we do not know which Mixin will override the `VERSION`
     */
    static readonly VERSION: string;
    constructor(options?: PuppetOptions);
    /**
     * The child puppet provider should put all start code inside `onStart()`
     *  becasue the `onStart()` with be called by `start()` inside state management.
     *
     * The `try {} catch () {}` is not necessary inside `onStart()`
     *  because it will be handled by the framework.
     *
     * `onStop()` is the same as the `onStart()`
     *
     *  @see https://github.com/wechaty/puppet/issues/163
     */
    abstract onStart(): Promise<void>;
    abstract onStop(): Promise<void>;
}
export { Puppet, };
//# sourceMappingURL=puppet-abstract.d.ts.map