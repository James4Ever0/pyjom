#!/usr/bin/env ts-node
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const tstest_1 = require("tstest");
tstest_1.test('AsyncMapLike Interface via object', (t) => __awaiter(void 0, void 0, void 0, function* () {
    const mapCollection = {
        clear: () => __awaiter(void 0, void 0, void 0, function* () { }),
        delete: (key) => __awaiter(void 0, void 0, void 0, function* () { return !!key; }),
        forEach: (callbackfn, thisArg) => __awaiter(void 0, void 0, void 0, function* () { void callbackfn; void thisArg; }),
        get: (_) => __awaiter(void 0, void 0, void 0, function* () { }),
        has: (key) => __awaiter(void 0, void 0, void 0, function* () { return !!key; }),
        set: function (_, __) {
            return __awaiter(this, void 0, void 0, function* () { return {}; });
        },
        size: Promise.resolve(42),
    };
    const mapIterable = {
        [Symbol.iterator]: () => { return {}; },
        entries: () => { return {}; },
        keys: () => { return {}; },
        values: () => { return {}; },
    };
    const mapLike = Object.assign(Object.assign({}, mapCollection), mapIterable);
    t.ok(mapLike, 'should be assign-able from ES6 Map to our MapLike');
}));
tstest_1.test('AsyncMapLike Interface via class', (t) => __awaiter(void 0, void 0, void 0, function* () {
    class TestAsyncMapLike {
        constructor() { }
        /**
         * Collections
         */
        clear() {
            return __awaiter(this, void 0, void 0, function* () { });
        }
        delete(key) {
            return __awaiter(this, void 0, void 0, function* () { return !!key; });
        }
        forEach(callbackfn, thisArg) {
            return __awaiter(this, void 0, void 0, function* () { void callbackfn; void thisArg; });
        }
        get(key) {
            return __awaiter(this, void 0, void 0, function* () { void key; return 42; });
        }
        has(key) {
            return __awaiter(this, void 0, void 0, function* () { return !!key; });
        }
        set(key, value) {
            return __awaiter(this, void 0, void 0, function* () { void key; void value; return this; });
        }
        get size() { return Promise.resolve(42); }
        /**
         * Iterables
         */
        [Symbol.iterator]() { return {}; }
        entries() { return {}; }
        keys() { return {}; }
        values() { return {}; }
        get [Symbol.toStringTag]() { return 'test'; }
    }
    const mapLike = new TestAsyncMapLike();
    t.ok(mapLike, 'should be implement-able from AsyncMapLike');
}));
tstest_1.test('AsyncMapLike Interface via class generic', (t) => __awaiter(void 0, void 0, void 0, function* () {
    class TestAsyncMapLike {
        constructor() { }
        /**
         * Collections
         */
        clear() {
            return __awaiter(this, void 0, void 0, function* () { });
        }
        delete(key) {
            return __awaiter(this, void 0, void 0, function* () { return !!key; });
        }
        forEach(callbackfn, thisArg) {
            return __awaiter(this, void 0, void 0, function* () { void callbackfn; void thisArg; });
        }
        get(key) {
            return __awaiter(this, void 0, void 0, function* () { void key; return 42; });
        }
        has(key) {
            return __awaiter(this, void 0, void 0, function* () { return !!key; });
        }
        set(key, value) {
            return __awaiter(this, void 0, void 0, function* () { void key; void value; return this; });
        }
        get size() { return Promise.resolve(42); }
        /**
         * Iterables
         */
        [Symbol.iterator]() { return {}; }
        entries() { return {}; }
        keys() { return {}; }
        values() { return {}; }
        get [Symbol.toStringTag]() { return 'test'; }
    }
    const mapLike = new TestAsyncMapLike();
    t.ok(mapLike, 'should be implement-able from AsyncMapLike');
}));
//# sourceMappingURL=async-map-like.spec.js.map