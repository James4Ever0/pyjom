import cuid from 'cuid';
import { StateSwitch, } from 'state-switch';
import { log, } from './config.js';
import { FlashStore, } from './flash-store.js';
export class FlashStoreSync {
    constructor(workdir) {
        this.workdir = workdir;
        log.verbose('CacheStore', 'constructor(%s)', workdir);
        workdir = workdir || '.flash-store-sync';
        this.asyncBusyDict = {};
        this.asyncBusyState = new StateSwitch('Busy:' + workdir.split('/').pop(), // get the latest folder name
        { log });
        this.cacheMap = new Map();
        this.flashStore = new FlashStore(workdir);
        this.asyncBusyAdd(this.loadStoreToCache());
    }
    async loadStoreToCache() {
        this.cacheMap.clear();
        for await (const [key, val] of this.flashStore) {
            this.cacheMap.set(key, val);
        }
    }
    asyncBusyAdd(task) {
        this.asyncBusyState.on(true);
        const id = cuid();
        this.asyncBusyDict[id] = task.finally(() => {
            delete this.asyncBusyDict[id];
            if (Object.keys(this.asyncBusyDict).length <= 0) {
                this.asyncBusyState.off(true);
            }
        });
    }
    version() {
        return this.flashStore.version();
    }
    /**
     *
     * Async methods:
     *
     */
    async close() {
        await this.ready();
        await this.flashStore.close();
    }
    async destroy() {
        // this.clear()
        // add destroy task at the end of the event loop
        this.asyncBusyState.ready('off')
            .then(() => this.flashStore.destroy()).catch(console.error);
    }
    async ready() {
        await this.asyncBusyState.ready('off');
    }
    /*******************************************************
     *
     *
     * The following methods is all for ES6 Map Interface
     *
     *
     *******************************************************/
    get size() {
        return this.cacheMap.size;
    }
    get [Symbol.toStringTag]() {
        return 'FlashStoreSync';
    }
    [Symbol.iterator]() {
        return this.cacheMap[Symbol.iterator]();
    }
    entries() {
        return this.cacheMap.entries();
    }
    keys() {
        return this.cacheMap.keys();
    }
    values() {
        return this.cacheMap.values();
    }
    clear() {
        this.asyncBusyAdd(this.flashStore.clear());
        return this.cacheMap.clear();
    }
    delete(key) {
        this.asyncBusyAdd(this.flashStore.delete(key));
        return this.cacheMap.delete(key);
    }
    /**
     * Do not mutate the key/value in the forEach loop!
     */
    forEach(callbackfn, thisArg) {
        /**
         * 1. no need to call flashStore
         * 2. callbackfn should not mutate the data, or the data will be lost sync between cache & store
         */
        return this.cacheMap.forEach(callbackfn, thisArg);
    }
    get(key) {
        return this.cacheMap.get(key);
    }
    has(key) {
        return this.cacheMap.has(key);
    }
    set(key, value) {
        this.asyncBusyAdd(this.flashStore.set(key, value));
        this.cacheMap.set(key, value);
        return this;
    }
}
FlashStoreSync.VERSION = FlashStore.VERSION;
export default FlashStoreSync;
//# sourceMappingURL=flash-store-sync.js.map