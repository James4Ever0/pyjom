#!/usr/bin/env -S node --no-warnings --loader ts-node/esm
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tstest_1 = require("tstest");
const validation_js_1 = require("./validation.js");
(0, tstest_1.test)('validationMixin() valid()', async (t) => {
    class Parent {
        foo() { return 'foo'; }
    }
    class Child extends Parent {
        bar() { return 'bar'; }
    }
    class UserClassImpl extends (0, validation_js_1.validationMixin)(Child)() {
    }
    const FIXTURES = [
        [new UserClassImpl(), true],
        // Invalid things
        [{}, false],
        [[], false],
        [new Map(), false],
        // Object interface
        [{ bar: true, foo: true }, true],
        [{ bar: true }, false],
        [{ foo: true }, false],
    ];
    for (const [input, expected] of FIXTURES) {
        const valid = expected ? 'valid' : 'invalid';
        /* eslint-disable multiline-ternary */
        const type = typeof input !== 'object' ? typeof input
            : typeof input.constructor === 'function' ? input.constructor.name
                : 'object';
        t.equal(UserClassImpl.valid(input), expected, `should be ${valid} for ${type} "${JSON.stringify(input)}"`);
    }
});
(0, tstest_1.test)('validationMixin() type guard', async (t) => {
    class Parent {
        foo() { return 'foo'; }
        constructor() { }
    }
    class Child extends Parent {
        bar() { return 'bar'; }
        constructor() { super(); }
    }
    class UserClassImpl extends (0, validation_js_1.validationMixin)(Child)() {
    }
    const obj = {};
    if (UserClassImpl.valid(obj)) {
        const validType = true;
        t.ok(validType, 'should be type `UserClass`');
    }
    else {
        const stringType = true;
        t.ok(stringType, 'should be type `string`');
    }
});
//# sourceMappingURL=validation.spec.js.map