/// <reference types="node" />
/**
 *   Wechaty Chatbot SDK - https://github.com/wechaty/wechaty
 *
 *   @copyright 2016 Huan LI (李卓桓) <https://github.com/huan>, and
 *                   Wechaty Contributors <https://github.com/wechaty>.
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 */
import { EventEmitter } from 'events';
import * as PUPPET from 'wechaty-puppet';
import type { FileBoxInterface } from 'file-box';
import type { Constructor } from 'clone-class';
import type { SayableSayer, Sayable } from '../sayable/mod.js';
import type { ContactInterface } from './contact.js';
import type { RoomInterface } from './room.js';
import type { UrlLinkInterface } from './url-link.js';
import type { MiniProgramInterface } from './mini-program.js';
import type { ImageInterface } from './image.js';
import { PostInterface } from './post.js';
import { LocationInterface } from './location.js';
declare const MixinBase: ((abstract new (...args: any[]) => {
    readonly wechaty: import("../wechaty/wechaty-impl.js").WechatyInterface;
}) & {
    readonly wechaty: import("../wechaty/wechaty-impl.js").WechatyInterface;
}) & typeof EventEmitter;
/**
 * All wechat messages will be encapsulated as a Message.
 *
 * [Examples/Ding-Dong-Bot]{@link https://github.com/wechaty/wechaty/blob/1523c5e02be46ebe2cc172a744b2fbe53351540e/examples/ding-dong-bot.ts}
 */
declare class MessageMixin extends MixinBase implements SayableSayer {
    readonly id: string;
    /**
     *
     * Static Properties
     *
     */
    /**
     * @ignore
     */
    static readonly Type: typeof PUPPET.types.Message;
    /**
     * Find message in cache
     */
    static find(query: string | PUPPET.filters.Message): Promise<undefined | MessageInterface>;
    /**
     * Find messages in cache
     */
    static findAll(query?: PUPPET.filters.Message): Promise<MessageInterface[]>;
    /**
     * Create a Mobile Terminated Message
     * @ignore
     * "mobile originated" or "mobile terminated"
     * https://www.tatango.com/resources/video-lessons/video-mo-mt-sms-messaging/
     */
    static load(id: string): MessageImplInterface;
    /**
     *
     * Instance Properties
     * @hidden
     *
     */
    payload?: PUPPET.payloads.Message;
    /**
     * @hideconstructor
     */
    constructor(id: string);
    /**
     * @ignore
     */
    toString(): string;
    conversation(): ContactInterface | RoomInterface;
    /**
     * Get the talker of a message.
     * @returns {ContactInterface}
     * @example
     * const bot = new Wechaty()
     * bot
     * .on('message', async m => {
     *   const talker = msg.talker()
     *   const text = msg.text()
     *   const room = msg.room()
     *   if (room) {
     *     const topic = await room.topic()
     *     console.log(`Room: ${topic} Contact: ${talker.name()} Text: ${text}`)
     *   } else {
     *     console.log(`Contact: ${talker.name()} Text: ${text}`)
     *   }
     * })
     * .start()
     */
    talker(): ContactInterface;
    /**
     * @depreacated Use `message.talker()` to replace `message.from()`
     *  https://github.com/wechaty/wechaty/issues/2094
     */
    from(): undefined | ContactInterface;
    /**
     * Get the destination of the message
     * Message.to() will return null if a message is in a room, use Message.room() to get the room.
     * @returns {(ContactInterface|null)}
     * @deprecated use `listener()` instead
     */
    to(): undefined | ContactInterface;
    /**
     * Get the destination of the message
     * Message.listener() will return null if a message is in a room,
     * use Message.room() to get the room.
     * @returns {(undefined | ContactInterface)}
     */
    listener(): undefined | ContactInterface;
    /**
     * Get the room from the message.
     * If the message is not in a room, then will return `null`
     *
     * @returns {(RoomInterface | null)}
     * @example
     * const bot = new Wechaty()
     * bot
     * .on('message', async m => {
     *   const contact = msg.from()
     *   const text = msg.text()
     *   const room = msg.room()
     *   if (room) {
     *     const topic = await room.topic()
     *     console.log(`Room: ${topic} Contact: ${contact.name()} Text: ${text}`)
     *   } else {
     *     console.log(`Contact: ${contact.name()} Text: ${text}`)
     *   }
     * })
     * .start()
     */
    room(): undefined | RoomInterface;
    /**
     * Get the text content of the message
     *
     * @returns {string}
     * @example
     * const bot = new Wechaty()
     * bot
     * .on('message', async m => {
     *   const contact = msg.from()
     *   const text = msg.text()
     *   const room = msg.room()
     *   if (room) {
     *     const topic = await room.topic()
     *     console.log(`Room: ${topic} Contact: ${contact.name()} Text: ${text}`)
     *   } else {
     *     console.log(`Contact: ${contact.name()} Text: ${text}`)
     *   }
     * })
     * .start()
     */
    text(): string;
    /**
     * Get the recalled message
     *
     * @example
     * const bot = new Wechaty()
     * bot
     * .on('message', async m => {
     *   if (m.type() === PUPPET.types.Message.Recalled) {
     *     const recalledMessage = await m.toRecalled()
     *     console.log(`Message: ${recalledMessage} has been recalled.`)
     *   }
     * })
     * .start()
     */
    toRecalled(): Promise<undefined | MessageInterface>;
    /**
     * Reply a Text or Media File message to the sender.
     * > Tips:
     * This function is depending on the Puppet Implementation, see [puppet-compatible-table](https://github.com/wechaty/wechaty/wiki/Puppet#3-puppet-compatible-table)
     *
     * @see {@link https://github.com/wechaty/wechaty/blob/1523c5e02be46ebe2cc172a744b2fbe53351540e/examples/ding-dong-bot.ts|Examples/ding-dong-bot}
     * @param {(string | ContactInterface | FileBox | UrlLinkInterface | MiniProgramInterface | LocationInterface)} textOrContactOrFile
     * send text, Contact, or file to bot. </br>
     * You can use {@link https://www.npmjs.com/package/file-box|FileBox} to send file
     * @param {(ContactInterface|ContactInterface[])} [mention]
     * If this is a room message, when you set mention param, you can `@` Contact in the room.
     * @returns {Promise<void | MessageInterface>}
     *
     * @example
     * import { FileBox }  from 'wechaty'
     * const bot = new Wechaty()
     * bot
     * .on('message', async m => {
     *
     * // 1. send Image
     *
     *   if (/^ding$/i.test(m.text())) {
     *     const fileBox = FileBox.fromUrl('https://wechaty.github.io/wechaty/images/bot-qr-code.png')
     *     await msg.say(fileBox)
     *     const message = await msg.say(fileBox) // only supported by puppet-padplus
     *   }
     *
     * // 2. send Text
     *
     *   if (/^dong$/i.test(m.text())) {
     *     await msg.say('ding')
     *     const message = await msg.say('ding') // only supported by puppet-padplus
     *   }
     *
     * // 3. send Contact
     *
     *   if (/^lijiarui$/i.test(m.text())) {
     *     const contactCard = await bot.Contact.find({name: 'lijiarui'})
     *     if (!contactCard) {
     *       console.log('not found')
     *       return
     *     }
     *     await msg.say(contactCard)
     *     const message = await msg.say(contactCard) // only supported by puppet-padplus
     *   }
     *
     * // 4. send Link
     *
     *   if (/^link$/i.test(m.text())) {
     *     const linkPayload = new UrlLink ({
     *       description : 'WeChat Bot SDK for Individual Account, Powered by TypeScript, Docker, and Love',
     *       thumbnailUrl: 'https://avatars0.githubusercontent.com/u/25162437?s=200&v=4',
     *       title       : 'Welcome to Wechaty',
     *       url         : 'https://github.com/wechaty/wechaty',
     *     })
     *     await msg.say(linkPayload)
     *     const message = await msg.say(linkPayload) // only supported by puppet-padplus
     *   }
     *
     * // 5. send MiniProgram
     *
     *   if (/^miniProgram$/i.test(m.text())) {
     *     const miniProgramPayload = new MiniProgram ({
     *       username           : 'gh_xxxxxxx',     //get from mp.weixin.qq.com
     *       appid              : '',               //optional, get from mp.weixin.qq.com
     *       title              : '',               //optional
     *       pagepath           : '',               //optional
     *       description        : '',               //optional
     *       thumbnailurl       : '',               //optional
     *     })
     *     await msg.say(miniProgramPayload)
     *     const message = await msg.say(miniProgramPayload) // only supported by puppet-padplus
     *   }
     *
     * // 6. send Location
     *   if (/^location$/i.test(m.text())) {
     *     const location = new Location ({
     *       accuracy  : 15,
     *       address   : '北京市北京市海淀区45 Chengfu Rd',
     *       latitude  : 39.995120999999997,
     *       longitude : 116.334154,
     *       name      : '东升乡人民政府(海淀区成府路45号)',
     *     })
     *     await contact.say(location)
     *     const msg = await msg.say(location)
     *   }
     * })
     * .start()
     */
    say(sayable: Sayable): Promise<void | MessageInterface>;
    /**
     * Recall a message.
     * > Tips:
     * @returns {Promise<boolean>}
     *
     * @example
     * const bot = new Wechaty()
     * bot
     * .on('message', async m => {
     *   const recallMessage = await msg.say('123')
     *   if (recallMessage) {
     *     const isSuccess = await recallMessage.recall()
     *   }
     * })
     */
    recall(): Promise<boolean>;
    /**
     * Get the type from the message.
     * > Tips: PUPPET.types.Message is Enum here. </br>
     * - PUPPET.types.Message.Unknown     </br>
     * - PUPPET.types.Message.Attachment  </br>
     * - PUPPET.types.Message.Audio       </br>
     * - PUPPET.types.Message.Contact     </br>
     * - PUPPET.types.Message.Emoticon    </br>
     * - PUPPET.types.Message.Image       </br>
     * - PUPPET.types.Message.Text        </br>
     * - PUPPET.types.Message.Video       </br>
     * - PUPPET.types.Message.Url         </br>
     * @returns {PUPPET.types.Message}
     *
     * @example
     * const bot = new Wechaty()
     * if (message.type() === bot.Message.Type.Text) {
     *   console.log('This is a text message')
     * }
     */
    type(): PUPPET.types.Message;
    /**
     * Check if a message is sent by self.
     *
     * @returns {boolean} - Return `true` for send from self, `false` for send from others.
     * @example
     * if (message.self()) {
     *  console.log('this message is sent by myself!')
     * }
     */
    self(): boolean;
    /**
     *
     * Get message mentioned contactList.
     *
     * Message event table as follows
     *
     * |                                                                            | Web  |  Mac PC Client | iOS Mobile |  android Mobile |
     * | :---                                                                       | :--: |     :----:     |   :---:    |     :---:       |
     * | [You were mentioned] tip ([有人@我]的提示)                                   |  ✘   |        √       |     √      |       √         |
     * | Identify magic code (8197) by copy & paste in mobile                       |  ✘   |        √       |     √      |       ✘         |
     * | Identify magic code (8197) by programming                                  |  ✘   |        ✘       |     ✘      |       ✘         |
     * | Identify two contacts with the same roomAlias by [You were  mentioned] tip |  ✘   |        ✘       |     √      |       √         |
     *
     * @returns {Promise<ContactInterface[]>} - Return message mentioned contactList
     *
     * @example
     * const contactList = await message.mentionList()
     * console.log(contactList)
     */
    mentionList(): Promise<ContactInterface[]>;
    /**
     * @deprecated mention() DEPRECATED. use mentionList() instead.
     */
    mention(): Promise<ContactInterface[]>;
    mentionText(): Promise<string>;
    /**
     * Check if a message is mention self.
     *
     * @returns {Promise<boolean>} - Return `true` for mention me.
     * @example
     * if (await message.mentionSelf()) {
     *  console.log('this message were mentioned me! [You were mentioned] tip ([有人@我]的提示)')
     * }
     */
    mentionSelf(): Promise<boolean>;
    /**
     * @ignore
     */
    isReady(): boolean;
    /**
     * @ignore
     */
    ready(): Promise<void>;
    /**
     * Forward the received message.
     *
     * @param {(Sayable | Sayable[])} to Room or Contact
     * The recipient of the message, the room, or the contact
     * @returns {Promise<void>}
     * @example
     * const bot = new Wechaty()
     * bot
     * .on('message', async m => {
     *   const room = await bot.Room.find({topic: 'wechaty'})
     *   if (room) {
     *     await m.forward(room)
     *     console.log('forward this message to wechaty room!')
     *   }
     * })
     * .start()
     */
    forward(to: RoomInterface | ContactInterface): Promise<void | MessageInterface>;
    /**
     * Message sent date
     */
    date(): Date;
    /**
     * Returns the message age in seconds. <br>
     *
     * For example, the message is sent at time `8:43:01`,
     * and when we received it in Wechaty, the time is `8:43:15`,
     * then the age() will return `8:43:15 - 8:43:01 = 14 (seconds)`
     *
     * @returns {number} message age in seconds.
     */
    age(): number;
    /**
     * Extract the Media File from the Message, and put it into the FileBox.
     * > Tips:
     * This function is depending on the Puppet Implementation, see [puppet-compatible-table](https://github.com/wechaty/wechaty/wiki/Puppet#3-puppet-compatible-table)
     *
     * @returns {Promise<FileBoxInterface>}
     *
     * @example <caption>Save media file from a message</caption>
     * const fileBox = await message.toFileBox()
     * const fileName = fileBox.name
     * fileBox.toFile(fileName)
     */
    toFileBox(): Promise<FileBoxInterface>;
    /**
     * Extract the Image File from the Message, so that we can use different image sizes.
     * > Tips:
     * This function is depending on the Puppet Implementation, see [puppet-compatible-table](https://github.com/wechaty/wechaty/wiki/Puppet#3-puppet-compatible-table)
     *
     * @returns {ImageInterface}
     *
     * @example <caption>Save image file from a message</caption>
     * const image = message.toImage()
     * const fileBox = await image.artwork()
     * const fileName = fileBox.name
     * fileBox.toFile(fileName)
     */
    toImage(): ImageInterface;
    /**
     * Get Share Card of the Message
     * Extract the Contact Card from the Message, and encapsulate it into Contact class
     * > Tips:
     * This function is depending on the Puppet Implementation, see [puppet-compatible-table](https://github.com/wechaty/wechaty/wiki/Puppet#3-puppet-compatible-table)
     * @returns {Promise<ContactInterface>}
     */
    toContact(): Promise<ContactInterface>;
    toUrlLink(): Promise<UrlLinkInterface>;
    toMiniProgram(): Promise<MiniProgramInterface>;
    toLocation(): Promise<LocationInterface>;
    toPost(): Promise<PostInterface>;
    toSayable(): Promise<undefined | Sayable>;
}
declare const MessageImplBase_base: {
    new (...args: any[]): {};
    valid: (o: any) => o is MessageImplInterface;
    validInstance: (target: any) => target is MessageMixin;
    validInterface: (target: any) => target is MessageImplInterface;
} & typeof MessageMixin;
declare class MessageImplBase extends MessageImplBase_base {
}
interface MessageImplInterface extends MessageImplBase {
}
declare type MessageProtectedProperty = 'ready';
declare type MessageInterface = Omit<MessageImplInterface, MessageProtectedProperty>;
declare const MessageImpl_base: {
    new (...args: any[]): {};
    valid: (o: any) => o is MessageInterface;
    validInstance: (target: any) => target is MessageImplBase;
    validInterface: (target: any) => target is MessageInterface;
} & typeof MessageImplBase;
declare class MessageImpl extends MessageImpl_base {
}
declare type MessageConstructor = Constructor<MessageInterface, Omit<typeof MessageImpl, 'load'>>;
export type { MessageInterface, MessageProtectedProperty, MessageConstructor, };
export { MessageImpl, };
//# sourceMappingURL=message.d.ts.map