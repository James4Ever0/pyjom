import { WrapAsync } from 'gerror';
import type { WechatySkeleton } from '../wechaty/mod.js';
declare const gErrorMixin: <MixinBase extends typeof WechatySkeleton>(mixinBase: MixinBase) => ((abstract new (...args: any[]) => {
    /**
     * Wrap promise in sync way (catch error by emitting it)
     *  1. convert a async callback function to be sync function
     *    by catcing any errors and emit them to error event
     *  2. wrap a Promise by catcing any errors and emit them to error event
     */
    wrapAsync: WrapAsync;
    /**
     * Wechaty internally can use `emit('error' whatever)` to emit any error
     * But the external call can only emit GError.
     * That's the reason why we need the below `emitError(e: any)
     */
    emitError(e: any): void;
    /**
     * Convert any error to GError,
     *  and emit `error` event with GError
     */
    emit(event: any, ...args: any): boolean;
    readonly log: import("brolog/dist/esm/src/logger").Loggable;
    readonly id: string;
    __memory?: import("memory-card").MemoryCard | undefined;
    readonly memory: import("memory-card").MemoryCard;
    __options: import("../schemas/wechaty-options.js").WechatyOptions;
    init(): Promise<void>;
    start(): Promise<void>;
    stop(): Promise<void>;
    on(event: "error" | "ready" | "login" | "start" | "stop" | "logout" | "room-invite" | "room-join" | "room-leave" | "room-topic" | "dong" | "friendship" | "heartbeat" | "message" | "post" | "puppet" | "scan", listener: (...args: any[]) => any): any;
    addListener<E extends keyof import("../schemas/wechaty-events.js").WechatyEventListeners>(event: E, listener: import("../schemas/wechaty-events.js").WechatyEventListeners[E]): any;
    once<E_1 extends keyof import("../schemas/wechaty-events.js").WechatyEventListeners>(event: E_1, listener: import("../schemas/wechaty-events.js").WechatyEventListeners[E_1]): any;
    prependListener<E_2 extends keyof import("../schemas/wechaty-events.js").WechatyEventListeners>(event: E_2, listener: import("../schemas/wechaty-events.js").WechatyEventListeners[E_2]): any;
    prependOnceListener<E_3 extends keyof import("../schemas/wechaty-events.js").WechatyEventListeners>(event: E_3, listener: import("../schemas/wechaty-events.js").WechatyEventListeners[E_3]): any;
    off<E_4 extends keyof import("../schemas/wechaty-events.js").WechatyEventListeners>(event: E_4, listener: import("../schemas/wechaty-events.js").WechatyEventListeners[E_4]): any;
    removeAllListeners<E_5 extends keyof import("../schemas/wechaty-events.js").WechatyEventListeners>(event?: E_5 | undefined): any;
    removeListener<E_6 extends keyof import("../schemas/wechaty-events.js").WechatyEventListeners>(event: E_6, listener: import("../schemas/wechaty-events.js").WechatyEventListeners[E_6]): any;
    eventNames(): (string | symbol)[];
    rawListeners<E_7 extends keyof import("../schemas/wechaty-events.js").WechatyEventListeners>(event: E_7): Function[];
    listeners<E_8 extends keyof import("../schemas/wechaty-events.js").WechatyEventListeners>(event: E_8): Function[];
    listenerCount<E_9 extends keyof import("../schemas/wechaty-events.js").WechatyEventListeners>(event: E_9): number;
    getMaxListeners(): number;
    setMaxListeners(maxListeners: number): any;
    __events: import("../schemas/wechaty-events.js").WechatyEventListeners;
}) & {
    readonly log: import("brolog/dist/esm/src/logger").Loggable;
}) & MixinBase;
declare type GErrorMixin = ReturnType<typeof gErrorMixin>;
declare type ProtectedPropertyGErrorMixin = never;
export type { GErrorMixin, ProtectedPropertyGErrorMixin, };
export { gErrorMixin, };
//# sourceMappingURL=gerror-mixin.d.ts.map