import { tokenize } from './newparser/tokenizer';
import { parse } from './newparser/parser';
import { errorBox } from './errorBox';
import { err, ok, isErr } from './Result';
import { Exit } from './effects';
export async function run(ap, strings) {
    const result = await runSafely(ap, strings);
    if (isErr(result)) {
        return result.error.run();
    }
    else {
        return result.value;
    }
}
/**
 * Runs a command but does not apply any effect
 */
export async function runSafely(ap, strings) {
    const longFlagKeys = new Set();
    const shortFlagKeys = new Set();
    const longOptionKeys = new Set();
    const shortOptionKeys = new Set();
    const hotPath = [];
    const registerContext = {
        forceFlagShortNames: shortFlagKeys,
        forceFlagLongNames: longFlagKeys,
        forceOptionShortNames: shortOptionKeys,
        forceOptionLongNames: longOptionKeys,
    };
    ap.register(registerContext);
    const tokens = tokenize(strings);
    const nodes = parse(tokens, registerContext);
    try {
        const result = await ap.run({ nodes, visitedNodes: new Set(), hotPath });
        if (isErr(result)) {
            throw new Exit({
                message: errorBox(nodes, result.error.errors, hotPath),
                exitCode: 1,
                into: 'stderr',
            });
        }
        else {
            return ok(result.value);
        }
    }
    catch (e) {
        if (e instanceof Exit) {
            return err(e);
        }
        throw e;
    }
}
/**
 * Run a command but don't quit. Returns an `Result` instead.
 */
export async function dryRun(ap, strings) {
    const result = await runSafely(ap, strings);
    if (isErr(result)) {
        return err(result.error.dryRun());
    }
    else {
        return result;
    }
}
//# sourceMappingURL=runner.js.map