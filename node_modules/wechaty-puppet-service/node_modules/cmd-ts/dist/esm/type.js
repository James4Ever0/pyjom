export { identity } from './from';
/**
 * Get the type definitions or an empty object from a type or a decoding function
 */
export function typeDef(from) {
    if (typeof from === 'function') {
        return {};
    }
    else {
        return from;
    }
}
/**
 * Get the decoding function from a type or a function
 */
export function fromFn(t) {
    if (typeof t === 'function') {
        return t;
    }
    else {
        return t.from;
    }
}
/**
 * Extend a type: take a type and use it as a base for another type. Much like using the spread operator:
 * ```
 * const newType = { ...oldType }
 * ```
 * but composes the `from` arguments
 *
 * @param base A base type from `InputA` to `OutputA`
 * @param nextTypeOrDecodingFunction Either an entire `Type<OutputA, AnyOutput>` or just a decoding function from `OutputA` to any type
 */
export function extendType(base, nextTypeOrDecodingFunction) {
    const { defaultValue: _defaultValue, from: _from, ...t1WithoutDefault } = base;
    const t2Object = typeDef(nextTypeOrDecodingFunction);
    const t2From = fromFn(nextTypeOrDecodingFunction);
    return {
        ...t1WithoutDefault,
        ...t2Object,
        async from(a) {
            const f1Result = await base.from(a);
            return await t2From(f1Result);
        },
    };
}
//# sourceMappingURL=type.js.map