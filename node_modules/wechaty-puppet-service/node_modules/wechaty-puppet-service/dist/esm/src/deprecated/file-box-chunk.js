import { FileBox } from 'file-box';
import { PassThrough } from 'stream';
import { Transform, } from 'stronger-typed-streams';
import { puppet } from 'wechaty-grpc';
import { nextData } from './next-data.js';
/**
 * @deprecated Will be removed after Dec 31, 2022
 */
const decoder = () => new Transform({
    objectMode: true,
    transform: (chunk, _, callback) => {
        if (!chunk.hasData()) {
            callback(new Error('no data'));
            return;
        }
        const data = chunk.getData();
        callback(null, data);
    },
});
/**
 * @deprecated Will be removed after Dec 31, 2022
 */
async function unpackFileBoxFromChunk(stream) {
    const chunk = await nextData(stream);
    if (!chunk.hasName()) {
        throw new Error('no name');
    }
    const fileName = chunk.getName();
    const fileStream = new PassThrough({ objectMode: true });
    const transformedStream = stream.pipe(decoder());
    transformedStream.pipe(fileStream);
    stream.on('error', e => fileStream.emit('error', e));
    transformedStream.on('error', e => fileStream.emit('error', e));
    const fileBox = FileBox.fromStream(fileStream, fileName);
    return fileBox;
}
/**
 * @deprecated Will be removed after Dec 31, 2022
 */
const encoder = () => new Transform({
    objectMode: true,
    transform: (chunk, _, callback) => {
        const fileBoxChunk = new puppet.FileBoxChunk();
        fileBoxChunk.setData(chunk);
        callback(null, fileBoxChunk);
    },
});
/**
 * @deprecated Will be removed after Dec 31, 2022
 */
async function packFileBoxToChunk(fileBox) {
    const stream = new PassThrough({ objectMode: true });
    const chunk = new puppet.FileBoxChunk();
    chunk.setName(fileBox.name);
    // FIXME: Huan(202010) write might return false
    stream.write(chunk);
    fileBox
        .pipe(encoder())
        .pipe(stream);
    return stream;
}
export { unpackFileBoxFromChunk, packFileBoxToChunk, };
//# sourceMappingURL=file-box-chunk.js.map