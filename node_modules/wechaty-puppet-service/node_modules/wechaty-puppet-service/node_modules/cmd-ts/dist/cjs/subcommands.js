"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.subcommands = void 0;
const positional_1 = require("./positional");
const chalk_1 = __importDefault(require("chalk"));
const circuitbreaker_1 = require("./circuitbreaker");
const Result = __importStar(require("./Result"));
const didyoumean_1 = __importDefault(require("didyoumean"));
/**
 * Combine multiple `command`s into one
 */
function subcommands(config) {
    const circuitbreaker = circuitbreaker_1.createCircuitBreaker(!!config.version);
    const type = {
        async from(str) {
            const commands = Object.entries(config.cmds)
                .map(([name, cmd]) => {
                var _a;
                return {
                    cmdName: name,
                    names: [name, ...((_a = cmd.aliases) !== null && _a !== void 0 ? _a : [])],
                };
            });
            const cmd = commands
                .find(x => x.names.includes(str));
            if (cmd) {
                return cmd.cmdName;
            }
            let errorMessage = `Not a valid subcommand name`;
            const closeOptions = didyoumean_1.default(str, flatMap(commands, x => x.names));
            if (closeOptions) {
                const option = Array.isArray(closeOptions) ? closeOptions[0] : closeOptions;
                errorMessage += `\nDid you mean ${chalk_1.default.italic(option)}?`;
            }
            throw new Error(errorMessage);
        },
    };
    const subcommand = positional_1.positional({
        displayName: 'subcommand',
        description: 'one of ' + Object.keys(config.cmds).join(', '),
        type,
    });
    return {
        version: config.version,
        description: config.description,
        name: config.name,
        handler: value => {
            const cmd = config.cmds[value.command];
            return cmd.handler(value.args);
        },
        register(opts) {
            for (const cmd of Object.values(config.cmds)) {
                cmd.register(opts);
            }
            circuitbreaker.register(opts);
        },
        printHelp(context) {
            var _a, _b, _c, _d;
            const lines = [];
            const argsSoFar = (_b = (_a = context.hotPath) === null || _a === void 0 ? void 0 : _a.join(' ')) !== null && _b !== void 0 ? _b : 'cli';
            lines.push(chalk_1.default.bold(argsSoFar + chalk_1.default.italic(' <subcommand>')));
            if (config.description) {
                lines.push(chalk_1.default.dim('> ') + config.description);
            }
            lines.push('');
            lines.push(`where ${chalk_1.default.italic('<subcommand>')} can be one of:`);
            lines.push('');
            for (const key of Object.keys(config.cmds)) {
                const cmd = config.cmds[key];
                let description = (_c = cmd.description) !== null && _c !== void 0 ? _c : '';
                description = description && ' - ' + description + ' ';
                if ((_d = cmd.aliases) === null || _d === void 0 ? void 0 : _d.length) {
                    const aliasTxt = cmd.aliases.length === 1 ? 'alias' : 'aliases';
                    const aliases = cmd.aliases.join(', ');
                    description += chalk_1.default.dim(`[${aliasTxt}: ${aliases}]`);
                }
                const row = chalk_1.default.dim('- ') + key + description;
                lines.push(row.trim());
            }
            const helpCommand = chalk_1.default.yellow(`${argsSoFar} <subcommand> --help`);
            lines.push('');
            lines.push(chalk_1.default.dim(`For more help, try running \`${helpCommand}\``));
            return lines.join('\n');
        },
        async parse(context) {
            var _a, _b;
            if (((_a = context.hotPath) === null || _a === void 0 ? void 0 : _a.length) === 0) {
                context.hotPath.push(config.name);
            }
            const parsed = await subcommand.parse(context);
            if (Result.isErr(parsed)) {
                return Result.err({
                    errors: parsed.error.errors,
                    partialValue: {},
                });
            }
            (_b = context.hotPath) === null || _b === void 0 ? void 0 : _b.push(parsed.value);
            const cmd = config.cmds[parsed.value];
            const parsedCommand = await cmd.parse(context);
            if (Result.isErr(parsedCommand)) {
                return Result.err({
                    errors: parsedCommand.error.errors,
                    partialValue: {
                        command: parsed.value,
                        args: parsedCommand.error.partialValue,
                    },
                });
            }
            return Result.ok({
                args: parsedCommand.value,
                command: parsed.value,
            });
        },
        async run(context) {
            var _a, _b;
            if (((_a = context.hotPath) === null || _a === void 0 ? void 0 : _a.length) === 0) {
                context.hotPath.push(config.name);
            }
            const parsedSubcommand = await subcommand.parse(context);
            if (Result.isErr(parsedSubcommand)) {
                const breaker = await circuitbreaker.parse(context);
                circuitbreaker_1.handleCircuitBreaker(context, this, breaker);
                return Result.err({ ...parsedSubcommand.error, partialValue: {} });
            }
            (_b = context.hotPath) === null || _b === void 0 ? void 0 : _b.push(parsedSubcommand.value);
            const cmd = config.cmds[parsedSubcommand.value];
            const commandRun = await cmd.run(context);
            if (Result.isOk(commandRun)) {
                return Result.ok({
                    command: parsedSubcommand.value,
                    value: commandRun.value,
                });
            }
            return Result.err({
                ...commandRun.error,
                partialValue: {
                    command: parsedSubcommand.value,
                    value: commandRun.error.partialValue,
                },
            });
        },
    };
}
exports.subcommands = subcommands;
function flatMap(array, f) {
    const rs = [];
    for (const item of array) {
        rs.push(...f(item));
    }
    return rs;
}
//# sourceMappingURL=subcommands.js.map