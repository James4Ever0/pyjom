{"version":3,"sources":["iterable/operators/tap.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,SAAS,EAAE,MAAM,cAAc,CAAC;AAGzC,OAAO,EAAE,UAAU,EAAE,MAAM,uBAAuB,CAAC;AAEnD,MAAM,OAAO,WAAqB,SAAQ,SAAkB;IAClD,OAAO,CAAoB;IAC3B,SAAS,CAA2B;IAE5C,YAAY,MAAyB,EAAE,QAAkC;QACvE,KAAK,EAAE,CAAC;QACR,IAAI,CAAC,OAAO,GAAG,MAAM,CAAC;QACtB,IAAI,CAAC,SAAS,GAAG,QAAQ,CAAC;IAC5B,CAAC;IAED,CAAC,CAAC,MAAM,CAAC,QAAQ,CAAC;QAChB,MAAM,EAAE,GAAG,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,QAAQ,CAAC,EAAE,CAAC;QAC3C,OAAO,CAAC,EAAE;YACR,IAAI,IAAI,CAAC;YACT,IAAI;gBACF,IAAI,GAAG,EAAE,CAAC,IAAI,EAAE,CAAC;gBACjB,IAAI,IAAI,CAAC,IAAI,EAAE;oBACb,MAAM;iBACP;aACF;YAAC,OAAO,CAAC,EAAE;gBACV,IAAI,IAAI,CAAC,SAAS,CAAC,KAAK,EAAE;oBACxB,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;iBACzB;gBACD,MAAM,CAAC,CAAC;aACT;YAED,IAAI,IAAI,CAAC,SAAS,CAAC,IAAI,EAAE;gBACvB,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;aACjC;YACD,MAAM,IAAI,CAAC,KAAK,CAAC;SAClB;QAED,IAAI,IAAI,CAAC,SAAS,CAAC,QAAQ,EAAE;YAC3B,IAAI,CAAC,SAAS,CAAC,QAAQ,EAAE,CAAC;SAC3B;IACH,CAAC;CACF;AA8BD;;;;;;;;;;;GAWG;AACH,MAAM,UAAU,GAAG,CACjB,cAA4E,EAC5E,KAAkC,EAClC,QAA6B;IAE7B,OAAO,SAAS,mBAAmB,CAAC,MAAyB;QAC3D,OAAO,IAAI,WAAW,CAAU,MAAM,EAAE,UAAU,CAAC,cAAc,EAAE,KAAK,EAAE,QAAQ,CAAC,CAAC,CAAC;IACvF,CAAC,CAAC;AACJ,CAAC","file":"tap.js","sourcesContent":["import { IterableX } from '../iterablex';\nimport { PartialObserver } from '../../observer';\nimport { MonoTypeOperatorFunction } from '../../interfaces';\nimport { toObserver } from '../../util/toobserver';\n\nexport class TapIterable<TSource> extends IterableX<TSource> {\n  private _source: Iterable<TSource>;\n  private _observer: PartialObserver<TSource>;\n\n  constructor(source: Iterable<TSource>, observer: PartialObserver<TSource>) {\n    super();\n    this._source = source;\n    this._observer = observer;\n  }\n\n  *[Symbol.iterator]() {\n    const it = this._source[Symbol.iterator]();\n    while (1) {\n      let next;\n      try {\n        next = it.next();\n        if (next.done) {\n          break;\n        }\n      } catch (e) {\n        if (this._observer.error) {\n          this._observer.error(e);\n        }\n        throw e;\n      }\n\n      if (this._observer.next) {\n        this._observer.next(next.value);\n      }\n      yield next.value;\n    }\n\n    if (this._observer.complete) {\n      this._observer.complete();\n    }\n  }\n}\n\n/**\n * Invokes an action for each element in the iterable sequence, and propagates all observer\n * messages through the result sequence. This method can be used for debugging, logging, etc. by\n * intercepting the message stream to run arbitrary actions for messages on the pipeline.\n *\n * @template TSource The type of the elements in the source sequence.\n * @param {PartialObserver<TSource>} observer Observer whose methods to invoke as part of the source sequence's observation.\n * @returns {MonoTypeOperatorFunction<TSource>} The source sequence with the side-effecting behavior applied.\n */\nexport function tap<TSource>(observer: PartialObserver<TSource>): MonoTypeOperatorFunction<TSource>;\n\n/**\n * Invokes an action for each element in the iterable sequence, and propagates all observer\n * messages through the result sequence. This method can be used for debugging, logging, etc. by\n * intercepting the message stream to run arbitrary actions for messages on the pipeline.\n *\n * @template TSource The type of the elements in the source sequence.\n * @param {(((value: TSource) => any) | null)} [next] Function to invoke for each element in the iterable sequence.\n * @param {(((err: any) => any) | null)} [error] Function to invoke upon exceptional termination of the iterable sequence.\n * @param {((() => any) | null)} [complete] Function to invoke upon graceful termination of the iterable sequence.\n * @returns {MonoTypeOperatorFunction<TSource>} The source sequence with the side-effecting behavior applied.\n */\nexport function tap<TSource>(\n  next?: ((value: TSource) => any) | null,\n  error?: ((err: any) => any) | null,\n  complete?: (() => any) | null\n): MonoTypeOperatorFunction<TSource>;\n\n/**\n * Invokes an action for each element in the iterable sequence, and propagates all observer\n * messages through the result sequence. This method can be used for debugging, logging, etc. by\n * intercepting the message stream to run arbitrary actions for messages on the pipeline.\n *\n * @template TSource The type of the elements in the source sequence.\n * @param {(PartialObserver<TSource> | ((value: TSource) => any) | null)} [observerOrNext] Observer whose methods to invoke as\n * part of the source sequence's observation or a function to invoke for each element in the iterable sequence.\n * @param {(((err: any) => any) | null)} [error] Function to invoke upon exceptional termination of the iterable sequence.\n * @param {((() => any) | null)} [complete] Function to invoke upon graceful termination of the iterable sequence.\n * @returns {MonoTypeOperatorFunction<TSource>} The source sequence with the side-effecting behavior applied.\n */\nexport function tap<TSource>(\n  observerOrNext?: PartialObserver<TSource> | ((value: TSource) => any) | null,\n  error?: ((err: any) => any) | null,\n  complete?: (() => any) | null\n): MonoTypeOperatorFunction<TSource> {\n  return function tapOperatorFunction(source: Iterable<TSource>): IterableX<TSource> {\n    return new TapIterable<TSource>(source, toObserver(observerOrNext, error, complete));\n  };\n}\n"]}