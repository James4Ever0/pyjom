{"version":3,"sources":["iterable/operators/union.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,SAAS,EAAE,MAAM,cAAc,CAAC;AACzC,OAAO,EAAE,YAAY,EAAE,MAAM,yBAAyB,CAAC;AACvD,OAAO,EAAE,QAAQ,IAAI,eAAe,EAAE,MAAM,qBAAqB,CAAC;AAGlE,MAAM,OAAO,aAAuB,SAAQ,SAAkB;IACpD,KAAK,CAAoB;IACzB,MAAM,CAAoB;IAC1B,SAAS,CAAsC;IAEvD,YACE,IAAuB,EACvB,KAAwB,EACxB,QAA6C;QAE7C,KAAK,EAAE,CAAC;QACR,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC;QAClB,IAAI,CAAC,MAAM,GAAG,KAAK,CAAC;QACpB,IAAI,CAAC,SAAS,GAAG,QAAQ,CAAC;IAC5B,CAAC;IAED,CAAC,CAAC,MAAM,CAAC,QAAQ,CAAC;QAChB,MAAM,GAAG,GAAG,EAAe,CAAC;QAC5B,KAAK,MAAM,KAAK,IAAI,IAAI,CAAC,KAAK,EAAE;YAC9B,IAAI,YAAY,CAAC,GAAG,EAAE,KAAK,EAAE,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC,EAAE;gBACnD,GAAG,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;gBAChB,MAAM,KAAK,CAAC;aACb;SACF;QAED,KAAK,MAAM,KAAK,IAAI,IAAI,CAAC,MAAM,EAAE;YAC/B,IAAI,YAAY,CAAC,GAAG,EAAE,KAAK,EAAE,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC,EAAE;gBACnD,GAAG,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;gBAChB,MAAM,KAAK,CAAC;aACb;SACF;IACH,CAAC;CACF;AAED;;;;;;;;GAQG;AACH,MAAM,UAAU,KAAK,CACnB,KAAwB,EACxB,WAAgD,eAAe;IAE/D,OAAO,SAAS,qBAAqB,CAAC,IAAuB;QAC3D,OAAO,IAAI,aAAa,CAAU,IAAI,EAAE,KAAK,EAAE,QAAQ,CAAC,CAAC;IAC3D,CAAC,CAAC;AACJ,CAAC","file":"union.js","sourcesContent":["import { IterableX } from '../iterablex';\nimport { arrayIndexOf } from '../../util/arrayindexof';\nimport { comparer as defaultComparer } from '../../util/comparer';\nimport { MonoTypeOperatorFunction } from '../../interfaces';\n\nexport class UnionIterable<TSource> extends IterableX<TSource> {\n  private _left: Iterable<TSource>;\n  private _right: Iterable<TSource>;\n  private _comparer: (x: TSource, y: TSource) => boolean;\n\n  constructor(\n    left: Iterable<TSource>,\n    right: Iterable<TSource>,\n    comparer: (x: TSource, y: TSource) => boolean\n  ) {\n    super();\n    this._left = left;\n    this._right = right;\n    this._comparer = comparer;\n  }\n\n  *[Symbol.iterator]() {\n    const map = [] as TSource[];\n    for (const lItem of this._left) {\n      if (arrayIndexOf(map, lItem, this._comparer) === -1) {\n        map.push(lItem);\n        yield lItem;\n      }\n    }\n\n    for (const rItem of this._right) {\n      if (arrayIndexOf(map, rItem, this._comparer) === -1) {\n        map.push(rItem);\n        yield rItem;\n      }\n    }\n  }\n}\n\n/**\n * Produces the set union of two sequences by using the given equality comparer.\n *\n * @template TSource The type of the elements of the input sequences.\n * @param {AsyncIterable<TSource>} right An iterable sequence whose distinct elements form the second set for the union.\n * @param {((x: TSource, y: TSource) => boolean)} [comparer=defaultComparer] The equality comparer to compare values.\n * @returns {MonoTypeOperatorFunction<TSource>} An iterable sequence that contains the elements from both input sequences,\n * excluding duplicates.\n */\nexport function union<TSource>(\n  right: Iterable<TSource>,\n  comparer: (x: TSource, y: TSource) => boolean = defaultComparer\n): MonoTypeOperatorFunction<TSource> {\n  return function unionOperatorFunction(left: Iterable<TSource>): IterableX<TSource> {\n    return new UnionIterable<TSource>(left, right, comparer);\n  };\n}\n"]}