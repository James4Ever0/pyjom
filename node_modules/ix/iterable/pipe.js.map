{"version":3,"sources":["iterable/pipe.ts"],"names":[],"mappings":";;;AACA,2CAAwC;AACxC,iCAA8B;AAyE9B,SAAgB,IAAI,CAClB,MAAyB,EACzB,GAAG,UAAgD;IAEnD,IAAI,UAAU,CAAC,MAAM,KAAK,CAAC,EAAE;QAC3B,OAAO,MAAM,YAAY,qBAAS,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,WAAI,CAAC,MAAM,CAAC,CAAC;KAC5D;IAED,MAAM,KAAK,GAAG,CAAC,KAAwB,EAAsB,EAAE;QAC7D,OAAO,UAAU,CAAC,MAAM,CACtB,CAAC,IAAS,EAAE,EAAsC,EAAE,EAAE,CAAC,EAAE,CAAC,IAAI,CAAC,EAC/D,KAAY,CACb,CAAC;IACJ,CAAC,CAAC;IAEF,OAAO,KAAK,CAAC,MAAM,CAAC,CAAC;AACvB,CAAC;AAhBD,oBAgBC","file":"pipe.js","sourcesContent":["import { OperatorFunction } from '../interfaces';\nimport { IterableX } from './iterablex';\nimport { from } from './from';\n\nexport function pipe<T>(source: Iterable<T>): IterableX<T>;\nexport function pipe<T, A>(source: Iterable<T>, op1: OperatorFunction<T, A>): IterableX<A>;\nexport function pipe<T, A, B>(\n  source: Iterable<T>,\n  op1: OperatorFunction<T, A>,\n  op2: OperatorFunction<A, B>\n): IterableX<B>;\nexport function pipe<T, A, B, C>(\n  source: Iterable<T>,\n  op1: OperatorFunction<T, A>,\n  op2: OperatorFunction<A, B>,\n  op3: OperatorFunction<B, C>\n): IterableX<C>;\nexport function pipe<T, A, B, C, D>(\n  source: Iterable<T>,\n  op1: OperatorFunction<T, A>,\n  op2: OperatorFunction<A, B>,\n  op3: OperatorFunction<B, C>,\n  op4: OperatorFunction<C, D>\n): IterableX<D>;\nexport function pipe<T, A, B, C, D, E>(\n  source: Iterable<T>,\n  op1: OperatorFunction<T, A>,\n  op2: OperatorFunction<A, B>,\n  op3: OperatorFunction<B, C>,\n  op4: OperatorFunction<C, D>,\n  op5: OperatorFunction<D, E>\n): IterableX<E>;\nexport function pipe<T, A, B, C, D, E, F>(\n  source: Iterable<T>,\n  op1: OperatorFunction<T, A>,\n  op2: OperatorFunction<A, B>,\n  op3: OperatorFunction<B, C>,\n  op4: OperatorFunction<C, D>,\n  op5: OperatorFunction<D, E>,\n  op6: OperatorFunction<E, F>\n): IterableX<F>;\nexport function pipe<T, A, B, C, D, E, F, G>(\n  source: Iterable<T>,\n  op1: OperatorFunction<T, A>,\n  op2: OperatorFunction<A, B>,\n  op3: OperatorFunction<B, C>,\n  op4: OperatorFunction<C, D>,\n  op5: OperatorFunction<D, E>,\n  op6: OperatorFunction<E, F>,\n  op7: OperatorFunction<F, G>\n): IterableX<G>;\nexport function pipe<T, A, B, C, D, E, F, G, H>(\n  source: Iterable<T>,\n  op1: OperatorFunction<T, A>,\n  op2: OperatorFunction<A, B>,\n  op3: OperatorFunction<B, C>,\n  op4: OperatorFunction<C, D>,\n  op5: OperatorFunction<D, E>,\n  op6: OperatorFunction<E, F>,\n  op7: OperatorFunction<F, G>,\n  op8: OperatorFunction<G, H>\n): IterableX<H>;\nexport function pipe<T, A, B, C, D, E, F, G, H, I>(\n  source: Iterable<T>,\n  op1: OperatorFunction<T, A>,\n  op2: OperatorFunction<A, B>,\n  op3: OperatorFunction<B, C>,\n  op4: OperatorFunction<C, D>,\n  op5: OperatorFunction<D, E>,\n  op6: OperatorFunction<E, F>,\n  op7: OperatorFunction<F, G>,\n  op8: OperatorFunction<G, H>,\n  op9: OperatorFunction<H, I>\n): IterableX<I>;\n\nexport function pipe<TSource, TResult>(\n  source: Iterable<TSource>,\n  ...operations: OperatorFunction<TSource, TResult>[]\n): IterableX<TResult> {\n  if (operations.length === 0) {\n    return source instanceof IterableX ? source : from(source);\n  }\n\n  const piped = (input: Iterable<TSource>): IterableX<TResult> => {\n    return operations.reduce(\n      (prev: any, fn: OperatorFunction<TSource, TResult>) => fn(prev),\n      input as any\n    );\n  };\n\n  return piped(source);\n}\n"]}