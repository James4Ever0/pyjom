{"version":3,"sources":["iterable/sequenceequal.ts"],"names":[],"mappings":";;;AAAA,+CAA+D;AAiB/D;;;;;;;;;GASG;AACH,SAAgB,aAAa,CAC3B,MAAmB,EACnB,KAAkB,EAClB,OAAgC;IAEhC,MAAM,EAAE,CAAC,UAAU,CAAC,EAAE,QAAQ,GAAG,mBAAe,EAAE,GAAG,OAAO,IAAI,EAAE,CAAC;IACnE,MAAM,GAAG,GAAG,MAAM,CAAC,MAAM,CAAC,QAAQ,CAAC,EAAE,CAAC;IACtC,MAAM,GAAG,GAAG,KAAK,CAAC,MAAM,CAAC,QAAQ,CAAC,EAAE,CAAC;IACrC,IAAI,KAAwB,CAAC;IAC7B,IAAI,KAAwB,CAAC;IAC7B,OAAO,CAAC,CAAC,KAAK,GAAG,GAAG,CAAC,IAAI,EAAE,CAAC,CAAC,IAAI,EAAE;QACjC,IAAI,CAAC,CAAC,CAAC,CAAC,KAAK,GAAG,GAAG,CAAC,IAAI,EAAE,CAAC,CAAC,IAAI,IAAI,QAAQ,CAAC,KAAK,CAAC,KAAK,EAAE,KAAK,CAAC,KAAK,CAAC,CAAC,EAAE;YACvE,OAAO,KAAK,CAAC;SACd;KACF;IAED,OAAO,CAAC,CAAC,GAAG,CAAC,IAAI,EAAE,CAAC,IAAI,CAAC;AAC3B,CAAC;AAjBD,sCAiBC","file":"sequenceequal.js","sourcesContent":["import { comparer as defaultComparer } from '../util/comparer';\n\n/**\n * The options for sequence equal operations including a comparer and abort signal\n *\n * @interface SequencEqualOptions\n * @template T The type of items to compare.\n */\nexport interface SequencEqualOptions<T> {\n  /**\n   * The comparer function which returns true if the items are equal, false otherwise.\n   *\n   * @memberof SequencEqualOptions\n   */\n  comparer?: (first: T, second: T) => boolean;\n}\n\n/**\n * Determines whether two sequences are equal by comparing the elements pairwise.\n *\n * @template T The type of the elements in the source sequence.\n * @param {Iterable<T>} source First iterable sequence to compare.\n * @param {Iterable<T>} other Second iterable sequence to compare.\n * @param {SequencEqualOptions<T>} [options] The sequence equal options which include an optional comparer and optional abort signal.\n * @returns {boolean} A promise which indicates whether both sequences are of equal length and their\n * corresponding elements are equal.\n */\nexport function sequenceEqual<T>(\n  source: Iterable<T>,\n  other: Iterable<T>,\n  options?: SequencEqualOptions<T>\n): boolean {\n  const { ['comparer']: comparer = defaultComparer } = options || {};\n  const it1 = source[Symbol.iterator]();\n  const it2 = other[Symbol.iterator]();\n  let next1: IteratorResult<T>;\n  let next2: IteratorResult<T>;\n  while (!(next1 = it1.next()).done) {\n    if (!(!(next2 = it2.next()).done && comparer(next1.value, next2.value))) {\n      return false;\n    }\n  }\n\n  return !!it2.next().done;\n}\n"]}