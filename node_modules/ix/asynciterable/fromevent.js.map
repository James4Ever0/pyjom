{"version":3,"sources":["asynciterable/fromevent.ts"],"names":[],"mappings":";;;AACA,yDAAsD;AAiBtD,SAAS,kBAAkB,CAAC,GAAQ;IAClC,OAAO,CAAC,CAAC,GAAG,IAAI,OAAO,GAAG,CAAC,WAAW,KAAK,UAAU,IAAI,OAAO,GAAG,CAAC,cAAc,KAAK,UAAU,CAAC;AACpG,CAAC;AAED,SAAS,aAAa,CAAC,GAAQ;IAC7B,OAAO,CACL,CAAC,CAAC,GAAG;QACL,OAAO,GAAG,CAAC,gBAAgB,KAAK,UAAU;QAC1C,OAAO,GAAG,CAAC,mBAAmB,KAAK,UAAU,CAC9C,CAAC;AACJ,CAAC;AAED;;;;;;;;GAQG;AACH,SAAgB,SAAS,CACvB,GAAkB,EAClB,IAAY,EACZ,OAA8B;IAE9B,IAAI,aAAa,CAAC,GAAG,CAAC,EAAE;QACtB,MAAM,MAAM,GAAgB,GAAG,CAAC;QAChC,OAAO,mCAAgB,CACrB,CAAC,CAAC,EAAE,EAAE,CAAC,MAAM,CAAC,gBAAgB,CAAC,IAAI,EAAiB,CAAC,EAAE,OAAO,CAAC,EAC/D,CAAC,CAAC,EAAE,EAAE,CAAC,MAAM,CAAC,mBAAmB,CAAC,IAAI,EAAiB,CAAC,EAAE,OAAO,CAAC,CACnE,CAAC;KACH;SAAM,IAAI,kBAAkB,CAAC,GAAG,CAAC,EAAE;QAClC,MAAM,MAAM,GAAqB,GAAG,CAAC;QACrC,OAAO,mCAAgB,CACrB,CAAC,CAAC,EAAE,EAAE,CAAC,MAAM,CAAC,WAAW,CAAC,IAAI,EAAE,CAAC,CAAC,EAClC,CAAC,CAAC,EAAE,EAAE,CAAC,MAAM,CAAC,cAAc,CAAC,IAAI,EAAE,CAAC,CAAC,CACtC,CAAC;KACH;SAAM;QACL,MAAM,IAAI,SAAS,CAAC,0BAA0B,CAAC,CAAC;KACjD;AACH,CAAC;AApBD,8BAoBC","file":"fromevent.js","sourcesContent":["import { AsyncIterableX } from './asynciterablex';\nimport { fromEventPattern } from './fromeventpattern';\n\nexport interface NodeEventEmitter {\n  addListener(event: string | symbol, listener: (...args: any[]) => void): this;\n  removeListener(event: string | symbol, listener: (...args: any[]) => void): this;\n}\n\nexport type EventListenerOptions =\n  | {\n      capture?: boolean;\n      passive?: boolean;\n      once?: boolean;\n    }\n  | boolean;\n\nexport type EventedTarget = EventTarget | NodeEventEmitter;\n\nfunction isNodeEventEmitter(obj: any): obj is NodeEventEmitter {\n  return !!obj && typeof obj.addListener === 'function' && typeof obj.removeListener === 'function';\n}\n\nfunction isEventTarget(obj: any): obj is EventTarget {\n  return (\n    !!obj &&\n    typeof obj.addEventListener === 'function' &&\n    typeof obj.removeEventListener === 'function'\n  );\n}\n\n/**\n * Converts an event emitter event into an async-iterable stream.\n *\n * @template TSource The type of elements in the emitter stream.\n * @param {EventedTarget} obj The object that emits the events to turn into an async-iterable.\n * @param {string} type The name of the event to listen for creation of the async-iterable.\n * @param {EventListenerOptions} [options] The options for listening to the events such as capture, passive and once.\n * @returns {AsyncIterableX<TSource>} An async-iterable sequence created from the events emitted from the evented target.\n */\nexport function fromEvent<TSource>(\n  obj: EventedTarget,\n  type: string,\n  options?: EventListenerOptions\n): AsyncIterableX<TSource> {\n  if (isEventTarget(obj)) {\n    const target = <EventTarget>obj;\n    return fromEventPattern<TSource>(\n      (h) => target.addEventListener(type, <EventListener>h, options),\n      (h) => target.removeEventListener(type, <EventListener>h, options)\n    );\n  } else if (isNodeEventEmitter(obj)) {\n    const target = <NodeEventEmitter>obj;\n    return fromEventPattern<TSource>(\n      (h) => target.addListener(type, h),\n      (h) => target.removeListener(type, h)\n    );\n  } else {\n    throw new TypeError('Unsupported event target');\n  }\n}\n"]}