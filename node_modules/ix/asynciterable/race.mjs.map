{"version":3,"sources":["asynciterable/race.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,cAAc,EAAE,MAAM,kBAAkB,CAAC;AAClD,OAAO,EAAE,aAAa,EAAE,MAAM,uBAAuB,CAAC;AACtD,OAAO,EAAE,cAAc,EAAE,MAAM,eAAe,CAAC;AAC/C,OAAO,EAAE,QAAQ,EAAE,MAAM,kBAAkB,CAAC;AAI5C,SAAS,oBAAoB,CAAI,OAAmB,EAAE,KAAa;IACjE,OAAO,OAAO,CAAC,IAAI,CAAC,CAAC,KAAK,EAAE,EAAE,CAAC,CAAC,EAAE,KAAK,EAAE,KAAK,EAAE,CAAC,CAA4B,CAAC;AAChF,CAAC;AAED,MAAM,OAAO,iBAA2B,SAAQ,cAAuB;IAC7D,QAAQ,CAA2B;IAE3C,YAAY,OAAiC;QAC3C,KAAK,EAAE,CAAC;QACR,IAAI,CAAC,QAAQ,GAAG,OAAO,CAAC;IAC1B,CAAC;IAED,KAAK,CAAC,CAAC,CAAC,MAAM,CAAC,aAAa,CAAC,CAAC,MAAoB;QAChD,cAAc,CAAC,MAAM,CAAC,CAAC;QACvB,MAAM,OAAO,GAAG,IAAI,CAAC,QAAQ,CAAC;QAC9B,MAAM,MAAM,GAAG,OAAO,CAAC,MAAM,CAAC;QAE9B,MAAM,SAAS,GAAG,IAAI,KAAK,CAAyB,MAAM,CAAC,CAAC;QAC5D,MAAM,KAAK,GAAG,IAAI,KAAK,CAAgD,MAAM,CAAC,CAAC;QAE/E,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,MAAM,EAAE,CAAC,EAAE,EAAE;YAC/B,MAAM,QAAQ,GAAG,aAAa,CAAU,OAAO,CAAC,CAAC,CAAC,EAAE,MAAM,CAAC,CAAC,MAAM,CAAC,aAAa,CAAC,EAAE,CAAC;YACpF,SAAS,CAAC,CAAC,CAAC,GAAG,QAAQ,CAAC;YACxB,KAAK,CAAC,CAAC,CAAC,GAAG,oBAAoB,CAAC,QAAQ,CAAC,IAAI,EAAE,EAAE,CAAC,CAAC,CAAC;SACrD;QAED,MAAM,IAAI,GAAG,QAAQ,CAAC,KAAK,CAAC,CAAC;QAC7B,MAAM,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,GAAG,MAAM,IAAI,CAAC;QAE3C,IAAI,CAAC,KAAK,CAAC,IAAI,EAAE;YACf,MAAM,KAAK,CAAC,KAAK,CAAC;SACnB;QAED,MAAM,SAAS,GAAG,SAAS,CAAC,KAAK,CAAC,CAAC;QAEnC,gCAAgC;QAChC,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,MAAM,EAAE,CAAC,EAAE,EAAE;YAC/B,IAAI,CAAC,KAAK,KAAK,EAAE;gBACf,SAAS;aACV;YAED,MAAM,aAAa,GAAG,SAAS,CAAC,CAAC,CAAC,CAAC;YACnC,IAAI,aAAa,CAAC,MAAM,EAAE;gBACxB,aAAa,CAAC,MAAM,EAAE,CAAC;aACxB;SACF;QAED,IAAI,QAAQ,CAAC;QACb,OAAO,CAAC,CAAC,QAAQ,GAAG,MAAM,SAAS,CAAC,IAAI,EAAE,CAAC,CAAC,IAAI,EAAE;YAChD,MAAM,QAAQ,CAAC,KAAK,CAAC;SACtB;IACH,CAAC;CACF;AAED;;;;;GAKG;AACH,MAAM,UAAU,IAAI,CAAU,GAAG,OAAiC;IAChE,OAAO,IAAI,iBAAiB,CAAU,OAAO,CAAC,CAAC;AACjD,CAAC","file":"race.js","sourcesContent":["import { AsyncIterableX } from './asynciterablex';\nimport { wrapWithAbort } from './operators/withabort';\nimport { throwIfAborted } from '../aborterror';\nimport { safeRace } from '../util/safeRace';\n\ntype MergeResult<T> = { value: T; index: number };\n\nfunction wrapPromiseWithIndex<T>(promise: Promise<T>, index: number) {\n  return promise.then((value) => ({ value, index })) as Promise<MergeResult<T>>;\n}\n\nexport class RaceAsyncIterable<TSource> extends AsyncIterableX<TSource> {\n  private _sources: AsyncIterable<TSource>[];\n\n  constructor(sources: AsyncIterable<TSource>[]) {\n    super();\n    this._sources = sources;\n  }\n\n  async *[Symbol.asyncIterator](signal?: AbortSignal) {\n    throwIfAborted(signal);\n    const sources = this._sources;\n    const length = sources.length;\n\n    const iterators = new Array<AsyncIterator<TSource>>(length);\n    const nexts = new Array<Promise<MergeResult<IteratorResult<TSource>>>>(length);\n\n    for (let i = 0; i < length; i++) {\n      const iterator = wrapWithAbort<TSource>(sources[i], signal)[Symbol.asyncIterator]();\n      iterators[i] = iterator;\n      nexts[i] = wrapPromiseWithIndex(iterator.next(), i);\n    }\n\n    const next = safeRace(nexts);\n    const { value: next$, index } = await next;\n\n    if (!next$.done) {\n      yield next$.value;\n    }\n\n    const iterator$ = iterators[index];\n\n    // Cancel/finish other iterators\n    for (let i = 0; i < length; i++) {\n      if (i === index) {\n        continue;\n      }\n\n      const otherIterator = iterators[i];\n      if (otherIterator.return) {\n        otherIterator.return();\n      }\n    }\n\n    let nextItem;\n    while (!(nextItem = await iterator$.next()).done) {\n      yield nextItem.value;\n    }\n  }\n}\n\n/**\n * Propagates the async sequence that reacts first.\n *\n * @param {...AsyncIterable<T>[]} sources The source sequences.\n * @return {AsyncIterable<T>} An async sequence that surfaces either of the given sequences, whichever reacted first.\n */\nexport function race<TSource>(...sources: AsyncIterable<TSource>[]): AsyncIterableX<TSource> {\n  return new RaceAsyncIterable<TSource>(sources);\n}\n"]}