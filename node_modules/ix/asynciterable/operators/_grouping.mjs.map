{"version":3,"sources":["asynciterable/operators/_grouping.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,aAAa,EAAE,MAAM,aAAa,CAAC;AAE5C;;GAEG;AACH,MAAM,CAAC,KAAK,UAAU,cAAc,CAClC,MAA8B,EAC9B,WAA2E,EAC3E,eAAmF,EACnF,MAAoB;IAEpB,MAAM,GAAG,GAAG,IAAI,GAAG,EAAkB,CAAC;IACtC,IAAI,KAAK,EAAE,MAAM,IAAI,IAAI,aAAa,CAAC,MAAM,EAAE,MAAM,CAAC,EAAE;QACtD,MAAM,GAAG,GAAG,MAAM,WAAW,CAAC,IAAI,EAAE,MAAM,CAAC,CAAC;QAC5C,IAAI,QAAQ,GAAG,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;QAC5B,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE;YACjB,QAAQ,GAAG,EAAE,CAAC;YACd,GAAG,CAAC,GAAG,CAAC,GAAG,EAAE,QAAQ,CAAC,CAAC;SACxB;QACD,MAAM,OAAO,GAAG,MAAM,eAAe,CAAC,IAAI,EAAE,MAAM,CAAC,CAAC;QACpD,QAAS,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;KACzB;IAED,OAAO,GAAG,CAAC;AACb,CAAC","file":"_grouping.js","sourcesContent":["import { wrapWithAbort } from './withabort';\n\n/**\n * @ignore\n */\nexport async function createGrouping<TSource, TKey, TValue>(\n  source: AsyncIterable<TSource>,\n  keySelector: (value: TSource, signal?: AbortSignal) => TKey | Promise<TKey>,\n  elementSelector: (value: TSource, signal?: AbortSignal) => TValue | Promise<TValue>,\n  signal?: AbortSignal\n): Promise<Map<TKey, TValue[]>> {\n  const map = new Map<TKey, TValue[]>();\n  for await (const item of wrapWithAbort(source, signal)) {\n    const key = await keySelector(item, signal);\n    let grouping = map.get(key);\n    if (!map.has(key)) {\n      grouping = [];\n      map.set(key, grouping);\n    }\n    const element = await elementSelector(item, signal);\n    grouping!.push(element);\n  }\n\n  return map;\n}\n"]}