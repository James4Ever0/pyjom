{"version":3,"sources":["asynciterable/operators/takeuntil.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,cAAc,EAAE,MAAM,mBAAmB,CAAC;AAEnD,OAAO,EAAE,aAAa,EAAE,MAAM,aAAa,CAAC;AAC5C,OAAO,EAAE,cAAc,EAAE,MAAM,kBAAkB,CAAC;AAClD,OAAO,EAAE,QAAQ,EAAE,MAAM,qBAAqB,CAAC;AAE/C,MAAM,kBAAkB,GAAG,SAAS,CAAC;AAErC,MAAM,OAAO,sBAAgC,SAAQ,cAAuB;IAClE,OAAO,CAAyB;IAChC,MAAM,CAAyC;IAEvD,YAAY,MAA8B,EAAE,KAA6C;QACvF,KAAK,EAAE,CAAC;QACR,IAAI,CAAC,OAAO,GAAG,MAAM,CAAC;QACtB,IAAI,CAAC,MAAM,GAAG,KAAK,CAAC;IACtB,CAAC;IAED,KAAK,CAAC,CAAC,CAAC,MAAM,CAAC,aAAa,CAAC,CAAC,MAAoB;QAChD,cAAc,CAAC,MAAM,CAAC,CAAC;QACvB,MAAM,WAAW,GAAG,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC,IAAI,CAAC,GAAG,EAAE,CAAC,kBAAkB,CAAC,CAAC;QACvE,MAAM,kBAAkB,GAAG,aAAa,CAAC,IAAI,CAAC,OAAO,EAAE,MAAM,CAAC,CAAC,MAAM,CAAC,aAAa,CAAC,EAAE,CAAC;QACvF,SAAS;YACP,MAAM,WAAW,GAAG,kBAAkB,CAAC,IAAI,EAAE,CAAC;YAC9C,MAAM,MAAM,GAAG,MAAM,QAAQ,CAAC,CAAC,WAAW,EAAE,WAAW,CAAC,CAAC,CAAC;YAC1D,IAAI,MAAM,KAAK,kBAAkB,IAAI,MAAM,CAAC,IAAI,EAAE;gBAChD,MAAM;aACP;YACD,MAAM,MAAM,CAAC,KAAK,CAAC;SACpB;IACH,CAAC;CACF;AAED;;;;;;;;;GASG;AACH,MAAM,UAAU,SAAS,CACvB,KAA6C;IAE7C,OAAO,SAAS,yBAAyB,CACvC,MAA8B;QAE9B,OAAO,IAAI,sBAAsB,CAAU,MAAM,EAAE,KAAK,CAAC,CAAC;IAC5D,CAAC,CAAC;AACJ,CAAC","file":"takeuntil.js","sourcesContent":["import { AsyncIterableX } from '../asynciterablex';\nimport { MonoTypeOperatorAsyncFunction } from '../../interfaces';\nimport { wrapWithAbort } from './withabort';\nimport { throwIfAborted } from '../../aborterror';\nimport { safeRace } from '../../util/safeRace';\n\nconst DONE_PROMISE_VALUE = undefined;\n\nexport class TakeUntilAsyncIterable<TSource> extends AsyncIterableX<TSource> {\n  private _source: AsyncIterable<TSource>;\n  private _other: (signal?: AbortSignal) => Promise<any>;\n\n  constructor(source: AsyncIterable<TSource>, other: (signal?: AbortSignal) => Promise<any>) {\n    super();\n    this._source = source;\n    this._other = other;\n  }\n\n  async *[Symbol.asyncIterator](signal?: AbortSignal) {\n    throwIfAborted(signal);\n    const donePromise = this._other(signal).then(() => DONE_PROMISE_VALUE);\n    const itemsAsyncIterator = wrapWithAbort(this._source, signal)[Symbol.asyncIterator]();\n    for (;;) {\n      const itemPromise = itemsAsyncIterator.next();\n      const result = await safeRace([donePromise, itemPromise]);\n      if (result === DONE_PROMISE_VALUE || result.done) {\n        break;\n      }\n      yield result.value;\n    }\n  }\n}\n\n/**\n * Returns the elements from the source async-iterable sequence until the other function\n * that returns a promise produces an element.\n *\n * @template TSource The type of the elements in the source sequence.\n * @param {(signal?: AbortSignal) => Promise<any>} other A function that terminates the propagation of\n * elements in the source sequence.\n * @returns {MonoTypeOperatorAsyncFunction<TSource>} An async-iterable sequence containing the elements of the\n * source sequence up to the point the other function which returns a promise interrupted further propagation.\n */\nexport function takeUntil<TSource>(\n  other: (signal?: AbortSignal) => Promise<any>\n): MonoTypeOperatorAsyncFunction<TSource> {\n  return function takeUntilOperatorFunction(\n    source: AsyncIterable<TSource>\n  ): AsyncIterableX<TSource> {\n    return new TakeUntilAsyncIterable<TSource>(source, other);\n  };\n}\n"]}