import type { MapLike } from './map-like.js';
declare type MapLikeNoSync<K, V> = Omit<MapLike<K, V>, typeof Symbol.toStringTag | typeof Symbol.iterator>;
declare type IteratorMethod = 'entries' | 'keys' | 'values';
declare type GetMethod = 'get';
declare type AnyFunction = (...args: any) => any;
declare type AsyncifyIterator<R extends IterableIterator<any>> = R extends IterableIterator<infer I> ? AsyncIterableIterator<I> : never;
/**
 * Asyncify Functions
 */
declare type AsyncifyIteratorFunction<T extends AnyFunction> = (...args: Parameters<T>) => AsyncifyIterator<ReturnType<T>>;
declare type AsyncifyBooleanFunction<T extends AnyFunction> = (...args: Parameters<T>) => Promise<boolean>;
declare type AsyncifyMapFunction<K, V, T extends AnyFunction> = (...args: Parameters<T>) => Promise<AsyncMapLike<K, V>>;
declare type AsyncifySimpleFunction<T extends AnyFunction> = (...args: Parameters<T>) => Promise<ReturnType<T>>;
declare type Asyncify<NAME, T> = T extends AnyFunction ? 
/**
 * Methods
 */
NAME extends IteratorMethod ? AsyncifyIteratorFunction<T> : NAME extends GetMethod ? AsyncifySimpleFunction<T> : NAME extends Symbol ? AsyncifyIteratorFunction<T> : ReturnType<T> extends boolean ? AsyncifyBooleanFunction<T> : ReturnType<T> extends Map<infer IK, infer IV> ? AsyncifyMapFunction<IK, IV, T> : AsyncifySimpleFunction<T> : Promise<T>;
declare type AsyncMapBase<K, V> = {
    [N in keyof MapLikeNoSync<K, V>]: Asyncify<N, MapLikeNoSync<K, V>[N]>;
};
interface AsyncMapIterator<K, V> {
    /**
     * Huan(202111): we have removed the `[Symbol.iterator]`, and add the below `[Symbol.asyncIterator]` for Async
     */
    [Symbol.asyncIterator]: () => AsyncifyIterator<ReturnType<Map<K, V>[typeof Symbol.iterator]>>;
}
declare type AsyncMapLike<K, V> = AsyncMapBase<K, V> & AsyncMapIterator<K, V>;
export type { AsyncMapLike, };
//# sourceMappingURL=async-map-like.d.ts.map