/**
 * File Box
 * https://github.com/huan/file-box
 *
 * 2018 Huan LI <zixia@zixia.net>
 */
/// <reference types="node" />
import type * as HTTP from 'http';
import { Readable, Writable } from 'stream';
import { FileBoxJsonObject, FileBoxOptions, FileBoxType, Metadata, Pipeable, UuidLoader, UuidSaver } from './file-box.type.js';
import type { FileBoxInterface } from './interface.js';
declare class FileBox implements Pipeable, FileBoxInterface {
    /**
     *
     * Static Properties
     *
     */
    static readonly version: string;
    /**
     * Symbol.hasInstance: instanceof
     *
     * @link https://www.keithcirkel.co.uk/metaprogramming-in-es6-symbols/
     */
    static [Symbol.hasInstance](lho: any): lho is FileBoxInterface;
    /**
     * Check if obj satisfy FileBox interface
     */
    static valid(target: any): target is FileBoxInterface;
    /**
     * Check if obj satisfy FileBox interface
     */
    static validInterface(target: any): target is FileBoxInterface;
    /**
     * loose check instance of FileBox
     */
    static validInstance(target: any): target is FileBox;
    static fromUrl(url: string, options?: {
        headers?: HTTP.OutgoingHttpHeaders;
        name?: string;
        size?: number;
        md5?: string;
    }): FileBox;
    /**
     * @deprecated use `fromUrl(url, options)` instead
     */
    static fromUrl(url: string, name?: string, headers?: HTTP.OutgoingHttpHeaders): FileBox;
    /**
     * Alias for `FileBox.fromFile()`
     *
     * @alias fromFile
     */
    static fromFile(path: string, name?: string, md5?: string): FileBox;
    /**
     * TODO: add `FileBoxStreamOptions` with `size` support (@huan, 202111)
     */
    static fromStream(stream: Readable, name?: string, md5?: string): FileBox;
    static fromBuffer(buffer: Buffer, name?: string, md5?: string): FileBox;
    /**
     * @param base64
     * @param name the file name of the base64 data
     */
    static fromBase64(base64: string, name?: string, md5?: string): FileBox;
    /**
     * dataURL: `data:image/png;base64,${base64Text}`,
     */
    static fromDataURL(dataUrl: string, name?: string, md5?: string): FileBox;
    /**
     *
     * @param qrCode the value of the QR Code. For example: `https://github.com`
     */
    static fromQRCode(qrCode: string, md5?: string): FileBox;
    protected static uuidToStream?: UuidLoader;
    protected static uuidFromStream?: UuidSaver;
    static fromUuid(uuid: string, options?: {
        name?: string;
        size?: number;
        md5?: string;
    }): FileBox;
    /**
     * @deprecated use `fromUuid(name, options)` instead
     */
    static fromUuid(uuid: string, name?: string, md5?: string): FileBox;
    /**
     * UUID Type FielBox Loader
     */
    static setUuidLoader(loader: UuidLoader): void;
    /**
     * UUID Type FielBox Saver
     */
    static setUuidSaver(saver: UuidSaver): void;
    /**
     *
     * @static
     * @param {(FileBoxJsonObject | string)} obj
     * @returns {FileBox}
     */
    static fromJSON(obj: FileBoxJsonObject | string): FileBox;
    /**
     *
     * Instance Properties
     *
     */
    readonly version: string;
    /**
     * We are using a getter for `type` is because
     *  getter name can be enumurated by the `Object.hasOwnProperties()`*
     *    but property name can not.
     *
     *  * required by `validInterface()`
     */
    readonly _type: FileBoxType;
    get type(): FileBoxType;
    /**
     * the Content-Length of the file
     *  `SIZE_UNKNOWN(-1)` means unknown
     *
     * @example
     * ```ts
     * const fileBox = FileBox.fromUrl('http://example.com/image.png')
     * await fileBox.ready()
     * console.log(fileBox.size)
     * // > 102400 <- this is the size of the remote image.png
     * ```
     */
    _size?: number;
    get size(): number;
    /**
     * File MD5 Sum
     */
    readonly md5: undefined | string;
    /**
     * @deprecated: use `mediaType` instead. will be removed after Dec 31, 2022
     */
    mimeType: string;
    /**
     * (Internet) Media Type is the proper technical term of `MIME Type`
     *  @see https://stackoverflow.com/a/9277778/1123955
     *
     * @example 'text/plain'
     */
    protected _mediaType?: string;
    get mediaType(): string;
    protected _name: string;
    get name(): string;
    protected _metadata?: Metadata;
    get metadata(): Metadata;
    set metadata(data: Metadata);
    /**
     * Lazy load data: (can be serialized to JSON)
     *  Do not read file to Buffer until there's a consumer.
     */
    private readonly base64?;
    private readonly remoteUrl?;
    private readonly qrCode?;
    private readonly uuid?;
    /**
     * Can not be serialized to JSON
     */
    private readonly buffer?;
    private readonly localPath?;
    private readonly stream?;
    private readonly headers?;
    constructor(options: FileBoxOptions);
    ready(): Promise<void>;
    /**
     * @todo use http.get/gets instead of Request
     */
    protected _syncUrlMetadata(): Promise<void>;
    /**
     *
     * toXXX methods
     *
     */
    toString(): string;
    toJSON(): FileBoxJsonObject;
    toStream(): Promise<Readable>;
    /**
     * https://stackoverflow.com/a/16044400/1123955
     */
    private _transformBufferToStream;
    private _transformBase64ToStream;
    private _transformFileToStream;
    private _transformUrlToStream;
    private _transformQRCodeToStream;
    /**
     * save file
     *
     * @param filePath save file
     */
    toFile(filePath?: string, overwrite?: boolean): Promise<void>;
    toBase64(): Promise<string>;
    /**
     * dataUrl: `data:image/png;base64,${base64Text}',
     */
    toDataURL(): Promise<string>;
    toBuffer(): Promise<Buffer>;
    toQRCode(): Promise<string>;
    toUuid(): Promise<string>;
    /**
     *
     * toXXX methods END
     *
     */
    pipe<T extends Writable>(destination: T): T;
}
export { FileBox, };
//# sourceMappingURL=file-box.d.ts.map