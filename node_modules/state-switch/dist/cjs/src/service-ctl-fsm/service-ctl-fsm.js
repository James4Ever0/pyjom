"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.serviceCtlFsmMixin = exports.ServiceCtlFsm = void 0;
/**
 * Licenst: Apache-2.0
 * https://github.com/huan/state-switch
 */
const xstate_1 = require("xstate");
const version_js_1 = require("../version.js");
const interfaces_js_1 = require("../interfaces.js");
const machine_config_js_1 = require("./machine-config.js");
const machine_options_js_1 = require("./machine-options.js");
const wait_for_selector_js_1 = require("./wait-for-selector.js");
const guard_machine_event_js_1 = require("./guard-machine-event.js");
const brolog_1 = require("brolog");
const state_switch_js_1 = require("../state-switch.js");
const serviceCtlFsmMixin = (serviceCtlName = 'ServiceCtlFsm', options) => (superClass) => {
    class ServiceCtlFsmMixin extends superClass {
        static VERSION = version_js_1.VERSION;
        /**
         * Huan(202110): this state is simple record the start/stop status
         */
        state;
        __serviceCtlLogger;
        __serviceCtlFsmInterpreter;
        constructor(...args) {
            super(...args);
            this.__serviceCtlLogger = (0, brolog_1.getLoggable)(options?.log);
            this.__serviceCtlLogger.verbose(`ServiceCtlFsm<${serviceCtlName}>`, 'constructor()');
            this.state = new state_switch_js_1.StateSwitch(serviceCtlName, options);
            const machineOptions = (0, machine_options_js_1.buildMachineOptions)({
                // reset: () => has been internally implemented by calling stop() and start()
                start: async () => {
                    if (typeof super.start === 'function') {
                        await super.start();
                    }
                    await this.onStart();
                },
                stop: async () => {
                    await this.onStop();
                    if (typeof super.stop === 'function') {
                        await super.stop();
                    }
                },
            });
            const machine = (0, xstate_1.createMachine)(machine_config_js_1.config, machineOptions);
            this.__serviceCtlFsmInterpreter = (0, xstate_1.interpret)(machine);
            this.__serviceCtlFsmInterpreter.start();
        }
        start() {
            this.__serviceCtlLogger.verbose(`ServiceCtlFsm<${serviceCtlName}>`, 'start()');
            (0, guard_machine_event_js_1.guardMachineEvent)(this.__serviceCtlFsmInterpreter, 'START');
            const started = (0, wait_for_selector_js_1.waitForMachineState)(this.__serviceCtlFsmInterpreter, 'active');
            const canceled = (0, wait_for_selector_js_1.waitForMachineState)(this.__serviceCtlFsmInterpreter, 'canceled');
            this.__serviceCtlFsmInterpreter.send('START');
            this.state.active(true);
            return Promise.race([
                started,
                canceled,
            ]).then(() => {
                this.__serviceCtlLogger.verbose(`ServiceCtlFsm<${serviceCtlName}>`, 'start() ... done');
                return undefined;
            });
        }
        stop() {
            this.__serviceCtlLogger.verbose(`ServiceCtlFsm<${serviceCtlName}>`, 'stop()');
            (0, guard_machine_event_js_1.guardMachineEvent)(this.__serviceCtlFsmInterpreter, 'STOP');
            const stopped = (0, wait_for_selector_js_1.waitForMachineState)(this.__serviceCtlFsmInterpreter, 'inactive');
            const canceled = (0, wait_for_selector_js_1.waitForMachineState)(this.__serviceCtlFsmInterpreter, 'canceled');
            this.__serviceCtlFsmInterpreter.send('STOP');
            this.state.inactive(true);
            return Promise.race([
                stopped,
                canceled,
            ]).then(() => {
                this.__serviceCtlLogger.verbose(`ServiceCtlFsm<${serviceCtlName}>`, 'stop() ... done');
                return undefined;
            });
        }
        reset() {
            this.__serviceCtlLogger.verbose(`ServiceCtlFsm<${serviceCtlName}>`, 'reset()');
            (0, guard_machine_event_js_1.guardMachineEvent)(this.__serviceCtlFsmInterpreter, 'RESET');
            const started = (0, wait_for_selector_js_1.waitForMachineState)(this.__serviceCtlFsmInterpreter, 'active');
            const canceled = (0, wait_for_selector_js_1.waitForMachineState)(this.__serviceCtlFsmInterpreter, 'canceled');
            this.__serviceCtlFsmInterpreter.send('RESET');
            // TODO: emit('error' e) if there's any rejections inside `reset()`
            //  or the error should be handled by the onStart/onStop ?
            return Promise.race([
                started,
                canceled,
            ]).then(() => {
                this.__serviceCtlLogger.verbose(`ServiceCtlFsm<${serviceCtlName}>`, 'reset() ... done');
                return undefined;
            });
        }
    }
    return ServiceCtlFsmMixin;
};
exports.serviceCtlFsmMixin = serviceCtlFsmMixin;
class ServiceCtlFsm extends serviceCtlFsmMixin()(interfaces_js_1.ServiceableAbstract) {
}
exports.ServiceCtlFsm = ServiceCtlFsm;
//# sourceMappingURL=service-ctl-fsm.js.map