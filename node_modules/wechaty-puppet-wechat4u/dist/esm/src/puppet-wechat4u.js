/**
 *   Wechaty - https://github.com/chatie/wechaty
 *
 *   @copyright 2016-2018 Huan LI <zixia@zixia.net>
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 */
import Wechat4u from 'wechat4u';
import QuickLru from '@alloc/quick-lru';
import * as PUPPET from 'wechaty-puppet';
import { log } from 'wechaty-puppet';
import { FileBox } from 'file-box';
import { GError } from 'gerror';
import { qrCodeForChatie, retry, VERSION, NAME, } from './config.js';
import { WebMessageType, } from './web-schemas.js';
import { messageRawPayloadParser, } from './pure-function-helpers/mod.js';
// export interface Wechat4uContactRawPayload {
//   name : string,
// }
// export interface WebMessageRawPayload {
//   id   : string,
//   from : string,
//   to   : string,
//   text : string
// }
// export interface Wechat4uRoomRawPayload {
//   topic      : string,
//   memberList : string[],
//   ownerId    : string,
// }
// MemoryCard Slot Name
const MEMORY_SLOT_NAME = 'PUPPET-WECHAT4U';
export class PuppetWechat4u extends PUPPET.Puppet {
    options;
    static VERSION = VERSION;
    /**
     * Wecaht4u
     *
     * Code from:
     * https://github.com/nodeWechat/wechat4u/blob/46931e78bcb56899b8d2a42a37b919e7feaebbef/run-core.js
     *
     */
    wechat4u;
    scanQrCode;
    cacheMessageRawPayload;
    constructor(options = {}) {
        super(options);
        this.options = options;
        const lruOptions = {
            maxAge: 1000 * 60 * 60,
            maxSize: 10000,
            onEviction(key, val) {
                log.silly('PuppetWechat4u', 'constructor() lruOptions.dispose(%s, %s)', key, JSON.stringify(val));
            },
        };
        this.cacheMessageRawPayload = new QuickLru(lruOptions);
    }
    version() { return `${VERSION}<${super.version()}>`; }
    name() { return `${NAME}<${super.name()}>`; }
    async onStart() {
        log.verbose('PuppetWechat4u', 'onStart() with %s', this.memory.name || 'NONAME');
        if (this.wechat4u) {
            log.warn('PuppetWechat4u', 'onStart() wechat4u exist, will be overwrited');
        }
        /**
         * Huan(202110): rename `onStart()` to `tryStart()`
         *  then we will be able to use `MemoryMixin`
         *  to init MemoryCard for the child puppet
         */
        try {
            await this.memory.load();
        }
        catch (_) { }
        // console.info('faint 1')
        const syncData = await this.memory.get(MEMORY_SLOT_NAME);
        // console.info('faint 2')
        if (syncData) {
            this.wechat4u = new Wechat4u(syncData);
        }
        else {
            this.wechat4u = new Wechat4u();
        }
        this.monkeyPatch(this.wechat4u);
        this.initHookEvents(this.wechat4u);
        /**
         * Should not `await` onStart/restart for wechat4u
         * because it will blocks...
         */
        if (this.wechat4u.PROP.uin) {
            // å­˜åœ¨ç™»å½•æ•°æ®æ—¶ï¼Œå¯ä»¥éšæ—¶è°ƒç”¨restartè¿›è¡Œé‡å¯
            this.wechat4u.restart();
        }
        else {
            this.wechat4u.start();
        }
    }
    monkeyPatch(wechat4u) {
        log.silly('PuppetWechat4u', 'monkeyPatch()');
        // fake wechat4u to think as we had logined.)
        this.monkeyPatchOffState(wechat4u, 'checkLogin', Promise.resolve({ code: 200 }));
        this.monkeyPatchOffState(wechat4u, 'login', Promise.resolve());
        this.monkeyPatchOffState(wechat4u, '_init', Promise.resolve());
        this.monkeyPatchHook(wechat4u, 'syncCheck', () => {
            log.silly('PuppetWechat4u', 'monkeyPatch() monkeyPatchHook() wechat4u.syncCheck()');
            this.emit('heartbeat', { data: 'syncCheck()' });
        });
        /**
         * Disable Wechat4u for Sending Message to Filehelper when Heartbeat.
         */
        // tslint:disable-next-line
        // console.log(Object.keys(wechat4u))
        // tslint:disable-next-line:no-string-literal
        wechat4u['checkPolling'] = () => {
            log.silly('PuppetWechat4u', 'monkeyPatch() wechat4u.checkPolling()');
            if (this.state.inactive()) {
                return;
            }
            wechat4u.notifyMobile()
                .catch((err) => {
                log.warn('PuppetWechat4u', 'monkeyPatch() wechat4u.checkPolling() notifyMobile() exception: %s', err);
                wechat4u.emit('error', err);
            });
            clearTimeout(wechat4u.checkPollingId);
            wechat4u.checkPollingId = setTimeout(() => wechat4u.checkPolling(), wechat4u._getPollingInterval());
        };
        // è‡ªå®šä¹‰å¿ƒè·³é—´éš”ï¼ˆä»¥æ¯«ç§’ä¸ºå•ä½ï¼‰
        // 25 days: https://stackoverflow.com/a/12633556/1123955
        // this.wechat4u.setPollingIntervalGetter(() => Math.pow(2,31) - 1)
    }
    /**
     * Monkey Patch for Wechat4u
     *  - https://www.audero.it/blog/2016/12/05/monkey-patching-javascript/#what-is-monkey-patching
     *
     * What is Monkey patching?
     *  Monkey patching is a technique to add, modify, or suppress
     *  the default behavior of a piece of code at runtime
     *  without changing its original source code.
     */
    monkeyPatchOffState(wechat4u, func, valueWhenLogouted) {
        log.verbose('PuppetWechat4u', 'monkeyPatchOffState(wechat4u, %s)', func);
        const puppetThis = this;
        const funcOrig = wechat4u[func];
        function funcNew() {
            log.verbose('PuppetWechat4u', 'monkeyPatchOffState(%s) funcNew()', func);
            if (puppetThis.state.inactive()) {
                log.verbose('PuppetWechat4u', 'monkeyPatchOffState(%s) funcNew() state.off() is true, return', func);
                return valueWhenLogouted;
            }
            return funcOrig.call(this);
        }
        wechat4u[func] = funcNew;
    }
    monkeyPatchHook(wechat4u, func, hookFunc) {
        log.verbose('PuppetWechat4u', 'monkeyPatchHook(wechat4u, %s, func)', func);
        const funcOrig = wechat4u[func];
        function funcNew() {
            log.silly('PuppetWechat4u', 'monkeyPatchHook(wechat4u, %s, func) funcNew()', func);
            hookFunc();
            return funcOrig.call(this);
        }
        wechat4u[func] = funcNew;
    }
    initHookEvents(wechat4u) {
        log.verbose('PuppetWechat4u', 'initHookEvents()');
        /**
         * uuidäº‹ä»¶ï¼Œå‚æ•°ä¸ºuuidï¼Œæ ¹æ®uuidç”ŸæˆäºŒç»´ç 
         */
        this.wechat4u.on('uuid', (uuid) => {
            log.silly('PuppetWechat4u', 'initHookEvents() wechat4u.on(uuid)');
            this.scanQrCode = 'https://login.weixin.qq.com/l/' + uuid;
            this.emit('scan', { qrcode: this.scanQrCode, status: PUPPET.types.ScanStatus.Waiting });
        });
        /**
         * ç™»å½•ç”¨æˆ·å¤´åƒäº‹ä»¶ï¼Œæ‰‹æœºæ‰«æåŽå¯ä»¥å¾—åˆ°ç™»å½•ç”¨æˆ·å¤´åƒçš„Data URL
         */
        wechat4u.on('user-avatar', (avatarDataUrl) => {
            this.emit('scan', {
                data: avatarDataUrl,
                qrcode: this.scanQrCode || '',
                status: PUPPET.types.ScanStatus.Scanned,
            });
        });
        /**
         * ç™»å½•æˆåŠŸäº‹ä»¶
         */
        wechat4u.on('login', async () => {
            // FIXME: where's the logined user id?
            const userId = this.wechat4u.user.UserName;
            if (!userId) {
                this.emit('error', {
                    data: GError.stringify(new Error('login event can not found selfId')),
                });
                return;
            }
            await this.login(userId);
            // ä¿å­˜æ•°æ®ï¼Œå°†æ•°æ®åºåˆ—åŒ–ä¹‹åŽä¿å­˜åˆ°ä»»æ„ä½ç½®
            await this.memory.set(MEMORY_SLOT_NAME, wechat4u.botData);
            await this.memory.save();
        });
        /**
         * ç™»å‡ºæˆåŠŸäº‹ä»¶
         */
        wechat4u.on('logout', async () => {
            if (this.isLoggedIn) {
                await this.logout();
            }
            // æ¸…é™¤æ•°æ®
            await this.memory.delete(MEMORY_SLOT_NAME);
            await this.memory.save();
        });
        /**
         * è”ç³»äººæ›´æ–°äº‹ä»¶ï¼Œå‚æ•°ä¸ºè¢«æ›´æ–°çš„è”ç³»äººåˆ—è¡¨
         */
        wechat4u.on('contacts-updated', (contacts) => {
            log.silly('PuppetWechat4u', 'initHookEvents() wechat4u.on(contacts-updated) new/total contacts.length=%d/%d', contacts.length, Object.keys(wechat4u.contacts).length);
        });
        /**
         * é”™è¯¯äº‹ä»¶ï¼Œå‚æ•°ä¸€èˆ¬ä¸ºErrorå¯¹è±¡
         */
        wechat4u.on('error', (err) => {
            this.emit('error', {
                data: GError.stringify(err),
            });
        });
        /**
         * å¦‚ä½•å¤„ç†ä¼šè¯æ¶ˆæ¯
         */
        wechat4u.on('message', (msg) => {
            if (!msg.MsgId) {
                log.warn('PuppetWechat4u', 'initHookEvents() wechat4u.on(message) no message id: %s', JSON.stringify(msg));
                throw new Error('no id');
            }
            this.cacheMessageRawPayload.set(msg.MsgId, msg);
            switch (msg.MsgType) {
                case WebMessageType.STATUSNOTIFY:
                    // Skip this internal type
                    break;
                case WebMessageType.VERIFYMSG:
                    this.emit('friendship', { friendshipId: msg.MsgId });
                    break;
                case WebMessageType.SYS:
                    if (this.isFriendConfirm(msg.Content)) {
                        this.emit('friendship', { friendshipId: msg.MsgId });
                    }
                    this.emit('message', { messageId: msg.MsgId });
                    break;
                default:
                    this.emit('message', { messageId: msg.MsgId });
                    break;
            }
            /**
             * èŽ·å–æ¶ˆæ¯æ—¶é—´
             */
            // console.log(`----------${msg.getDisplayTime()}----------`)
            /**
             * èŽ·å–æ¶ˆæ¯å‘é€è€…çš„æ˜¾ç¤ºå
             */
            // console.log(wechat4u.contacts[msg.FromUserName].getDisplayName())
        });
    }
    async onStop() {
        log.verbose('PuppetWechat4u', 'onStop()');
        this.wechat4u.stop();
        this.wechat4u = undefined;
    }
    async ding(data) {
        log.silly('PuppetWechat4u', 'ding(%s)', data || '');
        this.emit('dong', { data });
    }
    isFriendConfirm(text) {
        const friendConfirmRegexpList = [
            /^You have added (.+) as your WeChat contact. Start chatting!$/,
            /^ä½ å·²æ·»åŠ äº†(.+)ï¼ŒçŽ°åœ¨å¯ä»¥å¼€å§‹èŠå¤©äº†ã€‚$/,
            /^(.+) just added you to his\/her contacts list. Send a message to him\/her now!$/,
            /^(.+)åˆšåˆšæŠŠä½ æ·»åŠ åˆ°é€šè®¯å½•ï¼ŒçŽ°åœ¨å¯ä»¥å¼€å§‹èŠå¤©äº†ã€‚$/,
        ];
        let found = false;
        friendConfirmRegexpList.some(re => !!(found = re.test(text)));
        return found;
    }
    /**
     *
     * ContactSelf
     *
     *
     */
    async contactSelfQRCode() {
        return PUPPET.throwUnsupportedError();
    }
    async contactSelfName(name) {
        return PUPPET.throwUnsupportedError(name);
    }
    async contactSelfSignature(signature) {
        return PUPPET.throwUnsupportedError(signature);
    }
    async contactAlias(contactId, alias) {
        log.verbose('PuppetWechat4u', 'contactAlias(%s, %s)', contactId, alias);
        if (typeof alias === 'undefined') {
            const payload = await this.contactPayload(contactId);
            return payload.alias;
        }
        await this.wechat4u.updateRemarkName(contactId, alias);
    }
    async contactList() {
        log.verbose('PuppetWechat4u', 'contactList()');
        const idList = this.wechat4u.contacts
            .filter((contact) => !contact.isRoomContact())
            .map((rawPayload) => rawPayload.UserName);
        return idList;
    }
    async contactAvatar(contactId, file) {
        log.verbose('PuppetWechat4u', 'contactAvatar(%s)', contactId);
        if (file) {
            return PUPPET.throwUnsupportedError();
        }
        const rawPayload = await this.contactRawPayload(contactId);
        const payload = await this.contactPayload(contactId);
        const name = payload.name;
        const res = await this.wechat4u.getHeadImg(rawPayload.HeadImgUrl);
        /**
         * å¦‚ä½•èŽ·å–è”ç³»äººå¤´åƒ
         */
        return FileBox.fromStream(res.data, `wechaty-contact-avatar-${name}.jpg`);
    }
    async contactRawPayload(contactId) {
        log.verbose('PuppetWechat4u', 'contactRawPayload(%s) with contacts.length=%d', contactId, Object.keys(this.wechat4u.contacts).length);
        if (!(contactId in this.wechat4u.contacts)) {
            try {
                const userDataList = [
                    {
                        EncryChatRoomId: '',
                        UserName: contactId,
                    },
                ];
                const result = await this.wechat4u.batchGetContact(userDataList);
                log.silly('PuppetWechat4u', 'contactRawPayload(%s) wechat4u.batchGetContact() result: %s', JSON.stringify(result));
                this.wechat4u.updateContacts(result);
            }
            catch (e) {
                log.warn('PuppetWechat4u', 'contactRawPayload(%s) wechat4u.batchGetContact() exception: %s', e);
            }
        }
        const rawPayload = await retry(async (retryException, attempt) => {
            log.verbose('PuppetWechat4u', 'contactRawPayload(%s) retry() attempt=%d', contactId, attempt);
            if (contactId in this.wechat4u.contacts) {
                return this.wechat4u.contacts[contactId];
            }
            retryException(new Error('no this.wechat4u.contacts[' + contactId + ']'));
        });
        return rawPayload;
    }
    async contactRawPayloadParser(rawPayload) {
        log.silly('PuppetWechat4u', 'contactParseRawPayload(Object.keys(payload).length=%d)', Object.keys(rawPayload).length);
        if (!Object.keys(rawPayload).length) {
            log.error('PuppetWechat4u', 'contactParseRawPayload(Object.keys(payload).length=%d)', Object.keys(rawPayload).length);
            log.error('PuppetWechat4u', 'contactParseRawPayload() got empty rawPayload!');
            throw new Error('empty raw payload');
            // return {
            //   gender: Gender.Unknown,
            //   type:   Contact.Type.Unknown,
            // }
        }
        // this.id = rawPayload.UserName   // MMActualSender??? MMPeerUserName???
        // `getUserContact(message.MMActualSender,message.MMPeerUserName).HeadImgUrl`
        // uin:        rawPayload.Uin,    // stable id: 4763975 || getCookie("wxuin")
        return {
            address: rawPayload.Alias,
            alias: rawPayload.RemarkName,
            avatar: rawPayload.HeadImgUrl,
            city: rawPayload.City,
            friend: rawPayload.stranger === undefined
                ? undefined
                : !rawPayload.stranger,
            gender: rawPayload.Sex,
            id: rawPayload.UserName,
            name: rawPayload.NickName || '',
            phone: [],
            province: rawPayload.Province,
            signature: rawPayload.Signature,
            star: !!rawPayload.StarFriend,
            weixin: rawPayload.Alias,
            // tslint:disable:max-line-length
            /**
             * @see 1. https://github.com/Chatie/webwx-app-tracker/blob/7c59d35c6ea0cff38426a4c5c912a086c4c512b2/formatted/webwxApp.js#L3243
             * @see 2. https://github.com/Urinx/WeixinBot/blob/master/README.md
             * @ignore
             */
            // eslint-disable-next-line sort-keys
            type: (!!rawPayload.UserName && !rawPayload.UserName.startsWith('@@') && !!(rawPayload.VerifyFlag & 8))
                ? PUPPET.types.Contact.Official
                : PUPPET.types.Contact.Individual,
            /**
             * @see 1. https://github.com/Chatie/webwx-app-tracker/blob/7c59d35c6ea0cff38426a4c5c912a086c4c512b2/formatted/webwxApp.js#L3246
             * @ignore
             */
            // special:       specialContactList.indexOf(rawPayload.UserName) > -1 || /@qqim$/.test(rawPayload.UserName),
        };
    }
    /**
     *
     * Message
     *
     */
    async messageContact(messageId) {
        log.verbose('PuppetWechat4u', 'messageContact(%s)', messageId);
        return PUPPET.throwUnsupportedError();
    }
    async messageRecall(messageId) {
        log.verbose('PuppetWechat4u', 'messageRecall(%s)', messageId);
        return PUPPET.throwUnsupportedError();
    }
    async messageImage(messageId, imageType) {
        log.verbose('PuppetWechat4u', 'messageImage(%s, %s[%s])', messageId, imageType, PUPPET.types.Image[imageType]);
        return PUPPET.throwUnsupportedError();
    }
    async messageFile(id) {
        log.verbose('PuppetWechat4u', 'messageFile(%s)', id);
        const payload = await this.messagePayload(id);
        const rawPayload = await this.messageRawPayload(id);
        const filename = payload.filename || 'unknown.txt';
        /**
         * åˆ¤æ–­æ¶ˆæ¯ç±»åž‹
         */
        switch (rawPayload.MsgType) {
            case this.wechat4u.CONF.MSGTYPE_TEXT:
                /**
                 * æ–‡æœ¬æ¶ˆæ¯
                 */
                throw new Error('msg type is text');
            case this.wechat4u.CONF.MSGTYPE_EMOTICON:
            /**
             * è¡¨æƒ…æ¶ˆæ¯
             */
            // eslint-disable-next-lint no-fallthrough
            case this.wechat4u.CONF.MSGTYPE_IMAGE:
                /**
                 * å›¾ç‰‡æ¶ˆæ¯
                 */
                // console.log('å›¾ç‰‡æ¶ˆæ¯ï¼Œä¿å­˜åˆ°æœ¬åœ°')
                return FileBox.fromStream((await this.wechat4u.getMsgImg(rawPayload.MsgId)).data, filename);
            case this.wechat4u.CONF.MSGTYPE_VOICE:
                /**
                 * è¯­éŸ³æ¶ˆæ¯
                 */
                // console.log('è¯­éŸ³æ¶ˆæ¯ï¼Œä¿å­˜åˆ°æœ¬åœ°')
                return FileBox.fromStream((await this.wechat4u.getVoice(rawPayload.MsgId)).data, filename);
            case this.wechat4u.CONF.MSGTYPE_VIDEO:
            case this.wechat4u.CONF.MSGTYPE_MICROVIDEO:
                /**
                 * è§†é¢‘æ¶ˆæ¯
                 */
                // console.log('è§†é¢‘æ¶ˆæ¯ï¼Œä¿å­˜åˆ°æœ¬åœ°')
                return FileBox.fromStream((await this.wechat4u.getVideo(rawPayload.MsgId)).data, filename);
            case this.wechat4u.CONF.MSGTYPE_APP:
                if (rawPayload.AppMsgType === 6) {
                    /**
                     * æ–‡ä»¶æ¶ˆæ¯
                     */
                    // console.log('æ–‡ä»¶æ¶ˆæ¯ï¼Œä¿å­˜åˆ°æœ¬åœ°')
                    return FileBox.fromStream((await this.wechat4u.getDoc(rawPayload.FromUserName, rawPayload.MediaId, rawPayload.FileName)).data, filename);
                }
                break;
            default:
                break;
        }
        throw new Error('unsupported message. id: ' + id);
    }
    async messageUrl(messageId) {
        return PUPPET.throwUnsupportedError(messageId);
    }
    async messageMiniProgram(messageId) {
        log.verbose('PuppetWechat4u', 'messageMiniProgram(%s)', messageId);
        return PUPPET.throwUnsupportedError(messageId);
    }
    async messageRawPayload(id) {
        log.verbose('PuppetWechat4u', 'messageRawPayload(%s)', id);
        const rawPayload = this.cacheMessageRawPayload.get(id);
        if (!rawPayload) {
            throw new Error('id not found');
        }
        return rawPayload;
    }
    async messageRawPayloadParser(rawPayload) {
        log.verbose('PuppetWechat4u', 'messageRawPayloadParser(%s) @ %s', rawPayload, this);
        // console.log(rawPayload)
        const payload = messageRawPayloadParser(rawPayload);
        return payload;
    }
    async messageSendText(conversationId, text) {
        log.verbose('PuppetWechat4u', 'messageSend(%s, %s)', conversationId, text);
        /**
         * å‘é€æ–‡æœ¬æ¶ˆæ¯ï¼Œå¯ä»¥åŒ…å«emoji(ðŸ˜’)å’ŒQQè¡¨æƒ…([åç¬‘])
         */
        await this.wechat4u.sendMsg(text, conversationId);
        /**
         * { BaseResponse: { Ret: 0, ErrMsg: '' },
         *  MsgID: '830582407297708303',
         *  LocalID: '15279119663740094' }
         */
    }
    async messageSendFile(conversationId, file) {
        log.verbose('PuppetWechat4u', 'messageSend(%s, %s)', conversationId, file);
        /**
         * é€šè¿‡è¡¨æƒ…MD5å‘é€è¡¨æƒ…
         */
        // wechat4u.sendMsg({
        //   emoticonMd5: '00c801cdf69127550d93ca52c3f853ff'
        // }, ToUserName)
        //   .catch(err => {
        //     bot.emit('error', err)
        //   })
        /**
         * ä»¥ä¸‹é€šè¿‡ä¸Šä¼ æ–‡ä»¶å‘é€å›¾ç‰‡ï¼Œè§†é¢‘ï¼Œé™„ä»¶ç­‰
         * é€šç”¨æ–¹æ³•ä¸ºå…¥ä¸‹
         * fileä¸ºå¤šç§ç±»åž‹
         * filenameå¿…å¡«ï¼Œä¸»è¦ä¸ºäº†åˆ¤æ–­æ–‡ä»¶ç±»åž‹
         */
        await this.wechat4u.sendMsg({
            file: await file.toStream(),
            filename: file.name,
        }, conversationId);
    }
    async messageSendContact(conversationId, contactId) {
        log.verbose('PuppetWechat4u', 'messageSend("%s", %s)', conversationId, contactId);
        PUPPET.throwUnsupportedError();
    }
    async messageSendUrl(conversationId, urlLinkPayload) {
        PUPPET.throwUnsupportedError(conversationId, urlLinkPayload);
    }
    async messageSendMiniProgram(conversationId, miniProgramPayload) {
        log.verbose('PuppetWechat4u', 'messageSendMiniProgram("%s", %s)', JSON.stringify(conversationId), JSON.stringify(miniProgramPayload));
        PUPPET.throwUnsupportedError(conversationId, miniProgramPayload);
    }
    async messageForward(conversationid, messageId) {
        log.verbose('PuppetWechat4u', 'messageForward(%s, %s)', conversationid, messageId);
        const rawPayload = await this.messageRawPayload(messageId);
        /**
         * å¦‚ä½•ç›´æŽ¥è½¬å‘æ¶ˆæ¯
         */
        await this.wechat4u.forwardMsg(rawPayload, conversationid);
    }
    async conversationReadMark(conversationId, hasRead) {
        return PUPPET.throwUnsupportedError(conversationId, hasRead);
    }
    /**
     *
     * Room Invitation
     *
     */
    async roomInvitationAccept(roomInvitationId) {
        return PUPPET.throwUnsupportedError(roomInvitationId);
    }
    async roomInvitationRawPayload(roomInvitationId) {
        return PUPPET.throwUnsupportedError(roomInvitationId);
    }
    async roomInvitationRawPayloadParser(rawPayload) {
        return PUPPET.throwUnsupportedError(rawPayload);
    }
    /**
     *
     * Room
     *
     */
    async roomRawPayload(id) {
        log.verbose('PuppetWechat4u', 'roomRawPayload(%s)', id);
        const rawPayload = await retry((retryException, attempt) => {
            log.verbose('PuppetWechat4u', 'contactRawPayload(%s) retry() attempt=%d', id, attempt);
            if (!this.wechat4u.contacts[id]) {
                retryException(new Error('no this.wechat4u.contacts[' + id + ']'));
            }
            return this.wechat4u.contacts[id];
        });
        return rawPayload;
    }
    async roomRawPayloadParser(rawPayload) {
        log.verbose('PuppetWechat4u', 'roomRawPayloadParser(%s)', rawPayload);
        const id = rawPayload.UserName;
        // const rawMemberList = rawPayload.MemberList || []
        // const memberIdList  = rawMemberList.map(rawMember => rawMember.UserName)
        // const aliasDict = {} as { [id: string]: string | undefined }
        // if (Array.isArray(rawPayload.MemberList)) {
        //   rawPayload.MemberList.forEach(rawMember => {
        //     aliasDict[rawMember.UserName] = rawMember.DisplayName
        //   })
        // }
        const memberIdList = rawPayload.MemberList
            ? rawPayload.MemberList.map(m => m.UserName)
            : [];
        const roomPayload = {
            adminIdList: [],
            id,
            memberIdList,
            topic: rawPayload.NickName || '',
            // aliasDict,
        };
        return roomPayload;
    }
    async roomList() {
        log.verbose('PuppetWechat4u', 'roomList()');
        const idList = this.wechat4u.contacts
            .filter((contact) => contact.isRoomContact())
            .map((rawPayload) => rawPayload.UserName);
        return idList;
    }
    async roomDel(roomId, contactId) {
        log.verbose('PuppetWechat4u', 'roomDel(%s, %s)', roomId, contactId);
        const type = 'delmember';
        // XXX: [contactId] or [{ UserName: id }, ...] ?
        await this.wechat4u.updateChatroom(roomId, [contactId], type);
    }
    async roomAvatar(roomId) {
        log.verbose('PuppetWechat4u', 'roomAvatar(%s)', roomId);
        const payload = await this.roomPayload(roomId);
        if (payload.avatar) {
            // FIXME: set http headers with cookies
            return FileBox.fromUrl(payload.avatar);
        }
        log.warn('PuppetWechat4u', 'roomAvatar() avatar not found, use the chatie default.');
        return qrCodeForChatie();
    }
    async roomAdd(roomId, contactId) {
        log.verbose('PuppetWechat4u', 'roomAdd(%s, %s)', roomId, contactId);
        const roomPayload = await this.roomPayload(roomId);
        // TODO: if the room owner enabled "invite only?"
        let type = 'addmember'; // invitemember ???
        if (roomPayload.memberIdList.length > 40) {
            type = 'invitemember';
        }
        // https://github.com/nodeWechat/wechat4u/tree/46931e78bcb56899b8d2a42a37b919e7feaebbef#botupdatechatroomchatroomusername-memberlist-fun
        const ret = await this.wechat4u.updateChatroom(roomId, [contactId], type);
        log.verbose('PuppetWechat4u', 'roomAdd(%s, %s) ret: %s', roomId, contactId, JSON.stringify(ret));
    }
    async roomTopic(roomId, topic) {
        log.verbose('PuppetWechat4u', 'roomTopic(%s, %s)', roomId, topic);
        const roomPayload = await this.roomPayload(roomId);
        if (typeof topic === 'undefined') {
            return roomPayload.topic;
        }
        await this.wechat4u.updateChatRoomName(roomId, topic);
    }
    async roomCreate(contactIdList, topic) {
        log.verbose('PuppetWechat4u', 'roomCreate(%s, %s)', contactIdList, topic);
        const memberList = contactIdList.map(id => ({ UserName: id }));
        const roomId = await this.wechat4u.createChatroom(topic, memberList);
        return roomId;
    }
    async roomAnnounce(roomId, text) {
        return PUPPET.throwUnsupportedError(roomId, text);
    }
    async roomQuit(roomId) {
        return PUPPET.throwUnsupportedError(roomId);
    }
    async roomQRCode(roomId) {
        return PUPPET.throwUnsupportedError(roomId);
    }
    async roomMemberList(roomId) {
        log.verbose('PuppetWechat4u', 'roommemberList(%s)', roomId);
        const rawPayload = await this.roomRawPayload(roomId);
        const memberIdList = (rawPayload.MemberList || [])
            .map(member => member.UserName);
        return memberIdList;
    }
    async roomMemberRawPayload(roomId, contactId) {
        log.verbose('PuppetWechat4u', 'roomMemberRawPayload(%s, %s)', roomId, contactId);
        const rawPayload = await this.roomRawPayload(roomId);
        const memberPayloadList = rawPayload.MemberList || [];
        const memberPayloadResult = memberPayloadList.filter(payload => payload.UserName === contactId);
        if (memberPayloadResult.length > 0) {
            return memberPayloadResult[0];
        }
        else {
            throw new Error('not found');
        }
    }
    async roomMemberRawPayloadParser(rawPayload) {
        log.verbose('PuppetWechat4u', 'roomMemberRawPayloadParser(%s)', rawPayload);
        const payload = {
            avatar: rawPayload.HeadImgUrl,
            id: rawPayload.UserName,
            name: rawPayload.NickName,
            roomAlias: rawPayload.DisplayName,
        };
        return payload;
    }
    /**
     *
     * Friendship
     *
     */
    async friendshipSearchPhone(phone) {
        log.verbose('PuppetWechat4u', 'friendshipSearchPhone(%s)', phone);
        return PUPPET.throwUnsupportedError();
    }
    async friendshipSearchWeixin(weixin) {
        log.verbose('PuppetWechat4u', 'friendshipSearchWeixin(%s)', weixin);
        return PUPPET.throwUnsupportedError();
    }
    async friendshipAdd(contactId, hello) {
        log.verbose('PuppetWechat4u', 'friendshipAdd(%s, %s)', contactId, hello);
        await this.wechat4u.addFriend(contactId, hello);
    }
    async friendshipAccept(friendshipId) {
        log.verbose('PuppetWechat4u', 'friendshipAccept(%s)', friendshipId);
        const payload = await this.friendshipPayload(friendshipId);
        await this.wechat4u.verifyUser(payload.contactId, payload.ticket);
    }
    async friendshipRawPayload(id) {
        log.verbose('PuppetWechat4u', 'friendshipRawPayload(%s)', id);
        const rawPayload = this.cacheMessageRawPayload.get(id);
        if (!rawPayload) {
            throw new Error('no rawPayload');
        }
        return rawPayload;
    }
    async friendshipRawPayloadParser(rawPayload) {
        log.verbose('PuppetWechat4u', 'friendshipRawPayloadParser(%s)', rawPayload);
        const timestamp = Math.floor(Date.now() / 1000); // in seconds
        switch (rawPayload.MsgType) {
            case WebMessageType.VERIFYMSG: {
                const recommendInfo = rawPayload.RecommendInfo;
                if (!recommendInfo) {
                    throw new Error('no recommendInfo');
                }
                const payloadReceive = {
                    contactId: recommendInfo.UserName,
                    hello: recommendInfo.Content,
                    id: rawPayload.MsgId,
                    ticket: recommendInfo.Ticket,
                    timestamp,
                    type: PUPPET.types.Friendship.Receive,
                };
                return payloadReceive;
            }
            case WebMessageType.SYS: {
                const payloadConfirm = {
                    contactId: rawPayload.FromUserName,
                    id: rawPayload.MsgId,
                    timestamp,
                    type: PUPPET.types.Friendship.Confirm,
                };
                return payloadConfirm;
            }
            default:
                throw new Error('not supported friend request message raw payload');
        }
    }
    /**
     *
     * Tag
     *
     */
    async tagContactAdd(tagId, contactId) {
        log.verbose('PuppetWechat4u', 'tagContactAdd(%s)', tagId, contactId);
    }
    async tagContactRemove(tagId, contactId) {
        log.verbose('PuppetWechat4u', 'tagContactRemove(%s)', tagId, contactId);
    }
    async tagContactDelete(tagId) {
        log.verbose('PuppetWechat4u', 'tagContactDelete(%s)', tagId);
    }
    async tagContactList(contactId) {
        log.verbose('PuppetWechat4u', 'tagContactList(%s)', contactId);
        return [];
    }
    contactCorporationRemark(..._) {
        return PUPPET.throwUnsupportedError();
    }
    contactDescription(..._) {
        return PUPPET.throwUnsupportedError();
    }
    contactPhone(..._) {
        return PUPPET.throwUnsupportedError();
    }
    async messageLocation(messageId) {
        return PUPPET.throwUnsupportedError(messageId);
    }
    async messageSendLocation(conversationId, locationPayload) {
        return PUPPET.throwUnsupportedError(conversationId, locationPayload);
    }
}
export default PuppetWechat4u;
//# sourceMappingURL=puppet-wechat4u.js.map